# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
# pylint: disable=useless-super-delegation

import datetime
from typing import Any, Literal, Mapping, Optional, TYPE_CHECKING, Union, overload

from .._utils.model_base import Model as _Model, rest_discriminator, rest_field
from ._enums import (
    BatchDeploymentConfigurationType,
    ComputeType,
    ConnectionAuthType,
    CredentialsType,
    DataGenerationType,
    DataReferenceCredentialType,
    DataType,
    DatastoreType,
    DistributionType,
    EarlyTerminationPolicyType,
    EndpointComputeType,
    EndpointType,
    ForecastHorizonMode,
    IdentityConfigurationType,
    JobInputType,
    JobLimitsType,
    JobOutputType,
    JobType,
    ModelProvider,
    MonitorComputeIdentityType,
    MonitorComputeType,
    MonitoringFeatureDataType,
    MonitoringFeatureFilterType,
    MonitoringInputDataType,
    MonitoringSignalType,
    NCrossValidationsMode,
    NodesValueType,
    OneLakeArtifactType,
    PendingUploadCredentialType,
    ReferenceType,
    RuleType,
    SamplingAlgorithmType,
    ScaleType,
    ScheduleActionType,
    SeasonalityMode,
    SecretsType,
    SparkJobEntryType,
    TargetLagsMode,
    TargetRollingWindowSizeMode,
    TaskType,
    TriggerType,
    WebhookType,
)

if TYPE_CHECKING:
    from .. import models as _models


class WorkspaceConnectionPropertiesV2(_Model):
    """WorkspaceConnectionPropertiesV2.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AADAuthTypeWorkspaceConnectionProperties, AccessKeyAuthTypeWorkspaceConnectionProperties,
    AccountKeyAuthTypeWorkspaceConnectionProperties, ApiKeyAuthWorkspaceConnectionProperties,
    CustomKeysWorkspaceConnectionProperties, ManagedIdentityAuthTypeWorkspaceConnectionProperties,
    NoneAuthTypeWorkspaceConnectionProperties, OAuth2AuthTypeWorkspaceConnectionProperties,
    PATAuthTypeWorkspaceConnectionProperties, SASAuthTypeWorkspaceConnectionProperties,
    ServicePrincipalAuthTypeWorkspaceConnectionProperties,
    UsernamePasswordAuthTypeWorkspaceConnectionProperties

    :ivar auth_type: Authentication type of the connection target. Required. Known values are:
     "PAT", "ManagedIdentity", "UsernamePassword", "None", "SAS", "AccountKey", "ServicePrincipal",
     "AccessKey", "ApiKey", "CustomKeys", "OAuth2", "AAD", "DelegatedSAS", "ProjectManagedIdentity",
     "AccountManagedIdentity", "UserEntraToken", "AgentUserImpersonation", "AgenticIdentityToken",
     and "AgenticUser".
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.ConnectionAuthType
    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    """

    __mapping__: dict[str, _Model] = {}
    auth_type: str = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])
    """Authentication type of the connection target. Required. Known values are: \"PAT\",
     \"ManagedIdentity\", \"UsernamePassword\", \"None\", \"SAS\", \"AccountKey\",
     \"ServicePrincipal\", \"AccessKey\", \"ApiKey\", \"CustomKeys\", \"OAuth2\", \"AAD\",
     \"DelegatedSAS\", \"ProjectManagedIdentity\", \"AccountManagedIdentity\", \"UserEntraToken\",
     \"AgentUserImpersonation\", \"AgenticIdentityToken\", and \"AgenticUser\"."""
    category: Optional[Union[str, "_models.ConnectionCategory"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Category of the connection. Known values are: \"PythonFeed\", \"ContainerRegistry\", \"Git\",
     \"S3\", \"Snowflake\", \"AzureKeyVault\", \"AzureSqlDb\", \"AzureSynapseAnalytics\",
     \"AzureMySqlDb\", \"AzurePostgresDb\", \"ADLSGen2\", \"AzureContainerAppEnvironment\",
     \"Redis\", \"ApiKey\", \"AzureOpenAI\", \"AIServices\", \"CognitiveSearch\",
     \"CognitiveService\", \"CustomKeys\", \"AzureBlob\", \"AzureStorageAccount\", \"AzureOneLake\",
     \"CosmosDb\", \"CosmosDbMongoDbApi\", \"AzureDataExplorer\", \"AzureMariaDb\",
     \"AzureDatabricksDeltaLake\", \"AzureSqlMi\", \"AzureTableStorage\", \"AmazonRdsForOracle\",
     \"AmazonRdsForSqlServer\", \"AmazonRedshift\", \"Db2\", \"Drill\", \"GoogleBigQuery\",
     \"Greenplum\", \"Hbase\", \"Hive\", \"Impala\", \"Informix\", \"MariaDb\", \"MicrosoftAccess\",
     \"MySql\", \"Netezza\", \"Oracle\", \"Phoenix\", \"PostgreSql\", \"Presto\", \"SapOpenHub\",
     \"SapBw\", \"SapHana\", \"SapTable\", \"Spark\", \"SqlServer\", \"Sybase\", \"Teradata\",
     \"Vertica\", \"Pinecone\", \"Databricks\", \"Cassandra\", \"Couchbase\", \"MongoDbV2\",
     \"MongoDbAtlas\", \"AmazonS3Compatible\", \"FileServer\", \"FtpServer\",
     \"GoogleCloudStorage\", \"Hdfs\", \"OracleCloudStorage\", \"Sftp\", \"GenericHttp\",
     \"ODataRest\", \"Odbc\", \"GenericRest\", \"RemoteTool\", \"AmazonMws\", \"Concur\",
     \"Dynamics\", \"DynamicsAx\", \"DynamicsCrm\", \"GoogleAdWords\", \"Hubspot\", \"Jira\",
     \"Magento\", \"Marketo\", \"Office365\", \"Eloqua\", \"Responsys\", \"OracleServiceCloud\",
     \"PayPal\", \"QuickBooks\", \"Salesforce\", \"SalesforceServiceCloud\",
     \"SalesforceMarketingCloud\", \"SapCloudForCustomer\", \"SapEcc\", \"ServiceNow\",
     \"SharePointOnlineList\", \"Shopify\", \"Square\", \"WebTable\", \"Xero\", \"Zoho\",
     \"GenericContainerRegistry\", \"Elasticsearch\", \"AppInsights\", \"AppConfig\", \"OpenAI\",
     \"Serp\", \"BingLLMSearch\", \"Serverless\", \"ManagedOnlineEndpoint\", \"ApiManagement\",
     \"ModelGateway\", \"GroundingWithBingSearch\", \"GroundingWithCustomSearch\", \"Sharepoint\",
     \"MicrosoftFabric\", \"PowerPlatformEnvironment\", and \"RemoteA2A\"."""
    created_by_workspace_arm_id: Optional[str] = rest_field(name="createdByWorkspaceArmId", visibility=["read"])
    error: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    expiry_time: Optional[datetime.datetime] = rest_field(
        name="expiryTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    group: Optional[Union[str, "_models.ConnectionGroup"]] = rest_field(visibility=["read"])
    """Group based on connection category. Known values are: \"Azure\", \"AzureAI\", \"Database\",
     \"NoSQL\", \"File\", \"GenericProtocol\", and \"ServicesAndApps\"."""
    is_shared_to_all: Optional[bool] = rest_field(
        name="isSharedToAll", visibility=["read", "create", "update", "delete", "query"]
    )
    metadata: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Store user metadata for this connection."""
    pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = rest_field(
        name="peRequirement", visibility=["read", "create", "update", "delete", "query"]
    )
    """Known values are: \"Required\", \"NotRequired\", and \"NotApplicable\"."""
    pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = rest_field(
        name="peStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """Known values are: \"Inactive\", \"Active\", and \"NotApplicable\"."""
    shared_user_list: Optional[list[str]] = rest_field(
        name="sharedUserList", visibility=["read", "create", "update", "delete", "query"]
    )
    target: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    use_workspace_managed_identity: Optional[bool] = rest_field(
        name="useWorkspaceManagedIdentity", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        auth_type: str,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AADAuthTypeWorkspaceConnectionProperties(WorkspaceConnectionPropertiesV2, discriminator="AAD"):
    """This connection type covers the AAD auth for any applicable Azure service.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.AAD
    """

    auth_type: Literal[ConnectionAuthType.AAD] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.AAD  # type: ignore


class AccessKeyAuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="AccessKey"
):  # pylint: disable=name-too-long
    """AccessKeyAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionAccessKey
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.ACCESS_KEY
    """

    credentials: Optional["_models.WorkspaceConnectionAccessKey"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.ACCESS_KEY] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionAccessKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.ACCESS_KEY  # type: ignore


class AccountApiKeys(_Model):
    """AccountApiKeys.

    :ivar key1:
    :vartype key1: str
    :ivar key2:
    :vartype key2: str
    """

    key1: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    key2: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        key1: Optional[str] = None,
        key2: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AccountKeyAuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="AccountKey"
):  # pylint: disable=name-too-long
    """This connection type covers the account key connection for Azure storage.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials: Account key object for workspace connection credential.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionAccountKey
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.ACCOUNT_KEY
    """

    credentials: Optional["_models.WorkspaceConnectionAccountKey"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Account key object for workspace connection credential."""
    auth_type: Literal[ConnectionAuthType.ACCOUNT_KEY] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionAccountKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.ACCOUNT_KEY  # type: ignore


class DatastoreCredentials(_Model):
    """Base definition for datastore credentials.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AccountKeyDatastoreCredentials, CertificateDatastoreCredentials, NoneDatastoreCredentials,
    SasDatastoreCredentials, ServicePrincipalDatastoreCredentials

    :ivar credentials_type: [Required] Credential type used to authentication with storage.
     Required. Known values are: "AccountKey", "Certificate", "None", "Sas", and "ServicePrincipal".
    :vartype credentials_type: str or ~azure.mgmt.machinelearningservices.models.CredentialsType
    """

    __mapping__: dict[str, _Model] = {}
    credentials_type: str = rest_discriminator(
        name="credentialsType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Credential type used to authentication with storage. Required. Known values are:
     \"AccountKey\", \"Certificate\", \"None\", \"Sas\", and \"ServicePrincipal\"."""

    @overload
    def __init__(
        self,
        *,
        credentials_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AccountKeyDatastoreCredentials(DatastoreCredentials, discriminator="AccountKey"):
    """Account key datastore credentials configuration.

    :ivar secrets: [Required] Storage account secrets. Required.
    :vartype secrets: ~azure.mgmt.machinelearningservices.models.AccountKeyDatastoreSecrets
    :ivar credentials_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credentials_type: str or ~azure.mgmt.machinelearningservices.models.ACCOUNT_KEY
    """

    secrets: "_models.AccountKeyDatastoreSecrets" = rest_field(visibility=["create", "update"])
    """[Required] Storage account secrets. Required."""
    credentials_type: Literal[CredentialsType.ACCOUNT_KEY] = rest_discriminator(name="credentialsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        secrets: "_models.AccountKeyDatastoreSecrets",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credentials_type = CredentialsType.ACCOUNT_KEY  # type: ignore


class DatastoreSecrets(_Model):
    """Base definition for datastore secrets.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AccountKeyDatastoreSecrets, CertificateDatastoreSecrets, SasDatastoreSecrets,
    ServicePrincipalDatastoreSecrets

    :ivar secrets_type: [Required] Credential type used to authentication with storage. Required.
     Known values are: "AccountKey", "Certificate", "Sas", and "ServicePrincipal".
    :vartype secrets_type: str or ~azure.mgmt.machinelearningservices.models.SecretsType
    """

    __mapping__: dict[str, _Model] = {}
    secrets_type: str = rest_discriminator(
        name="secretsType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Credential type used to authentication with storage. Required. Known values are:
     \"AccountKey\", \"Certificate\", \"Sas\", and \"ServicePrincipal\"."""

    @overload
    def __init__(
        self,
        *,
        secrets_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AccountKeyDatastoreSecrets(DatastoreSecrets, discriminator="AccountKey"):
    """Datastore account key secrets.

    :ivar key: Storage account key.
    :vartype key: str
    :ivar secrets_type: [Required] Credential type used to authentication with storage. Required.
    :vartype secrets_type: str or ~azure.mgmt.machinelearningservices.models.ACCOUNT_KEY
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Storage account key."""
    secrets_type: Literal[SecretsType.ACCOUNT_KEY] = rest_discriminator(name="secretsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.secrets_type = SecretsType.ACCOUNT_KEY  # type: ignore


class AcrDetails(_Model):
    """Details of ACR account to be used for the Registry.

    :ivar system_created_acr_account: Details of system created ACR account to be used for the
     Registry.
    :vartype system_created_acr_account:
     ~azure.mgmt.machinelearningservices.models.SystemCreatedAcrAccount
    """

    system_created_acr_account: Optional["_models.SystemCreatedAcrAccount"] = rest_field(
        name="systemCreatedAcrAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Details of system created ACR account to be used for the Registry."""

    @overload
    def __init__(
        self,
        *,
        system_created_acr_account: Optional["_models.SystemCreatedAcrAccount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ActualCapacityInfo(_Model):
    """ActualCapacityInfo.

    :ivar total: Gets or sets the total number of instances (scale units) regardless of
     provisioning state or whether current group payload version matches the target group payload.
    :vartype total: int
    :ivar succeeded: Gets or sets the number of instances (scale units) which have Succeeded
     provisioning state and target group payload.
    :vartype succeeded: int
    :ivar failed: Gets or sets the number of instances (scale units) which have Failed provisioning
     state and have target group payload.
    :vartype failed: int
    :ivar outdated_succeeded: Gets or sets the number of instances (scale units) which have
     Succeeded provisioning state but do not have target group payload.
    :vartype outdated_succeeded: int
    :ivar outdated_failed: Gets or sets the number of instances (scale units) which have Failed
     provisioning state but do not have target group payload.
    :vartype outdated_failed: int
    """

    total: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the total number of instances (scale units) regardless of provisioning state or
     whether current group payload version matches the target group payload."""
    succeeded: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the number of instances (scale units) which have Succeeded provisioning state and
     target group payload."""
    failed: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the number of instances (scale units) which have Failed provisioning state and
     have target group payload."""
    outdated_succeeded: Optional[int] = rest_field(
        name="outdatedSucceeded", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets the number of instances (scale units) which have Succeeded provisioning state but
     do not have target group payload."""
    outdated_failed: Optional[int] = rest_field(
        name="outdatedFailed", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets the number of instances (scale units) which have Failed provisioning state but do
     not have target group payload."""

    @overload
    def __init__(
        self,
        *,
        total: Optional[int] = None,
        succeeded: Optional[int] = None,
        failed: Optional[int] = None,
        outdated_succeeded: Optional[int] = None,
        outdated_failed: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Compute(_Model):
    """Machine Learning compute object.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AKS, AmlCompute, ComputeInstance, DataFactory, DataLakeAnalytics, Databricks, HDInsight,
    Kubernetes, SynapseSpark, VirtualMachine

    :ivar compute_type: The type of compute. Required. Known values are: "AKS", "Kubernetes",
     "AmlCompute", "ComputeInstance", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics", and "SynapseSpark".
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.ComputeType
    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    """

    __mapping__: dict[str, _Model] = {}
    compute_type: str = rest_discriminator(
        name="computeType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of compute. Required. Known values are: \"AKS\", \"Kubernetes\", \"AmlCompute\",
     \"ComputeInstance\", \"DataFactory\", \"VirtualMachine\", \"HDInsight\", \"Databricks\",
     \"DataLakeAnalytics\", and \"SynapseSpark\"."""
    compute_location: Optional[str] = rest_field(name="computeLocation", visibility=["read", "create"])
    """Location for the underlying compute."""
    provisioning_state: Optional[Union[str, "_models.ProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The provision state of the cluster. Valid values are Unknown, Updating, Provisioning,
     Succeeded, and Failed. Known values are: \"Unknown\", \"Updating\", \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", and \"Canceled\"."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of the Machine Learning compute."""
    created_on: Optional[datetime.datetime] = rest_field(name="createdOn", visibility=["read"], format="rfc3339")
    """The time at which the compute was created."""
    modified_on: Optional[datetime.datetime] = rest_field(name="modifiedOn", visibility=["read"], format="rfc3339")
    """The time at which the compute was last modified."""
    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM resource id of the underlying compute."""
    provisioning_errors: Optional[list["_models.ErrorResponse"]] = rest_field(
        name="provisioningErrors", visibility=["read"]
    )
    """Errors during provisioning."""
    is_attached_compute: Optional[bool] = rest_field(name="isAttachedCompute", visibility=["read"])
    """Indicating whether the compute was provisioned by user and brought from outside if true, or
     machine learning service provisioned it if false."""
    disable_local_auth: Optional[bool] = rest_field(name="disableLocalAuth", visibility=["read", "create"])
    """Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
     authentication."""

    @overload
    def __init__(
        self,
        *,
        compute_type: str,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AKS(Compute, discriminator="AKS"):
    """A Machine Learning compute based on AKS.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties: AKS properties.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.AKSSchemaProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.AKS
    """

    properties: Optional["_models.AKSSchemaProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """AKS properties."""
    compute_type: Literal[ComputeType.AKS] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.AKSSchemaProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.AKS  # type: ignore


class ComputeSecrets(_Model):
    """Secrets related to a Machine Learning compute. Might differ for every type of compute.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AksComputeSecrets, DatabricksComputeSecrets, VirtualMachineSecrets

    :ivar compute_type: The type of compute. Required. Known values are: "AKS", "Kubernetes",
     "AmlCompute", "ComputeInstance", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics", and "SynapseSpark".
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.ComputeType
    """

    __mapping__: dict[str, _Model] = {}
    compute_type: str = rest_discriminator(
        name="computeType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of compute. Required. Known values are: \"AKS\", \"Kubernetes\", \"AmlCompute\",
     \"ComputeInstance\", \"DataFactory\", \"VirtualMachine\", \"HDInsight\", \"Databricks\",
     \"DataLakeAnalytics\", and \"SynapseSpark\"."""

    @overload
    def __init__(
        self,
        *,
        compute_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AksComputeSecrets(ComputeSecrets, discriminator="AKS"):
    """Secrets related to a Machine Learning compute based on AKS.

    :ivar user_kube_config: Content of kubeconfig file that can be used to connect to the
     Kubernetes cluster.
    :vartype user_kube_config: str
    :ivar admin_kube_config: Content of kubeconfig file that can be used to connect to the
     Kubernetes cluster.
    :vartype admin_kube_config: str
    :ivar image_pull_secret_name: Image registry pull secret.
    :vartype image_pull_secret_name: str
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.AKS
    """

    user_kube_config: Optional[str] = rest_field(
        name="userKubeConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """Content of kubeconfig file that can be used to connect to the Kubernetes cluster."""
    admin_kube_config: Optional[str] = rest_field(
        name="adminKubeConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """Content of kubeconfig file that can be used to connect to the Kubernetes cluster."""
    image_pull_secret_name: Optional[str] = rest_field(
        name="imagePullSecretName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image registry pull secret."""
    compute_type: Literal[ComputeType.AKS] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        user_kube_config: Optional[str] = None,
        admin_kube_config: Optional[str] = None,
        image_pull_secret_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.AKS  # type: ignore


class AksNetworkingConfiguration(_Model):
    """Advance configuration for AKS networking.

    :ivar subnet_id: Virtual network subnet resource ID the compute nodes belong to.
    :vartype subnet_id: str
    :ivar service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must
     not overlap with any Subnet IP ranges.
    :vartype service_cidr: str
    :ivar dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within
     the Kubernetes service address range specified in serviceCidr.
    :vartype dns_service_ip: str
    :ivar docker_bridge_cidr: A CIDR notation IP range assigned to the Docker bridge network. It
     must not overlap with any Subnet IP ranges or the Kubernetes service address range.
    :vartype docker_bridge_cidr: str
    """

    subnet_id: Optional[str] = rest_field(name="subnetId", visibility=["read", "create", "update", "delete", "query"])
    """Virtual network subnet resource ID the compute nodes belong to."""
    service_cidr: Optional[str] = rest_field(
        name="serviceCidr", visibility=["read", "create", "update", "delete", "query"]
    )
    """A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any
     Subnet IP ranges."""
    dns_service_ip: Optional[str] = rest_field(
        name="dnsServiceIP", visibility=["read", "create", "update", "delete", "query"]
    )
    """An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service
     address range specified in serviceCidr."""
    docker_bridge_cidr: Optional[str] = rest_field(
        name="dockerBridgeCidr", visibility=["read", "create", "update", "delete", "query"]
    )
    """A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any
     Subnet IP ranges or the Kubernetes service address range."""

    @overload
    def __init__(
        self,
        *,
        subnet_id: Optional[str] = None,
        service_cidr: Optional[str] = None,
        dns_service_ip: Optional[str] = None,
        docker_bridge_cidr: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AKSSchemaProperties(_Model):
    """AKS properties.

    :ivar cluster_fqdn: Cluster full qualified domain name.
    :vartype cluster_fqdn: str
    :ivar system_services: System services.
    :vartype system_services: list[~azure.mgmt.machinelearningservices.models.SystemService]
    :ivar agent_count: Number of agents.
    :vartype agent_count: int
    :ivar agent_vm_size: Agent virtual machine size.
    :vartype agent_vm_size: str
    :ivar cluster_purpose: Intended usage of the cluster. Known values are: "FastProd",
     "DenseProd", and "DevTest".
    :vartype cluster_purpose: str or ~azure.mgmt.machinelearningservices.models.ClusterPurpose
    :ivar ssl_configuration: SSL configuration.
    :vartype ssl_configuration: ~azure.mgmt.machinelearningservices.models.SslConfiguration
    :ivar aks_networking_configuration: AKS networking configuration for vnet.
    :vartype aks_networking_configuration:
     ~azure.mgmt.machinelearningservices.models.AksNetworkingConfiguration
    :ivar load_balancer_type: Load Balancer Type. Known values are: "PublicIp" and
     "InternalLoadBalancer".
    :vartype load_balancer_type: str or ~azure.mgmt.machinelearningservices.models.LoadBalancerType
    :ivar load_balancer_subnet: Load Balancer Subnet.
    :vartype load_balancer_subnet: str
    """

    cluster_fqdn: Optional[str] = rest_field(
        name="clusterFqdn", visibility=["read", "create", "update", "delete", "query"]
    )
    """Cluster full qualified domain name."""
    system_services: Optional[list["_models.SystemService"]] = rest_field(name="systemServices", visibility=["read"])
    """System services."""
    agent_count: Optional[int] = rest_field(
        name="agentCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of agents."""
    agent_vm_size: Optional[str] = rest_field(
        name="agentVmSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Agent virtual machine size."""
    cluster_purpose: Optional[Union[str, "_models.ClusterPurpose"]] = rest_field(
        name="clusterPurpose", visibility=["read", "create", "update", "delete", "query"]
    )
    """Intended usage of the cluster. Known values are: \"FastProd\", \"DenseProd\", and \"DevTest\"."""
    ssl_configuration: Optional["_models.SslConfiguration"] = rest_field(
        name="sslConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """SSL configuration."""
    aks_networking_configuration: Optional["_models.AksNetworkingConfiguration"] = rest_field(
        name="aksNetworkingConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """AKS networking configuration for vnet."""
    load_balancer_type: Optional[Union[str, "_models.LoadBalancerType"]] = rest_field(
        name="loadBalancerType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Load Balancer Type. Known values are: \"PublicIp\" and \"InternalLoadBalancer\"."""
    load_balancer_subnet: Optional[str] = rest_field(
        name="loadBalancerSubnet", visibility=["read", "create", "update", "delete", "query"]
    )
    """Load Balancer Subnet."""

    @overload
    def __init__(
        self,
        *,
        cluster_fqdn: Optional[str] = None,
        agent_count: Optional[int] = None,
        agent_vm_size: Optional[str] = None,
        cluster_purpose: Optional[Union[str, "_models.ClusterPurpose"]] = None,
        ssl_configuration: Optional["_models.SslConfiguration"] = None,
        aks_networking_configuration: Optional["_models.AksNetworkingConfiguration"] = None,
        load_balancer_type: Optional[Union[str, "_models.LoadBalancerType"]] = None,
        load_balancer_subnet: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitoringFeatureFilterBase(_Model):
    """MonitoringFeatureFilterBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AllFeatures, FeatureSubset, TopNFeaturesByAttribution

    :ivar filter_type: [Required] Specifies the feature filter to leverage when selecting features
     to calculate metrics over. Required. Known values are: "AllFeatures", "TopNByAttribution", and
     "FeatureSubset".
    :vartype filter_type: str or
     ~azure.mgmt.machinelearningservices.models.MonitoringFeatureFilterType
    """

    __mapping__: dict[str, _Model] = {}
    filter_type: str = rest_discriminator(name="filterType", visibility=["read", "create"])
    """[Required] Specifies the feature filter to leverage when selecting features to calculate
     metrics over. Required. Known values are: \"AllFeatures\", \"TopNByAttribution\", and
     \"FeatureSubset\"."""

    @overload
    def __init__(
        self,
        *,
        filter_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AllFeatures(MonitoringFeatureFilterBase, discriminator="AllFeatures"):
    """AllFeatures.

    :ivar filter_type: [Required] Specifies the feature filter to leverage when selecting features
     to calculate metrics over. Required. Includes all features.
    :vartype filter_type: str or ~azure.mgmt.machinelearningservices.models.ALL_FEATURES
    """

    filter_type: Literal[MonitoringFeatureFilterType.ALL_FEATURES] = rest_discriminator(name="filterType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the feature filter to leverage when selecting features to calculate
     metrics over. Required. Includes all features."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.filter_type = MonitoringFeatureFilterType.ALL_FEATURES  # type: ignore


class Nodes(_Model):
    """Abstract Nodes definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AllNodes

    :ivar nodes_value_type: [Required] Type of the Nodes value. Required. "All"
    :vartype nodes_value_type: str or ~azure.mgmt.machinelearningservices.models.NodesValueType
    """

    __mapping__: dict[str, _Model] = {}
    nodes_value_type: str = rest_discriminator(name="nodesValueType", visibility=["read", "create"])
    """[Required] Type of the Nodes value. Required. \"All\""""

    @overload
    def __init__(
        self,
        *,
        nodes_value_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AllNodes(Nodes, discriminator="All"):
    """All nodes means the service will be running on all of the nodes of the job.

    :ivar nodes_value_type: [Required] Type of the Nodes value. Required.
    :vartype nodes_value_type: str or ~azure.mgmt.machinelearningservices.models.ALL
    """

    nodes_value_type: Literal[NodesValueType.ALL] = rest_discriminator(name="nodesValueType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Type of the Nodes value. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.nodes_value_type = NodesValueType.ALL  # type: ignore


class AmlCompute(Compute, discriminator="AmlCompute"):
    """An Azure Machine Learning compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties: Properties of AmlCompute.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.AmlComputeProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.AML_COMPUTE
    """

    properties: Optional["_models.AmlComputeProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of AmlCompute."""
    compute_type: Literal[ComputeType.AML_COMPUTE] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.AmlComputeProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.AML_COMPUTE  # type: ignore


class AmlComputeNodeInformation(_Model):
    """Compute node information related to a AmlCompute.

    :ivar node_id: Node ID.
    :vartype node_id: str
    :ivar private_ip_address: Private IP address.
    :vartype private_ip_address: str
    :ivar public_ip_address: Public IP address.
    :vartype public_ip_address: str
    :ivar port: Port.
    :vartype port: int
    :ivar node_state: State of the compute node. Values are idle, running, preparing, unusable,
     leaving and preempted. Known values are: "idle", "running", "preparing", "unusable", "leaving",
     and "preempted".
    :vartype node_state: str or ~azure.mgmt.machinelearningservices.models.NodeState
    :ivar run_id: Run ID.
    :vartype run_id: str
    """

    node_id: Optional[str] = rest_field(name="nodeId", visibility=["read"])
    """Node ID."""
    private_ip_address: Optional[str] = rest_field(name="privateIpAddress", visibility=["read"])
    """Private IP address."""
    public_ip_address: Optional[str] = rest_field(name="publicIpAddress", visibility=["read"])
    """Public IP address."""
    port: Optional[int] = rest_field(visibility=["read"])
    """Port."""
    node_state: Optional[Union[str, "_models.NodeState"]] = rest_field(name="nodeState", visibility=["read"])
    """State of the compute node. Values are idle, running, preparing, unusable, leaving and
     preempted. Known values are: \"idle\", \"running\", \"preparing\", \"unusable\", \"leaving\",
     and \"preempted\"."""
    run_id: Optional[str] = rest_field(name="runId", visibility=["read"])
    """Run ID."""


class AmlComputeProperties(_Model):
    """AML Compute properties.

    :ivar os_type: Compute OS Type. Known values are: "Linux" and "Windows".
    :vartype os_type: str or ~azure.mgmt.machinelearningservices.models.OsType
    :ivar vm_size: Virtual Machine Size.
    :vartype vm_size: str
    :ivar vm_priority: Virtual Machine priority. Known values are: "Dedicated" and "LowPriority".
    :vartype vm_priority: str or ~azure.mgmt.machinelearningservices.models.VmPriority
    :ivar virtual_machine_image: Virtual Machine image for AML Compute - windows only.
    :vartype virtual_machine_image: ~azure.mgmt.machinelearningservices.models.VirtualMachineImage
    :ivar isolated_network: Network is isolated or not.
    :vartype isolated_network: bool
    :ivar scale_settings: Scale settings for AML Compute.
    :vartype scale_settings: ~azure.mgmt.machinelearningservices.models.ScaleSettings
    :ivar user_account_credentials: User account credentials.
    :vartype user_account_credentials:
     ~azure.mgmt.machinelearningservices.models.UserAccountCredentials
    :ivar subnet: Subnet.
    :vartype subnet: ~azure.mgmt.machinelearningservices.models.ResourceId
    :ivar remote_login_port_public_access: Close remote Login Access Port. Known values are:
     "Enabled", "Disabled", and "NotSpecified".
    :vartype remote_login_port_public_access: str or
     ~azure.mgmt.machinelearningservices.models.RemoteLoginPortPublicAccess
    :ivar allocation_state: Allocation state. Known values are: "Steady" and "Resizing".
    :vartype allocation_state: str or ~azure.mgmt.machinelearningservices.models.AllocationState
    :ivar allocation_state_transition_time: Allocation state transition time.
    :vartype allocation_state_transition_time: ~datetime.datetime
    :ivar errors: Errors.
    :vartype errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar current_node_count: Current node count.
    :vartype current_node_count: int
    :ivar target_node_count: Target node count.
    :vartype target_node_count: int
    :ivar node_state_counts: Node state counts.
    :vartype node_state_counts: ~azure.mgmt.machinelearningservices.models.NodeStateCounts
    :ivar enable_node_public_ip: Enable node public IP.
    :vartype enable_node_public_ip: bool
    :ivar property_bag: A property bag containing additional properties.
    :vartype property_bag: any
    """

    os_type: Optional[Union[str, "_models.OsType"]] = rest_field(
        name="osType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Compute OS Type. Known values are: \"Linux\" and \"Windows\"."""
    vm_size: Optional[str] = rest_field(name="vmSize", visibility=["read", "create", "update", "delete", "query"])
    """Virtual Machine Size."""
    vm_priority: Optional[Union[str, "_models.VmPriority"]] = rest_field(
        name="vmPriority", visibility=["read", "create", "update", "delete", "query"]
    )
    """Virtual Machine priority. Known values are: \"Dedicated\" and \"LowPriority\"."""
    virtual_machine_image: Optional["_models.VirtualMachineImage"] = rest_field(
        name="virtualMachineImage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Virtual Machine image for AML Compute - windows only."""
    isolated_network: Optional[bool] = rest_field(
        name="isolatedNetwork", visibility=["read", "create", "update", "delete", "query"]
    )
    """Network is isolated or not."""
    scale_settings: Optional["_models.ScaleSettings"] = rest_field(
        name="scaleSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Scale settings for AML Compute."""
    user_account_credentials: Optional["_models.UserAccountCredentials"] = rest_field(
        name="userAccountCredentials", visibility=["read", "create", "update", "delete", "query"]
    )
    """User account credentials."""
    subnet: Optional["_models.ResourceId"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Subnet."""
    remote_login_port_public_access: Optional[Union[str, "_models.RemoteLoginPortPublicAccess"]] = rest_field(
        name="remoteLoginPortPublicAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Close remote Login Access Port. Known values are: \"Enabled\", \"Disabled\", and
     \"NotSpecified\"."""
    allocation_state: Optional[Union[str, "_models.AllocationState"]] = rest_field(
        name="allocationState", visibility=["read"]
    )
    """Allocation state. Known values are: \"Steady\" and \"Resizing\"."""
    allocation_state_transition_time: Optional[datetime.datetime] = rest_field(
        name="allocationStateTransitionTime", visibility=["read"], format="rfc3339"
    )
    """Allocation state transition time."""
    errors: Optional[list["_models.ErrorResponse"]] = rest_field(visibility=["read"])
    """Errors."""
    current_node_count: Optional[int] = rest_field(name="currentNodeCount", visibility=["read"])
    """Current node count."""
    target_node_count: Optional[int] = rest_field(name="targetNodeCount", visibility=["read"])
    """Target node count."""
    node_state_counts: Optional["_models.NodeStateCounts"] = rest_field(name="nodeStateCounts", visibility=["read"])
    """Node state counts."""
    enable_node_public_ip: Optional[bool] = rest_field(
        name="enableNodePublicIp", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable node public IP."""
    property_bag: Optional[Any] = rest_field(
        name="propertyBag", visibility=["read", "create", "update", "delete", "query"]
    )
    """A property bag containing additional properties."""

    @overload
    def __init__(
        self,
        *,
        os_type: Optional[Union[str, "_models.OsType"]] = None,
        vm_size: Optional[str] = None,
        vm_priority: Optional[Union[str, "_models.VmPriority"]] = None,
        virtual_machine_image: Optional["_models.VirtualMachineImage"] = None,
        isolated_network: Optional[bool] = None,
        scale_settings: Optional["_models.ScaleSettings"] = None,
        user_account_credentials: Optional["_models.UserAccountCredentials"] = None,
        subnet: Optional["_models.ResourceId"] = None,
        remote_login_port_public_access: Optional[Union[str, "_models.RemoteLoginPortPublicAccess"]] = None,
        enable_node_public_ip: Optional[bool] = None,
        property_bag: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IdentityConfiguration(_Model):
    """Base definition for identity configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AmlToken, ManagedIdentity, UserIdentity

    :ivar identity_type: [Required] Specifies the type of identity framework. Required. Known
     values are: "Managed", "AMLToken", and "UserIdentity".
    :vartype identity_type: str or
     ~azure.mgmt.machinelearningservices.models.IdentityConfigurationType
    """

    __mapping__: dict[str, _Model] = {}
    identity_type: str = rest_discriminator(name="identityType", visibility=["read", "create"])
    """[Required] Specifies the type of identity framework. Required. Known values are: \"Managed\",
     \"AMLToken\", and \"UserIdentity\"."""

    @overload
    def __init__(
        self,
        *,
        identity_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AmlToken(IdentityConfiguration, discriminator="AMLToken"):
    """AML Token identity configuration.

    :ivar identity_type: [Required] Specifies the type of identity framework. Required.
    :vartype identity_type: str or ~azure.mgmt.machinelearningservices.models.AML_TOKEN
    """

    identity_type: Literal[IdentityConfigurationType.AML_TOKEN] = rest_discriminator(name="identityType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of identity framework. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.identity_type = IdentityConfigurationType.AML_TOKEN  # type: ignore


class MonitorComputeIdentityBase(_Model):
    """Monitor compute identity base definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AmlTokenComputeIdentity, ManagedComputeIdentity

    :ivar compute_identity_type: [Required] Specifies the type of identity to use within the
     monitoring jobs. Required. Known values are: "AmlToken" and "ManagedIdentity".
    :vartype compute_identity_type: str or
     ~azure.mgmt.machinelearningservices.models.MonitorComputeIdentityType
    """

    __mapping__: dict[str, _Model] = {}
    compute_identity_type: str = rest_discriminator(name="computeIdentityType", visibility=["read", "create"])
    """[Required] Specifies the type of identity to use within the monitoring jobs. Required. Known
     values are: \"AmlToken\" and \"ManagedIdentity\"."""

    @overload
    def __init__(
        self,
        *,
        compute_identity_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AmlTokenComputeIdentity(MonitorComputeIdentityBase, discriminator="AmlToken"):
    """AML token compute identity definition.

    :ivar compute_identity_type: [Required] Specifies the type of identity to use within the
     monitoring jobs. Required. Authenticates through user's AML token.
    :vartype compute_identity_type: str or ~azure.mgmt.machinelearningservices.models.AML_TOKEN
    """

    compute_identity_type: Literal[MonitorComputeIdentityType.AML_TOKEN] = rest_discriminator(name="computeIdentityType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of identity to use within the monitoring jobs. Required.
     Authenticates through user's AML token."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_identity_type = MonitorComputeIdentityType.AML_TOKEN  # type: ignore


class AmlUserFeature(_Model):
    """Features enabled for a workspace.

    :ivar id: Specifies the feature ID.
    :vartype id: str
    :ivar display_name: Specifies the feature name.
    :vartype display_name: str
    :ivar description: Describes the feature for user experience.
    :vartype description: str
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the feature ID."""
    display_name: Optional[str] = rest_field(
        name="displayName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the feature name."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Describes the feature for user experience."""

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        display_name: Optional[str] = None,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataReferenceCredential(_Model):
    """DataReferenceCredential base class.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DockerCredential, ManagedIdentityCredential, AnonymousAccessCredential, SASCredential

    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required. Known values are: "SAS", "DockerCredentials", "ManagedIdentity", and "NoCredentials".
    :vartype credential_type: str or
     ~azure.mgmt.machinelearningservices.models.DataReferenceCredentialType
    """

    __mapping__: dict[str, _Model] = {}
    credential_type: str = rest_discriminator(
        name="credentialType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Credential type used to authentication with storage. Required. Known values are:
     \"SAS\", \"DockerCredentials\", \"ManagedIdentity\", and \"NoCredentials\"."""

    @overload
    def __init__(
        self,
        *,
        credential_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AnonymousAccessCredential(DataReferenceCredential, discriminator="NoCredentials"):
    """Access credential with no credentials.

    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credential_type: str or ~azure.mgmt.machinelearningservices.models.NO_CREDENTIALS
    """

    credential_type: Literal[DataReferenceCredentialType.NO_CREDENTIALS] = rest_discriminator(name="credentialType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credential_type = DataReferenceCredentialType.NO_CREDENTIALS  # type: ignore


class ApiKeyAuthWorkspaceConnectionProperties(WorkspaceConnectionPropertiesV2, discriminator="ApiKey"):
    """This connection type covers the generic ApiKey auth connection categories, for examples:
    AzureOpenAI:
    Category:= AzureOpenAI
    AuthType:= ApiKey (as type discriminator)
    Credentials:= {ApiKey} as
    Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
    Target:= {ApiBase}

    CognitiveService:
    Category:= CognitiveService
    AuthType:= ApiKey (as type discriminator)
    Credentials:= {SubscriptionKey} as
    Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
    Target:= ServiceRegion={serviceRegion}

    CognitiveSearch:
    Category:= CognitiveSearch
    AuthType:= ApiKey (as type discriminator)
    Credentials:= {Key} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
    Target:= {Endpoint}

    Use Metadata property bag for ApiType, ApiVersion, Kind and other metadata fields.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionApiKey
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.API_KEY
    """

    credentials: Optional["_models.WorkspaceConnectionApiKey"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.API_KEY] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionApiKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.API_KEY  # type: ignore


class ArmResourceId(_Model):
    """ARM ResourceId of a resource.

    :ivar resource_id: Arm ResourceId is in the format
     "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
     or
     "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}".
    :vartype resource_id: str
    """

    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Arm ResourceId is in the format
     \"/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}\"
     or
     \"/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}\"."""

    @overload
    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceBase(_Model):
    """ResourceBase.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    """

    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The asset description text."""
    properties: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The asset property dictionary."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Tag dictionary. Tags can be added, removed, and updated."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssetBase(ResourceBase):
    """AssetBase.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    """

    is_anonymous: Optional[bool] = rest_field(name="isAnonymous", visibility=["read", "create"])
    """If the name version are system generated (anonymous registration)."""
    is_archived: Optional[bool] = rest_field(name="isArchived", visibility=["read", "create", "update"])
    """Is the asset archived?."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssetContainer(ResourceBase):
    """AssetContainer.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    """

    is_archived: Optional[bool] = rest_field(name="isArchived", visibility=["read", "create", "update"])
    """Is the asset archived?."""
    latest_version: Optional[str] = rest_field(name="latestVersion", visibility=["read"])
    """The latest version inside this container."""
    next_version: Optional[str] = rest_field(name="nextVersion", visibility=["read"])
    """The next auto incremental version."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssetReferenceBase(_Model):
    """Base definition for asset references.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DataPathAssetReference, IdAssetReference, OutputPathAssetReference

    :ivar reference_type: [Required] Specifies the type of asset reference. Required. Known values
     are: "Id", "DataPath", and "OutputPath".
    :vartype reference_type: str or ~azure.mgmt.machinelearningservices.models.ReferenceType
    """

    __mapping__: dict[str, _Model] = {}
    reference_type: str = rest_discriminator(
        name="referenceType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Specifies the type of asset reference. Required. Known values are: \"Id\",
     \"DataPath\", and \"OutputPath\"."""

    @overload
    def __init__(
        self,
        *,
        reference_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AssignedUser(_Model):
    """A user that can be assigned to a compute instance.

    :ivar object_id: Users AAD Object Id. Required.
    :vartype object_id: str
    :ivar tenant_id: Users AAD Tenant Id. Required.
    :vartype tenant_id: str
    """

    object_id: str = rest_field(name="objectId", visibility=["read", "create", "update", "delete", "query"])
    """Users AAD Object Id. Required."""
    tenant_id: str = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])
    """Users AAD Tenant Id. Required."""

    @overload
    def __init__(
        self,
        *,
        object_id: str,
        tenant_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastHorizon(_Model):
    """The desired maximum forecast horizon in units of time-series frequency.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AutoForecastHorizon, CustomForecastHorizon

    :ivar mode: [Required] Set forecast horizon value selection mode. Required. Known values are:
     "Auto" and "Custom".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.ForecastHorizonMode
    """

    __mapping__: dict[str, _Model] = {}
    mode: str = rest_discriminator(name="mode", visibility=["read", "create"])
    """[Required] Set forecast horizon value selection mode. Required. Known values are: \"Auto\" and
     \"Custom\"."""

    @overload
    def __init__(
        self,
        *,
        mode: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoForecastHorizon(ForecastHorizon, discriminator="Auto"):
    """Forecast horizon determined automatically by system.

    :ivar mode: [Required] Set forecast horizon value selection mode. Required. Forecast horizon to
     be determined automatically.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.AUTO
    """

    mode: Literal[ForecastHorizonMode.AUTO] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Set forecast horizon value selection mode. Required. Forecast horizon to be
     determined automatically."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = ForecastHorizonMode.AUTO  # type: ignore


class JobBaseProperties(ResourceBase):
    """Base definition for a job.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AutoMLJob, CommandJob, DistillationJob, FineTuningJob, PipelineJob, SparkJob, SweepJob

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar job_type: [Required] Specifies the type of job. Required. Known values are: "AutoML",
     "Command", "Sweep", "Pipeline", "Spark", "FineTuning", and "Distillation".
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.JobType
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    """

    __mapping__: dict[str, _Model] = {}
    component_id: Optional[str] = rest_field(name="componentId", visibility=["read", "create"])
    """ARM resource ID of the component resource."""
    compute_id: Optional[str] = rest_field(name="computeId", visibility=["read", "create"])
    """ARM resource ID of the compute resource."""
    display_name: Optional[str] = rest_field(name="displayName", visibility=["read", "create"])
    """Display name of job."""
    experiment_name: Optional[str] = rest_field(name="experimentName", visibility=["read", "create"])
    """The name of the experiment the job belongs to. If not set, the job is placed in the \"Default\"
     experiment."""
    identity: Optional["_models.IdentityConfiguration"] = rest_field(visibility=["read", "create"])
    """Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity
     or null.
     Defaults to AmlToken if null."""
    is_archived: Optional[bool] = rest_field(name="isArchived", visibility=["read", "create", "update"])
    """Is the asset archived?."""
    job_type: str = rest_discriminator(name="jobType", visibility=["read", "create"])
    """[Required] Specifies the type of job. Required. Known values are: \"AutoML\", \"Command\",
     \"Sweep\", \"Pipeline\", \"Spark\", \"FineTuning\", and \"Distillation\"."""
    notification_setting: Optional["_models.NotificationSetting"] = rest_field(
        name="notificationSetting", visibility=["read", "create", "update"]
    )
    """Notification setting for the job."""
    parent_job_name: Optional[str] = rest_field(
        name="parentJobName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Parent job name."""
    services: Optional[dict[str, "_models.JobService"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject."""
    status: Optional[Union[str, "_models.JobStatus"]] = rest_field(visibility=["read"])
    """Status of the job. Known values are: \"NotStarted\", \"Starting\", \"Provisioning\",
     \"Preparing\", \"Queued\", \"Running\", \"Finalizing\", \"CancelRequested\", \"Completed\",
     \"Failed\", \"Canceled\", \"NotResponding\", \"Paused\", and \"Unknown\"."""

    @overload
    def __init__(
        self,
        *,
        job_type: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoMLJob(JobBaseProperties, discriminator="AutoML"):
    """AutoMLJob class.
    Use this class for executing AutoML tasks like Classification/Regression etc.
    See TaskType enum for all the tasks supported.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar environment_id: The ARM resource ID of the Environment specification for the job.
     This is optional value to provide, if not provided, AutoML will default this to Production
     AutoML curated environment version when running the job.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables included in the job.
    :vartype environment_variables: dict[str, str]
    :ivar outputs: Mapping of output data bindings used in the job.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar queue_settings: Queue settings for the job.
    :vartype queue_settings: ~azure.mgmt.machinelearningservices.models.QueueSettings
    :ivar resources: Compute Resource configuration for the job.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.JobResourceConfiguration
    :ivar task_details: [Required] This represents scenario which can be one of Tables/NLP/Image.
     Required.
    :vartype task_details: ~azure.mgmt.machinelearningservices.models.AutoMLVertical
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.AUTO_ML
    """

    environment_id: Optional[str] = rest_field(name="environmentId", visibility=["read", "create"])
    """The ARM resource ID of the Environment specification for the job.
     This is optional value to provide, if not provided, AutoML will default this to Production
     AutoML curated environment version when running the job."""
    environment_variables: Optional[dict[str, str]] = rest_field(
        name="environmentVariables", visibility=["read", "create"]
    )
    """Environment variables included in the job."""
    outputs: Optional[dict[str, "_models.JobOutput"]] = rest_field(visibility=["read", "create"])
    """Mapping of output data bindings used in the job."""
    queue_settings: Optional["_models.QueueSettings"] = rest_field(name="queueSettings", visibility=["read", "create"])
    """Queue settings for the job."""
    resources: Optional["_models.JobResourceConfiguration"] = rest_field(visibility=["read", "create"])
    """Compute Resource configuration for the job."""
    task_details: "_models.AutoMLVertical" = rest_field(
        name="taskDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] This represents scenario which can be one of Tables/NLP/Image. Required."""
    job_type: Literal[JobType.AUTO_ML] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        task_details: "_models.AutoMLVertical",
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        outputs: Optional[dict[str, "_models.JobOutput"]] = None,
        queue_settings: Optional["_models.QueueSettings"] = None,
        resources: Optional["_models.JobResourceConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.AUTO_ML  # type: ignore


class AutoMLVertical(_Model):
    """AutoML vertical class.
    Base class for AutoML verticals - TableVertical/ImageVertical/NLPVertical.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    Classification, Forecasting, ImageClassification, ImageClassificationMultilabel,
    ImageInstanceSegmentation, ImageObjectDetection, Regression, TextClassification,
    TextClassificationMultilabel, TextNer

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Known values are:
     "Classification", "Regression", "Forecasting", "ImageClassification",
     "ImageClassificationMultilabel", "ImageObjectDetection", "ImageInstanceSegmentation",
     "TextClassification", "TextClassificationMultilabel", and "TextNER".
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.TaskType
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    """

    __mapping__: dict[str, _Model] = {}
    log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = rest_field(
        name="logVerbosity", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum for setting log verbosity. Known values are: \"NotSet\", \"Debug\", \"Info\", \"Warning\",
     \"Error\", and \"Critical\"."""
    target_column_name: Optional[str] = rest_field(
        name="targetColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks."""
    task_type: str = rest_discriminator(name="taskType", visibility=["read", "create"])
    """[Required] Task type for AutoMLJob. Required. Known values are: \"Classification\",
     \"Regression\", \"Forecasting\", \"ImageClassification\", \"ImageClassificationMultilabel\",
     \"ImageObjectDetection\", \"ImageInstanceSegmentation\", \"TextClassification\",
     \"TextClassificationMultilabel\", and \"TextNER\"."""
    training_data: "_models.MLTableJobInput" = rest_field(
        name="trainingData", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Training data input. Required."""

    @overload
    def __init__(
        self,
        *,
        task_type: str,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NCrossValidations(_Model):
    """N-Cross validations value.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AutoNCrossValidations, CustomNCrossValidations

    :ivar mode: [Required] Mode for determining N-Cross validations. Required. Known values are:
     "Auto" and "Custom".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.NCrossValidationsMode
    """

    __mapping__: dict[str, _Model] = {}
    mode: str = rest_discriminator(name="mode", visibility=["read", "create"])
    """[Required] Mode for determining N-Cross validations. Required. Known values are: \"Auto\" and
     \"Custom\"."""

    @overload
    def __init__(
        self,
        *,
        mode: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoNCrossValidations(NCrossValidations, discriminator="Auto"):
    """N-Cross validations determined automatically.

    :ivar mode: [Required] Mode for determining N-Cross validations. Required. Determine N-Cross
     validations value automatically. Supported only for 'Forecasting' AutoML task.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.AUTO
    """

    mode: Literal[NCrossValidationsMode.AUTO] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Mode for determining N-Cross validations. Required. Determine N-Cross validations
     value automatically. Supported only for 'Forecasting' AutoML task."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = NCrossValidationsMode.AUTO  # type: ignore


class AutoPauseProperties(_Model):
    """Auto pause properties.

    :ivar delay_in_minutes:
    :vartype delay_in_minutes: int
    :ivar enabled:
    :vartype enabled: bool
    """

    delay_in_minutes: Optional[int] = rest_field(
        name="delayInMinutes", visibility=["read", "create", "update", "delete", "query"]
    )
    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        delay_in_minutes: Optional[int] = None,
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoScaleProperties(_Model):
    """Auto scale properties.

    :ivar min_node_count:
    :vartype min_node_count: int
    :ivar enabled:
    :vartype enabled: bool
    :ivar max_node_count:
    :vartype max_node_count: int
    """

    min_node_count: Optional[int] = rest_field(
        name="minNodeCount", visibility=["read", "create", "update", "delete", "query"]
    )
    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    max_node_count: Optional[int] = rest_field(
        name="maxNodeCount", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        min_node_count: Optional[int] = None,
        enabled: Optional[bool] = None,
        max_node_count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Seasonality(_Model):
    """Forecasting seasonality.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AutoSeasonality, CustomSeasonality

    :ivar mode: [Required] Seasonality mode. Required. Known values are: "Auto" and "Custom".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.SeasonalityMode
    """

    __mapping__: dict[str, _Model] = {}
    mode: str = rest_discriminator(name="mode", visibility=["read", "create"])
    """[Required] Seasonality mode. Required. Known values are: \"Auto\" and \"Custom\"."""

    @overload
    def __init__(
        self,
        *,
        mode: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoSeasonality(Seasonality, discriminator="Auto"):
    """AutoSeasonality.

    :ivar mode: [Required] Seasonality mode. Required. Seasonality to be determined automatically.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.AUTO
    """

    mode: Literal[SeasonalityMode.AUTO] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Seasonality mode. Required. Seasonality to be determined automatically."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = SeasonalityMode.AUTO  # type: ignore


class TargetLags(_Model):
    """The number of past periods to lag from the target column.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AutoTargetLags, CustomTargetLags

    :ivar mode: [Required] Set target lags mode - Auto/Custom. Required. Known values are: "Auto"
     and "Custom".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.TargetLagsMode
    """

    __mapping__: dict[str, _Model] = {}
    mode: str = rest_discriminator(name="mode", visibility=["read", "create"])
    """[Required] Set target lags mode - Auto/Custom. Required. Known values are: \"Auto\" and
     \"Custom\"."""

    @overload
    def __init__(
        self,
        *,
        mode: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoTargetLags(TargetLags, discriminator="Auto"):
    """AutoTargetLags.

    :ivar mode: [Required] Set target lags mode - Auto/Custom. Required. Target lags to be
     determined automatically.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.AUTO
    """

    mode: Literal[TargetLagsMode.AUTO] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Set target lags mode - Auto/Custom. Required. Target lags to be determined
     automatically."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = TargetLagsMode.AUTO  # type: ignore


class TargetRollingWindowSize(_Model):
    """Forecasting target rolling window size.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AutoTargetRollingWindowSize, CustomTargetRollingWindowSize

    :ivar mode: [Required] TargetRollingWindowSiz detection mode. Required. Known values are:
     "Auto" and "Custom".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.TargetRollingWindowSizeMode
    """

    __mapping__: dict[str, _Model] = {}
    mode: str = rest_discriminator(name="mode", visibility=["read", "create"])
    """[Required] TargetRollingWindowSiz detection mode. Required. Known values are: \"Auto\" and
     \"Custom\"."""

    @overload
    def __init__(
        self,
        *,
        mode: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AutoTargetRollingWindowSize(TargetRollingWindowSize, discriminator="Auto"):
    """Target lags rolling window determined automatically.

    :ivar mode: [Required] TargetRollingWindowSiz detection mode. Required. Determine rolling
     windows size automatically.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.AUTO
    """

    mode: Literal[TargetRollingWindowSizeMode.AUTO] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] TargetRollingWindowSiz detection mode. Required. Determine rolling windows size
     automatically."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = TargetRollingWindowSizeMode.AUTO  # type: ignore


class AvailableQuota(_Model):
    """AvailableQuota.

    :ivar properties: Available quota properties.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.AvailableQuotaProperties
    """

    properties: Optional["_models.AvailableQuotaProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Available quota properties."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.AvailableQuotaProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AvailableQuotaProperties(_Model):
    """AvailableQuotaProperties.

    :ivar total: The number of available quota.
    :vartype total: int
    """

    total: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The number of available quota."""

    @overload
    def __init__(
        self,
        *,
        total: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DatastoreProperties(ResourceBase):
    """Base definition for datastore contents configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AzureBlobDatastore, AzureDataLakeGen1Datastore, AzureDataLakeGen2Datastore, AzureFileDatastore,
    OneLakeDatastore

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar credentials: [Required] Account credentials. Required.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.DatastoreCredentials
    :ivar datastore_type: Enum to determine the datastore contents type. Required. Known values
     are: "AzureBlob", "AzureDataLakeGen1", "AzureDataLakeGen2", "AzureFile", and "OneLake".
    :vartype datastore_type: str or ~azure.mgmt.machinelearningservices.models.DatastoreType
    :ivar is_default: Readonly property to indicate if datastore is the workspace default
     datastore.
    :vartype is_default: bool
    """

    __mapping__: dict[str, _Model] = {}
    credentials: "_models.DatastoreCredentials" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Account credentials. Required."""
    datastore_type: str = rest_discriminator(
        name="datastoreType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum to determine the datastore contents type. Required. Known values are: \"AzureBlob\",
     \"AzureDataLakeGen1\", \"AzureDataLakeGen2\", \"AzureFile\", and \"OneLake\"."""
    is_default: Optional[bool] = rest_field(name="isDefault", visibility=["read"])
    """Readonly property to indicate if datastore is the workspace default datastore."""

    @overload
    def __init__(
        self,
        *,
        credentials: "_models.DatastoreCredentials",
        datastore_type: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureBlobDatastore(DatastoreProperties, discriminator="AzureBlob"):
    """Azure Blob datastore configuration.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar credentials: [Required] Account credentials. Required.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.DatastoreCredentials
    :ivar is_default: Readonly property to indicate if datastore is the workspace default
     datastore.
    :vartype is_default: bool
    :ivar resource_group: Azure Resource Group name.
    :vartype resource_group: str
    :ivar subscription_id: Azure Subscription Id.
    :vartype subscription_id: str
    :ivar account_name: Storage account name.
    :vartype account_name: str
    :ivar container_name: Storage account container name.
    :vartype container_name: str
    :ivar endpoint: Azure cloud endpoint for the storage account.
    :vartype endpoint: str
    :ivar protocol: Protocol used to communicate with the storage account.
    :vartype protocol: str
    :ivar service_data_access_auth_identity: Indicates which identity to use to authenticate
     service data access to customer's storage. Known values are: "None",
     "WorkspaceSystemAssignedIdentity", and "WorkspaceUserAssignedIdentity".
    :vartype service_data_access_auth_identity: str or
     ~azure.mgmt.machinelearningservices.models.ServiceDataAccessAuthIdentity
    :ivar datastore_type: [Required] Storage type backing the datastore. Required.
    :vartype datastore_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_BLOB
    """

    resource_group: Optional[str] = rest_field(
        name="resourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Resource Group name."""
    subscription_id: Optional[str] = rest_field(
        name="subscriptionId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Subscription Id."""
    account_name: Optional[str] = rest_field(name="accountName", visibility=["read", "create"])
    """Storage account name."""
    container_name: Optional[str] = rest_field(name="containerName", visibility=["read", "create"])
    """Storage account container name."""
    endpoint: Optional[str] = rest_field(visibility=["read", "create"])
    """Azure cloud endpoint for the storage account."""
    protocol: Optional[str] = rest_field(visibility=["read", "create"])
    """Protocol used to communicate with the storage account."""
    service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = rest_field(
        name="serviceDataAccessAuthIdentity", visibility=["read", "create"]
    )
    """Indicates which identity to use to authenticate service data access to customer's storage.
     Known values are: \"None\", \"WorkspaceSystemAssignedIdentity\", and
     \"WorkspaceUserAssignedIdentity\"."""
    datastore_type: Literal[DatastoreType.AZURE_BLOB] = rest_discriminator(name="datastoreType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Storage type backing the datastore. Required."""

    @overload
    def __init__(
        self,
        *,
        credentials: "_models.DatastoreCredentials",
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        resource_group: Optional[str] = None,
        subscription_id: Optional[str] = None,
        account_name: Optional[str] = None,
        container_name: Optional[str] = None,
        endpoint: Optional[str] = None,
        protocol: Optional[str] = None,
        service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.datastore_type = DatastoreType.AZURE_BLOB  # type: ignore


class AzureDataLakeGen1Datastore(DatastoreProperties, discriminator="AzureDataLakeGen1"):
    """Azure Data Lake Gen1 datastore configuration.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar credentials: [Required] Account credentials. Required.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.DatastoreCredentials
    :ivar is_default: Readonly property to indicate if datastore is the workspace default
     datastore.
    :vartype is_default: bool
    :ivar resource_group: Azure Resource Group name.
    :vartype resource_group: str
    :ivar subscription_id: Azure Subscription Id.
    :vartype subscription_id: str
    :ivar service_data_access_auth_identity: Indicates which identity to use to authenticate
     service data access to customer's storage. Known values are: "None",
     "WorkspaceSystemAssignedIdentity", and "WorkspaceUserAssignedIdentity".
    :vartype service_data_access_auth_identity: str or
     ~azure.mgmt.machinelearningservices.models.ServiceDataAccessAuthIdentity
    :ivar store_name: [Required] Azure Data Lake store name. Required.
    :vartype store_name: str
    :ivar datastore_type: [Required] Storage type backing the datastore. Required.
    :vartype datastore_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_DATA_LAKE_GEN1
    """

    resource_group: Optional[str] = rest_field(
        name="resourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Resource Group name."""
    subscription_id: Optional[str] = rest_field(
        name="subscriptionId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Subscription Id."""
    service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = rest_field(
        name="serviceDataAccessAuthIdentity", visibility=["read", "create"]
    )
    """Indicates which identity to use to authenticate service data access to customer's storage.
     Known values are: \"None\", \"WorkspaceSystemAssignedIdentity\", and
     \"WorkspaceUserAssignedIdentity\"."""
    store_name: str = rest_field(name="storeName", visibility=["read", "create"])
    """[Required] Azure Data Lake store name. Required."""
    datastore_type: Literal[DatastoreType.AZURE_DATA_LAKE_GEN1] = rest_discriminator(name="datastoreType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Storage type backing the datastore. Required."""

    @overload
    def __init__(
        self,
        *,
        credentials: "_models.DatastoreCredentials",
        store_name: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        resource_group: Optional[str] = None,
        subscription_id: Optional[str] = None,
        service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.datastore_type = DatastoreType.AZURE_DATA_LAKE_GEN1  # type: ignore


class AzureDataLakeGen2Datastore(DatastoreProperties, discriminator="AzureDataLakeGen2"):
    """Azure Data Lake Gen2 datastore configuration.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar credentials: [Required] Account credentials. Required.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.DatastoreCredentials
    :ivar is_default: Readonly property to indicate if datastore is the workspace default
     datastore.
    :vartype is_default: bool
    :ivar resource_group: Azure Resource Group name.
    :vartype resource_group: str
    :ivar subscription_id: Azure Subscription Id.
    :vartype subscription_id: str
    :ivar account_name: [Required] Storage account name. Required.
    :vartype account_name: str
    :ivar endpoint: Azure cloud endpoint for the storage account.
    :vartype endpoint: str
    :ivar filesystem: [Required] The name of the Data Lake Gen2 filesystem. Required.
    :vartype filesystem: str
    :ivar protocol: Protocol used to communicate with the storage account.
    :vartype protocol: str
    :ivar service_data_access_auth_identity: Indicates which identity to use to authenticate
     service data access to customer's storage. Known values are: "None",
     "WorkspaceSystemAssignedIdentity", and "WorkspaceUserAssignedIdentity".
    :vartype service_data_access_auth_identity: str or
     ~azure.mgmt.machinelearningservices.models.ServiceDataAccessAuthIdentity
    :ivar datastore_type: [Required] Storage type backing the datastore. Required.
    :vartype datastore_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_DATA_LAKE_GEN2
    """

    resource_group: Optional[str] = rest_field(
        name="resourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Resource Group name."""
    subscription_id: Optional[str] = rest_field(
        name="subscriptionId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Subscription Id."""
    account_name: str = rest_field(name="accountName", visibility=["read", "create"])
    """[Required] Storage account name. Required."""
    endpoint: Optional[str] = rest_field(visibility=["read", "create"])
    """Azure cloud endpoint for the storage account."""
    filesystem: str = rest_field(visibility=["read", "create"])
    """[Required] The name of the Data Lake Gen2 filesystem. Required."""
    protocol: Optional[str] = rest_field(visibility=["read", "create"])
    """Protocol used to communicate with the storage account."""
    service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = rest_field(
        name="serviceDataAccessAuthIdentity", visibility=["read", "create"]
    )
    """Indicates which identity to use to authenticate service data access to customer's storage.
     Known values are: \"None\", \"WorkspaceSystemAssignedIdentity\", and
     \"WorkspaceUserAssignedIdentity\"."""
    datastore_type: Literal[DatastoreType.AZURE_DATA_LAKE_GEN2] = rest_discriminator(name="datastoreType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Storage type backing the datastore. Required."""

    @overload
    def __init__(
        self,
        *,
        credentials: "_models.DatastoreCredentials",
        account_name: str,
        filesystem: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        resource_group: Optional[str] = None,
        subscription_id: Optional[str] = None,
        endpoint: Optional[str] = None,
        protocol: Optional[str] = None,
        service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.datastore_type = DatastoreType.AZURE_DATA_LAKE_GEN2  # type: ignore


class Webhook(_Model):
    """Webhook base.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AzureDevOpsWebhook

    :ivar event_type: Send callback on a specified notification event.
    :vartype event_type: str
    :ivar webhook_type: [Required] Specifies the type of service to send a callback. Required.
     "AzureDevOps"
    :vartype webhook_type: str or ~azure.mgmt.machinelearningservices.models.WebhookType
    """

    __mapping__: dict[str, _Model] = {}
    event_type: Optional[str] = rest_field(name="eventType", visibility=["read", "create"])
    """Send callback on a specified notification event."""
    webhook_type: str = rest_discriminator(name="webhookType", visibility=["read", "create"])
    """[Required] Specifies the type of service to send a callback. Required. \"AzureDevOps\""""

    @overload
    def __init__(
        self,
        *,
        webhook_type: str,
        event_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureDevOpsWebhook(Webhook, discriminator="AzureDevOps"):
    """Webhook details specific for Azure DevOps.

    :ivar event_type: Send callback on a specified notification event.
    :vartype event_type: str
    :ivar webhook_type: [Required] Specifies the type of service to send a callback. Required.
    :vartype webhook_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_DEV_OPS
    """

    webhook_type: Literal[WebhookType.AZURE_DEV_OPS] = rest_discriminator(name="webhookType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of service to send a callback. Required."""

    @overload
    def __init__(
        self,
        *,
        event_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.webhook_type = WebhookType.AZURE_DEV_OPS  # type: ignore


class AzureFileDatastore(DatastoreProperties, discriminator="AzureFile"):
    """Azure File datastore configuration.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar credentials: [Required] Account credentials. Required.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.DatastoreCredentials
    :ivar is_default: Readonly property to indicate if datastore is the workspace default
     datastore.
    :vartype is_default: bool
    :ivar resource_group: Azure Resource Group name.
    :vartype resource_group: str
    :ivar subscription_id: Azure Subscription Id.
    :vartype subscription_id: str
    :ivar account_name: [Required] Storage account name. Required.
    :vartype account_name: str
    :ivar endpoint: Azure cloud endpoint for the storage account.
    :vartype endpoint: str
    :ivar file_share_name: [Required] The name of the Azure file share that the datastore points
     to. Required.
    :vartype file_share_name: str
    :ivar protocol: Protocol used to communicate with the storage account.
    :vartype protocol: str
    :ivar service_data_access_auth_identity: Indicates which identity to use to authenticate
     service data access to customer's storage. Known values are: "None",
     "WorkspaceSystemAssignedIdentity", and "WorkspaceUserAssignedIdentity".
    :vartype service_data_access_auth_identity: str or
     ~azure.mgmt.machinelearningservices.models.ServiceDataAccessAuthIdentity
    :ivar datastore_type: [Required] Storage type backing the datastore. Required.
    :vartype datastore_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_FILE
    """

    resource_group: Optional[str] = rest_field(
        name="resourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Resource Group name."""
    subscription_id: Optional[str] = rest_field(
        name="subscriptionId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure Subscription Id."""
    account_name: str = rest_field(name="accountName", visibility=["read", "create"])
    """[Required] Storage account name. Required."""
    endpoint: Optional[str] = rest_field(visibility=["read", "create"])
    """Azure cloud endpoint for the storage account."""
    file_share_name: str = rest_field(name="fileShareName", visibility=["read", "create"])
    """[Required] The name of the Azure file share that the datastore points to. Required."""
    protocol: Optional[str] = rest_field(visibility=["read", "create"])
    """Protocol used to communicate with the storage account."""
    service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = rest_field(
        name="serviceDataAccessAuthIdentity", visibility=["read", "create"]
    )
    """Indicates which identity to use to authenticate service data access to customer's storage.
     Known values are: \"None\", \"WorkspaceSystemAssignedIdentity\", and
     \"WorkspaceUserAssignedIdentity\"."""
    datastore_type: Literal[DatastoreType.AZURE_FILE] = rest_discriminator(name="datastoreType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Storage type backing the datastore. Required."""

    @overload
    def __init__(
        self,
        *,
        credentials: "_models.DatastoreCredentials",
        account_name: str,
        file_share_name: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        resource_group: Optional[str] = None,
        subscription_id: Optional[str] = None,
        endpoint: Optional[str] = None,
        protocol: Optional[str] = None,
        service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.datastore_type = DatastoreType.AZURE_FILE  # type: ignore


class FineTuningVertical(_Model):
    """FineTuningVertical.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AzureOpenAiFineTuning, CustomModelFineTuning

    :ivar model: [Required] Input model for fine tuning. Required.
    :vartype model: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar model_provider: [Required] Enum to determine the type of fine tuning. Required. Known
     values are: "AzureOpenAI" and "Custom".
    :vartype model_provider: str or ~azure.mgmt.machinelearningservices.models.ModelProvider
    :ivar task_type: [Required] Fine tuning task type. Required. Known values are:
     "ChatCompletion", "TextCompletion", "TextClassification", "QuestionAnswering",
     "TextSummarization", "TokenClassification", "TextTranslation", "ImageClassification",
     "ImageInstanceSegmentation", "ImageObjectDetection", and "VideoMultiObjectTracking".
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.FineTuningTaskType
    :ivar training_data: [Required] Training data for fine tuning. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar validation_data: Validation data for fine tuning.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.JobInput
    """

    __mapping__: dict[str, _Model] = {}
    model: "_models.JobInput" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input model for fine tuning. Required."""
    model_provider: str = rest_discriminator(name="modelProvider", visibility=["read", "create"])
    """[Required] Enum to determine the type of fine tuning. Required. Known values are:
     \"AzureOpenAI\" and \"Custom\"."""
    task_type: Union[str, "_models.FineTuningTaskType"] = rest_field(name="taskType", visibility=["read", "create"])
    """[Required] Fine tuning task type. Required. Known values are: \"ChatCompletion\",
     \"TextCompletion\", \"TextClassification\", \"QuestionAnswering\", \"TextSummarization\",
     \"TokenClassification\", \"TextTranslation\", \"ImageClassification\",
     \"ImageInstanceSegmentation\", \"ImageObjectDetection\", and \"VideoMultiObjectTracking\"."""
    training_data: "_models.JobInput" = rest_field(
        name="trainingData", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Training data for fine tuning. Required."""
    validation_data: Optional["_models.JobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data for fine tuning."""

    @overload
    def __init__(
        self,
        *,
        model: "_models.JobInput",
        model_provider: str,
        task_type: Union[str, "_models.FineTuningTaskType"],
        training_data: "_models.JobInput",
        validation_data: Optional["_models.JobInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AzureOpenAiFineTuning(FineTuningVertical, discriminator="AzureOpenAI"):
    """AzureOpenAiFineTuning.

    :ivar model: [Required] Input model for fine tuning. Required.
    :vartype model: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar task_type: [Required] Fine tuning task type. Required. Known values are:
     "ChatCompletion", "TextCompletion", "TextClassification", "QuestionAnswering",
     "TextSummarization", "TokenClassification", "TextTranslation", "ImageClassification",
     "ImageInstanceSegmentation", "ImageObjectDetection", and "VideoMultiObjectTracking".
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.FineTuningTaskType
    :ivar training_data: [Required] Training data for fine tuning. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar validation_data: Validation data for fine tuning.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar hyper_parameters: HyperParameters for fine tuning Azure Open AI model.
    :vartype hyper_parameters:
     ~azure.mgmt.machinelearningservices.models.AzureOpenAiHyperParameters
    :ivar model_provider: [Required] Enum to determine the type of fine tuning. Required. Fine
     tuning using Azure Open AI model.
    :vartype model_provider: str or ~azure.mgmt.machinelearningservices.models.AZURE_OPEN_AI
    """

    hyper_parameters: Optional["_models.AzureOpenAiHyperParameters"] = rest_field(
        name="hyperParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """HyperParameters for fine tuning Azure Open AI model."""
    model_provider: Literal[ModelProvider.AZURE_OPEN_AI] = rest_discriminator(name="modelProvider", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Enum to determine the type of fine tuning. Required. Fine tuning using Azure Open AI
     model."""

    @overload
    def __init__(
        self,
        *,
        model: "_models.JobInput",
        task_type: Union[str, "_models.FineTuningTaskType"],
        training_data: "_models.JobInput",
        validation_data: Optional["_models.JobInput"] = None,
        hyper_parameters: Optional["_models.AzureOpenAiHyperParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.model_provider = ModelProvider.AZURE_OPEN_AI  # type: ignore


class AzureOpenAiHyperParameters(_Model):
    """Azure Open AI hyperparameters for fine tuning.

    :ivar batch_size: Number of examples in each batch. A larger batch size means that model
     parameters are updated less frequently, but with lower variance.
    :vartype batch_size: int
    :ivar learning_rate_multiplier: Scaling factor for the learning rate. A smaller learning rate
     may be useful to avoid over fitting.
    :vartype learning_rate_multiplier: float
    :ivar n_epochs: The number of epochs to train the model for. An epoch refers to one full cycle
     through the training dataset.
    :vartype n_epochs: int
    """

    batch_size: Optional[int] = rest_field(name="batchSize", visibility=["read", "create", "update", "delete", "query"])
    """Number of examples in each batch. A larger batch size means that model parameters are updated
     less frequently, but with lower variance."""
    learning_rate_multiplier: Optional[float] = rest_field(
        name="learningRateMultiplier", visibility=["read", "create", "update", "delete", "query"]
    )
    """Scaling factor for the learning rate. A smaller learning rate may be useful to avoid over
     fitting."""
    n_epochs: Optional[int] = rest_field(name="nEpochs", visibility=["read", "create", "update", "delete", "query"])
    """The number of epochs to train the model for. An epoch refers to one full cycle through the
     training dataset."""

    @overload
    def __init__(
        self,
        *,
        batch_size: Optional[int] = None,
        learning_rate_multiplier: Optional[float] = None,
        n_epochs: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EarlyTerminationPolicy(_Model):
    """Early termination policies enable canceling poor-performing runs before they complete.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BanditPolicy, MedianStoppingPolicy, TruncationSelectionPolicy

    :ivar delay_evaluation: Number of intervals by which to delay the first evaluation.
    :vartype delay_evaluation: int
    :ivar evaluation_interval: Interval (number of runs) between policy evaluations.
    :vartype evaluation_interval: int
    :ivar policy_type: [Required] Name of policy configuration. Required. Known values are:
     "Bandit", "MedianStopping", and "TruncationSelection".
    :vartype policy_type: str or
     ~azure.mgmt.machinelearningservices.models.EarlyTerminationPolicyType
    """

    __mapping__: dict[str, _Model] = {}
    delay_evaluation: Optional[int] = rest_field(
        name="delayEvaluation", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of intervals by which to delay the first evaluation."""
    evaluation_interval: Optional[int] = rest_field(
        name="evaluationInterval", visibility=["read", "create", "update", "delete", "query"]
    )
    """Interval (number of runs) between policy evaluations."""
    policy_type: str = rest_discriminator(name="policyType", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Name of policy configuration. Required. Known values are: \"Bandit\",
     \"MedianStopping\", and \"TruncationSelection\"."""

    @overload
    def __init__(
        self,
        *,
        policy_type: str,
        delay_evaluation: Optional[int] = None,
        evaluation_interval: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BanditPolicy(EarlyTerminationPolicy, discriminator="Bandit"):
    """Defines an early termination policy based on slack criteria, and a frequency and delay interval
    for evaluation.

    :ivar delay_evaluation: Number of intervals by which to delay the first evaluation.
    :vartype delay_evaluation: int
    :ivar evaluation_interval: Interval (number of runs) between policy evaluations.
    :vartype evaluation_interval: int
    :ivar slack_amount: Absolute distance allowed from the best performing run.
    :vartype slack_amount: float
    :ivar slack_factor: Ratio of the allowed distance from the best performing run.
    :vartype slack_factor: float
    :ivar policy_type: [Required] Name of policy configuration. Required.
    :vartype policy_type: str or ~azure.mgmt.machinelearningservices.models.BANDIT
    """

    slack_amount: Optional[float] = rest_field(
        name="slackAmount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Absolute distance allowed from the best performing run."""
    slack_factor: Optional[float] = rest_field(
        name="slackFactor", visibility=["read", "create", "update", "delete", "query"]
    )
    """Ratio of the allowed distance from the best performing run."""
    policy_type: Literal[EarlyTerminationPolicyType.BANDIT] = rest_discriminator(name="policyType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Name of policy configuration. Required."""

    @overload
    def __init__(
        self,
        *,
        delay_evaluation: Optional[int] = None,
        evaluation_interval: Optional[int] = None,
        slack_amount: Optional[float] = None,
        slack_factor: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.policy_type = EarlyTerminationPolicyType.BANDIT  # type: ignore


class Resource(_Model):
    """Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}."""
    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the resource."""
    type: Optional[str] = rest_field(visibility=["read"])
    """The type of the resource. E.g. \"Microsoft.Compute/virtualMachines\" or
     \"Microsoft.Storage/storageAccounts\"."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Azure Resource Manager metadata containing createdBy and modifiedBy information."""


class TrackedResource(Resource):
    """Tracked Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    """

    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""
    location: str = rest_field(visibility=["read", "create"])
    """The geo-location where the resource lives. Required."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchDeployment(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.BatchDeploymentProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.BatchDeploymentProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.BatchDeploymentProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchDeploymentConfiguration(_Model):
    """Properties relevant to different deployment types.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BatchPipelineComponentDeploymentConfiguration

    :ivar deployment_configuration_type: [Required] The type of the deployment. Required. Known
     values are: "Model" and "PipelineComponent".
    :vartype deployment_configuration_type: str or
     ~azure.mgmt.machinelearningservices.models.BatchDeploymentConfigurationType
    """

    __mapping__: dict[str, _Model] = {}
    deployment_configuration_type: str = rest_discriminator(
        name="deploymentConfigurationType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The type of the deployment. Required. Known values are: \"Model\" and
     \"PipelineComponent\"."""

    @overload
    def __init__(
        self,
        *,
        deployment_configuration_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointDeploymentPropertiesBase(_Model):
    """Base definition for endpoint deployment.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.mgmt.machinelearningservices.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    """

    code_configuration: Optional["_models.CodeConfiguration"] = rest_field(
        name="codeConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Code configuration for the endpoint deployment."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the endpoint deployment."""
    environment_id: Optional[str] = rest_field(
        name="environmentId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM resource ID or AssetId of the environment specification for the endpoint deployment."""
    environment_variables: Optional[dict[str, str]] = rest_field(
        name="environmentVariables", visibility=["read", "create", "update", "delete", "query"]
    )
    """Environment variables configuration for the deployment."""
    properties: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Property dictionary. Properties can be added, but not removed or altered."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        properties: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchDeploymentProperties(EndpointDeploymentPropertiesBase):
    """Batch inference settings per deployment.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.mgmt.machinelearningservices.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar compute: Compute target for batch inference operation.
    :vartype compute: str
    :ivar deployment_configuration: Properties relevant to different deployment types.
    :vartype deployment_configuration:
     ~azure.mgmt.machinelearningservices.models.BatchDeploymentConfiguration
    :ivar error_threshold: Error threshold, if the error count for the entire input goes above this
     value,
     the batch inference will be aborted. Range is [-1, int.MaxValue].
     For FileDataset, this value is the count of file failures.
     For TabularDataset, this value is the count of record failures.
     If set to -1 (the lower bound), all failures during batch inference will be ignored.
    :vartype error_threshold: int
    :ivar logging_level: Log verbosity for batch inferencing.
     Increasing verbosity order for logging is : Warning, Info and Debug.
     The default value is Info. Known values are: "Info", "Warning", and "Debug".
    :vartype logging_level: str or ~azure.mgmt.machinelearningservices.models.BatchLoggingLevel
    :ivar max_concurrency_per_instance: Indicates maximum number of parallelism per instance.
    :vartype max_concurrency_per_instance: int
    :ivar mini_batch_size: Size of the mini-batch passed to each batch invocation.
     For FileDataset, this is the number of files per mini-batch.
     For TabularDataset, this is the size of the records in bytes, per mini-batch.
    :vartype mini_batch_size: int
    :ivar model: Reference to the model asset for the endpoint deployment.
    :vartype model: ~azure.mgmt.machinelearningservices.models.AssetReferenceBase
    :ivar output_action: Enum to determine how batch inferencing will handle output. Known values
     are: "SummaryOnly" and "AppendRow".
    :vartype output_action: str or ~azure.mgmt.machinelearningservices.models.BatchOutputAction
    :ivar output_file_name: Customized output file name for append_row output action.
    :vartype output_file_name: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Known values are:
     "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentProvisioningState
    :ivar resources: Indicates compute configuration for the job.
     If not provided, will default to the defaults defined in ResourceConfiguration.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.DeploymentResourceConfiguration
    :ivar retry_settings: Retry Settings for the batch inference operation.
     If not provided, will default to the defaults defined in BatchRetrySettings.
    :vartype retry_settings: ~azure.mgmt.machinelearningservices.models.BatchRetrySettings
    """

    compute: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Compute target for batch inference operation."""
    deployment_configuration: Optional["_models.BatchDeploymentConfiguration"] = rest_field(
        name="deploymentConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties relevant to different deployment types."""
    error_threshold: Optional[int] = rest_field(
        name="errorThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """Error threshold, if the error count for the entire input goes above this value,
     the batch inference will be aborted. Range is [-1, int.MaxValue].
     For FileDataset, this value is the count of file failures.
     For TabularDataset, this value is the count of record failures.
     If set to -1 (the lower bound), all failures during batch inference will be ignored."""
    logging_level: Optional[Union[str, "_models.BatchLoggingLevel"]] = rest_field(
        name="loggingLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Log verbosity for batch inferencing.
     Increasing verbosity order for logging is : Warning, Info and Debug.
     The default value is Info. Known values are: \"Info\", \"Warning\", and \"Debug\"."""
    max_concurrency_per_instance: Optional[int] = rest_field(
        name="maxConcurrencyPerInstance", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates maximum number of parallelism per instance."""
    mini_batch_size: Optional[int] = rest_field(
        name="miniBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Size of the mini-batch passed to each batch invocation.
     For FileDataset, this is the number of files per mini-batch.
     For TabularDataset, this is the size of the records in bytes, per mini-batch."""
    model: Optional["_models.AssetReferenceBase"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Reference to the model asset for the endpoint deployment."""
    output_action: Optional[Union[str, "_models.BatchOutputAction"]] = rest_field(
        name="outputAction", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum to determine how batch inferencing will handle output. Known values are: \"SummaryOnly\"
     and \"AppendRow\"."""
    output_file_name: Optional[str] = rest_field(
        name="outputFileName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Customized output file name for append_row output action."""
    provisioning_state: Optional[Union[str, "_models.DeploymentProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint deployment. Known values are: \"Creating\", \"Deleting\",
     \"Scaling\", \"Updating\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    resources: Optional["_models.DeploymentResourceConfiguration"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates compute configuration for the job.
     If not provided, will default to the defaults defined in ResourceConfiguration."""
    retry_settings: Optional["_models.BatchRetrySettings"] = rest_field(
        name="retrySettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Retry Settings for the batch inference operation.
     If not provided, will default to the defaults defined in BatchRetrySettings."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        properties: Optional[dict[str, str]] = None,
        compute: Optional[str] = None,
        deployment_configuration: Optional["_models.BatchDeploymentConfiguration"] = None,
        error_threshold: Optional[int] = None,
        logging_level: Optional[Union[str, "_models.BatchLoggingLevel"]] = None,
        max_concurrency_per_instance: Optional[int] = None,
        mini_batch_size: Optional[int] = None,
        model: Optional["_models.AssetReferenceBase"] = None,
        output_action: Optional[Union[str, "_models.BatchOutputAction"]] = None,
        output_file_name: Optional[str] = None,
        resources: Optional["_models.DeploymentResourceConfiguration"] = None,
        retry_settings: Optional["_models.BatchRetrySettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchEndpoint(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.BatchEndpointProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.BatchEndpointProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.BatchEndpointProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchEndpointDefaults(_Model):
    """Batch endpoint default values.

    :ivar deployment_name: Name of the deployment that will be default for the endpoint.
     This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
    :vartype deployment_name: str
    """

    deployment_name: Optional[str] = rest_field(
        name="deploymentName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the deployment that will be default for the endpoint.
     This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked."""

    @overload
    def __init__(
        self,
        *,
        deployment_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointPropertiesBase(_Model):
    """Inference Endpoint base definition.

    :ivar auth_mode: [Required] The authentication method for invoking the endpoint (data plane
     operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning
     token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
     Required. Known values are: "AMLToken", "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.mgmt.machinelearningservices.models.EndpointAuthMode
    :ivar description: Description of the inference endpoint.
    :vartype description: str
    :ivar keys_property: EndpointAuthKeys to set initially on an Endpoint.
     This property will always be returned as null. AuthKey values must be retrieved using the
     ListKeys API.
    :vartype keys_property: ~azure.mgmt.machinelearningservices.models.EndpointAuthKeys
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar scoring_uri: Endpoint URI.
    :vartype scoring_uri: str
    :ivar swagger_uri: Endpoint Swagger URI.
    :vartype swagger_uri: str
    """

    auth_mode: Union[str, "_models.EndpointAuthMode"] = rest_field(
        name="authMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The authentication method for invoking the endpoint (data plane operation). Use
     'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning token-based
     authentication. Use 'AADToken' for Microsoft Entra token-based authentication. Required. Known
     values are: \"AMLToken\", \"Key\", and \"AADToken\"."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the inference endpoint."""
    keys_property: Optional["_models.EndpointAuthKeys"] = rest_field(
        name="keys", visibility=["create"], original_tsp_name="keys"
    )
    """EndpointAuthKeys to set initially on an Endpoint.
     This property will always be returned as null. AuthKey values must be retrieved using the
     ListKeys API."""
    properties: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Property dictionary. Properties can be added, but not removed or altered."""
    scoring_uri: Optional[str] = rest_field(name="scoringUri", visibility=["read"])
    """Endpoint URI."""
    swagger_uri: Optional[str] = rest_field(name="swaggerUri", visibility=["read"])
    """Endpoint Swagger URI."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.EndpointAuthMode"],
        description: Optional[str] = None,
        keys_property: Optional["_models.EndpointAuthKeys"] = None,
        properties: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchEndpointProperties(EndpointPropertiesBase):
    """Batch endpoint configuration.

    :ivar auth_mode: [Required] The authentication method for invoking the endpoint (data plane
     operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning
     token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
     Required. Known values are: "AMLToken", "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.mgmt.machinelearningservices.models.EndpointAuthMode
    :ivar description: Description of the inference endpoint.
    :vartype description: str
    :ivar keys_property: EndpointAuthKeys to set initially on an Endpoint.
     This property will always be returned as null. AuthKey values must be retrieved using the
     ListKeys API.
    :vartype keys_property: ~azure.mgmt.machinelearningservices.models.EndpointAuthKeys
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar scoring_uri: Endpoint URI.
    :vartype scoring_uri: str
    :ivar swagger_uri: Endpoint Swagger URI.
    :vartype swagger_uri: str
    :ivar defaults: Default values for Batch Endpoint.
    :vartype defaults: ~azure.mgmt.machinelearningservices.models.BatchEndpointDefaults
    :ivar provisioning_state: Provisioning state for the endpoint. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.EndpointProvisioningState
    """

    defaults: Optional["_models.BatchEndpointDefaults"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Default values for Batch Endpoint."""
    provisioning_state: Optional[Union[str, "_models.EndpointProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint. Known values are: \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.EndpointAuthMode"],
        description: Optional[str] = None,
        keys_property: Optional["_models.EndpointAuthKeys"] = None,
        properties: Optional[dict[str, str]] = None,
        defaults: Optional["_models.BatchEndpointDefaults"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BatchPipelineComponentDeploymentConfiguration(
    BatchDeploymentConfiguration, discriminator="PipelineComponent"
):  # pylint: disable=name-too-long
    """Properties for a Batch Pipeline Component Deployment.

    :ivar component_id: The ARM id of the component to be run.
    :vartype component_id: ~azure.mgmt.machinelearningservices.models.IdAssetReference
    :ivar description: The description which will be applied to the job.
    :vartype description: str
    :ivar settings: Run-time settings for the pipeline job.
    :vartype settings: dict[str, str]
    :ivar tags: The tags which will be applied to the job.
    :vartype tags: dict[str, str]
    :ivar deployment_configuration_type: [Required] The type of the deployment. Required.
    :vartype deployment_configuration_type: str or
     ~azure.mgmt.machinelearningservices.models.PIPELINE_COMPONENT
    """

    component_id: Optional["_models.IdAssetReference"] = rest_field(
        name="componentId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ARM id of the component to be run."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description which will be applied to the job."""
    settings: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Run-time settings for the pipeline job."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The tags which will be applied to the job."""
    deployment_configuration_type: Literal[BatchDeploymentConfigurationType.PIPELINE_COMPONENT] = rest_discriminator(name="deploymentConfigurationType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] The type of the deployment. Required."""

    @overload
    def __init__(
        self,
        *,
        component_id: Optional["_models.IdAssetReference"] = None,
        description: Optional[str] = None,
        settings: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.deployment_configuration_type = BatchDeploymentConfigurationType.PIPELINE_COMPONENT  # type: ignore


class BatchRetrySettings(_Model):
    """Retry settings for a batch inference operation.

    :ivar max_retries: Maximum retry count for a mini-batch.
    :vartype max_retries: int
    :ivar timeout: Invocation timeout for a mini-batch, in ISO 8601 format.
    :vartype timeout: ~datetime.timedelta
    """

    max_retries: Optional[int] = rest_field(
        name="maxRetries", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum retry count for a mini-batch."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Invocation timeout for a mini-batch, in ISO 8601 format."""

    @overload
    def __init__(
        self,
        *,
        max_retries: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SamplingAlgorithm(_Model):
    """The Sampling Algorithm used to generate hyperparameter values, along with properties to
    configure the algorithm.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BayesianSamplingAlgorithm, GridSamplingAlgorithm, RandomSamplingAlgorithm

    :ivar sampling_algorithm_type: [Required] The algorithm used for generating hyperparameter
     values, along with configuration properties. Required. Known values are: "Grid", "Random", and
     "Bayesian".
    :vartype sampling_algorithm_type: str or
     ~azure.mgmt.machinelearningservices.models.SamplingAlgorithmType
    """

    __mapping__: dict[str, _Model] = {}
    sampling_algorithm_type: str = rest_discriminator(
        name="samplingAlgorithmType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The algorithm used for generating hyperparameter values, along with configuration
     properties. Required. Known values are: \"Grid\", \"Random\", and \"Bayesian\"."""

    @overload
    def __init__(
        self,
        *,
        sampling_algorithm_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BayesianSamplingAlgorithm(SamplingAlgorithm, discriminator="Bayesian"):
    """Defines a Sampling Algorithm that generates values based on previous values.

    :ivar sampling_algorithm_type: [Required] The algorithm used for generating hyperparameter
     values, along with configuration properties. Required.
    :vartype sampling_algorithm_type: str or ~azure.mgmt.machinelearningservices.models.BAYESIAN
    """

    sampling_algorithm_type: Literal[SamplingAlgorithmType.BAYESIAN] = rest_discriminator(name="samplingAlgorithmType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] The algorithm used for generating hyperparameter values, along with configuration
     properties. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.sampling_algorithm_type = SamplingAlgorithmType.BAYESIAN  # type: ignore


class BindOptions(_Model):
    """BindOptions.

    :ivar propagation: Type of Bind Option.
    :vartype propagation: str
    :ivar create_host_path: Indicate whether to create host path.
    :vartype create_host_path: bool
    :ivar selinux: Mention the selinux options.
    :vartype selinux: str
    """

    propagation: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Type of Bind Option."""
    create_host_path: Optional[bool] = rest_field(
        name="createHostPath", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicate whether to create host path."""
    selinux: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Mention the selinux options."""

    @overload
    def __init__(
        self,
        *,
        propagation: Optional[str] = None,
        create_host_path: Optional[bool] = None,
        selinux: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BlobReferenceForConsumptionDto(_Model):
    """BlobReferenceForConsumptionDto.

    :ivar blob_uri: Blob URI path for client to upload data.
     Example: `https://blob.windows.core.net/Container/Path
     <https://blob.windows.core.net/Container/Path>`_.
    :vartype blob_uri: str
    :ivar credential: Credential info to access storage account.
    :vartype credential: ~azure.mgmt.machinelearningservices.models.PendingUploadCredentialDto
    :ivar storage_account_arm_id: Arm ID of the storage account to use.
    :vartype storage_account_arm_id: str
    """

    blob_uri: Optional[str] = rest_field(name="blobUri", visibility=["read", "create", "update", "delete", "query"])
    """Blob URI path for client to upload data.
     Example: `https://blob.windows.core.net/Container/Path
     <https://blob.windows.core.net/Container/Path>`_."""
    credential: Optional["_models.PendingUploadCredentialDto"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Credential info to access storage account."""
    storage_account_arm_id: Optional[str] = rest_field(
        name="storageAccountArmId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Arm ID of the storage account to use."""

    @overload
    def __init__(
        self,
        *,
        blob_uri: Optional[str] = None,
        credential: Optional["_models.PendingUploadCredentialDto"] = None,
        storage_account_arm_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BuildContext(_Model):
    """Configuration settings for Docker build context.

    :ivar context_uri: [Required] URI of the Docker build context used to build the image. Supports
     blob URIs on environment creation and may return blob or Git URIs.
     <seealso
     href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />.
     Required.
    :vartype context_uri: str
    :ivar dockerfile_path: Path to the Dockerfile in the build context.
     <seealso href="https://docs.docker.com/engine/reference/builder/" />.
    :vartype dockerfile_path: str
    """

    context_uri: str = rest_field(name="contextUri", visibility=["read", "create"])
    """[Required] URI of the Docker build context used to build the image. Supports blob URIs on
     environment creation and may return blob or Git URIs.
     <seealso
     href=\"https://docs.docker.com/engine/reference/commandline/build/#extended-description\" />.
     Required."""
    dockerfile_path: Optional[str] = rest_field(name="dockerfilePath", visibility=["read", "create"])
    """Path to the Dockerfile in the build context.
     <seealso href=\"https://docs.docker.com/engine/reference/builder/\" />."""

    @overload
    def __init__(
        self,
        *,
        context_uri: str,
        dockerfile_path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProxyResource(Resource):
    """Proxy Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    """


class CapabilityHost(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.CapabilityHostProperties
    """

    properties: "_models.CapabilityHostProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.CapabilityHostProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapabilityHostProperties(ResourceBase):
    """CapabilityHostProperties.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar aca_environment_connections: List of Aca Environment connections.
    :vartype aca_environment_connections: list[str]
    :ivar ai_services_connections: List of AI services connections.
    :vartype ai_services_connections: list[str]
    :ivar capability_host_kind: Kind of this capability host. "Agents"
    :vartype capability_host_kind: str or
     ~azure.mgmt.machinelearningservices.models.CapabilityHostKind
    :ivar customer_subnet: Customer subnet info to help set up this capability host.
    :vartype customer_subnet: str
    :ivar provisioning_state: Provisioning state for the CapabilityHost. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.CapabilityHostProvisioningState
    :ivar storage_connections: List of Storage connections.
    :vartype storage_connections: list[str]
    :ivar thread_storage_connections: List of Thread storage connections.
    :vartype thread_storage_connections: list[str]
    :ivar vector_store_connections: List of VectorStore connections.
    :vartype vector_store_connections: list[str]
    :ivar messages: List of messages containing errors.
    :vartype messages: list[str]
    """

    aca_environment_connections: Optional[list[str]] = rest_field(
        name="acaEnvironmentConnections", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of Aca Environment connections."""
    ai_services_connections: Optional[list[str]] = rest_field(
        name="aiServicesConnections", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of AI services connections."""
    capability_host_kind: Optional[Union[str, "_models.CapabilityHostKind"]] = rest_field(
        name="capabilityHostKind", visibility=["read", "create", "update", "delete", "query"]
    )
    """Kind of this capability host. \"Agents\""""
    customer_subnet: Optional[str] = rest_field(
        name="customerSubnet", visibility=["read", "create", "update", "delete", "query"]
    )
    """Customer subnet info to help set up this capability host."""
    provisioning_state: Optional[Union[str, "_models.CapabilityHostProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the CapabilityHost. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    storage_connections: Optional[list[str]] = rest_field(
        name="storageConnections", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of Storage connections."""
    thread_storage_connections: Optional[list[str]] = rest_field(
        name="threadStorageConnections", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of Thread storage connections."""
    vector_store_connections: Optional[list[str]] = rest_field(
        name="vectorStoreConnections", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of VectorStore connections."""
    messages: Optional[list[str]] = rest_field(visibility=["read"])
    """List of messages containing errors."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        aca_environment_connections: Optional[list[str]] = None,
        ai_services_connections: Optional[list[str]] = None,
        capability_host_kind: Optional[Union[str, "_models.CapabilityHostKind"]] = None,
        customer_subnet: Optional[str] = None,
        storage_connections: Optional[list[str]] = None,
        thread_storage_connections: Optional[list[str]] = None,
        vector_store_connections: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataDriftMetricThresholdBase(_Model):
    """DataDriftMetricThresholdBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CategoricalDataDriftMetricThreshold, NumericalDataDriftMetricThreshold

    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Known
     values are: "Numerical" and "Categorical".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType
    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    """

    __mapping__: dict[str, _Model] = {}
    data_type: str = rest_discriminator(name="dataType", visibility=["read", "create"])
    """[Required] Specifies the data type of the metric threshold. Required. Known values are:
     \"Numerical\" and \"Categorical\"."""
    threshold: Optional["_models.MonitoringThreshold"] = rest_field(visibility=["read", "create"])
    """The threshold value. If null, a default value will be set depending on the selected metric."""

    @overload
    def __init__(
        self,
        *,
        data_type: str,
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CategoricalDataDriftMetricThreshold(DataDriftMetricThresholdBase, discriminator="Categorical"):
    """CategoricalDataDriftMetricThreshold.

    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    :ivar metric: [Required] The categorical data drift metric to calculate. Required. Known values
     are: "JensenShannonDistance", "PopulationStabilityIndex", and "PearsonsChiSquaredTest".
    :vartype metric: str or ~azure.mgmt.machinelearningservices.models.CategoricalDataDriftMetric
    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Used for
     features of categorical data type.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.CATEGORICAL
    """

    metric: Union[str, "_models.CategoricalDataDriftMetric"] = rest_field(visibility=["read", "create"])
    """[Required] The categorical data drift metric to calculate. Required. Known values are:
     \"JensenShannonDistance\", \"PopulationStabilityIndex\", and \"PearsonsChiSquaredTest\"."""
    data_type: Literal[MonitoringFeatureDataType.CATEGORICAL] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the data type of the metric threshold. Required. Used for features of
     categorical data type."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.CategoricalDataDriftMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = MonitoringFeatureDataType.CATEGORICAL  # type: ignore


class DataQualityMetricThresholdBase(_Model):
    """DataQualityMetricThresholdBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CategoricalDataQualityMetricThreshold, NumericalDataQualityMetricThreshold

    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Known
     values are: "Numerical" and "Categorical".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType
    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    """

    __mapping__: dict[str, _Model] = {}
    data_type: str = rest_discriminator(name="dataType", visibility=["read", "create"])
    """[Required] Specifies the data type of the metric threshold. Required. Known values are:
     \"Numerical\" and \"Categorical\"."""
    threshold: Optional["_models.MonitoringThreshold"] = rest_field(visibility=["read", "create"])
    """The threshold value. If null, a default value will be set depending on the selected metric."""

    @overload
    def __init__(
        self,
        *,
        data_type: str,
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CategoricalDataQualityMetricThreshold(DataQualityMetricThresholdBase, discriminator="Categorical"):
    """CategoricalDataQualityMetricThreshold.

    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    :ivar metric: [Required] The categorical data quality metric to calculate. Required. Known
     values are: "NullValueRate", "DataTypeErrorRate", and "OutOfBoundsRate".
    :vartype metric: str or ~azure.mgmt.machinelearningservices.models.CategoricalDataQualityMetric
    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Used for
     features of categorical data type.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.CATEGORICAL
    """

    metric: Union[str, "_models.CategoricalDataQualityMetric"] = rest_field(visibility=["read", "create"])
    """[Required] The categorical data quality metric to calculate. Required. Known values are:
     \"NullValueRate\", \"DataTypeErrorRate\", and \"OutOfBoundsRate\"."""
    data_type: Literal[MonitoringFeatureDataType.CATEGORICAL] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the data type of the metric threshold. Required. Used for features of
     categorical data type."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.CategoricalDataQualityMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = MonitoringFeatureDataType.CATEGORICAL  # type: ignore


class PredictionDriftMetricThresholdBase(_Model):
    """PredictionDriftMetricThresholdBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CategoricalPredictionDriftMetricThreshold, NumericalPredictionDriftMetricThreshold

    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Known
     values are: "Numerical" and "Categorical".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType
    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    """

    __mapping__: dict[str, _Model] = {}
    data_type: str = rest_discriminator(name="dataType", visibility=["read", "create"])
    """[Required] Specifies the data type of the metric threshold. Required. Known values are:
     \"Numerical\" and \"Categorical\"."""
    threshold: Optional["_models.MonitoringThreshold"] = rest_field(visibility=["read", "create"])
    """The threshold value. If null, a default value will be set depending on the selected metric."""

    @overload
    def __init__(
        self,
        *,
        data_type: str,
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CategoricalPredictionDriftMetricThreshold(
    PredictionDriftMetricThresholdBase, discriminator="Categorical"
):  # pylint: disable=name-too-long
    """CategoricalPredictionDriftMetricThreshold.

    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    :ivar metric: [Required] The categorical prediction drift metric to calculate. Required. Known
     values are: "JensenShannonDistance", "PopulationStabilityIndex", and "PearsonsChiSquaredTest".
    :vartype metric: str or
     ~azure.mgmt.machinelearningservices.models.CategoricalPredictionDriftMetric
    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Used for
     features of categorical data type.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.CATEGORICAL
    """

    metric: Union[str, "_models.CategoricalPredictionDriftMetric"] = rest_field(visibility=["read", "create"])
    """[Required] The categorical prediction drift metric to calculate. Required. Known values are:
     \"JensenShannonDistance\", \"PopulationStabilityIndex\", and \"PearsonsChiSquaredTest\"."""
    data_type: Literal[MonitoringFeatureDataType.CATEGORICAL] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the data type of the metric threshold. Required. Used for features of
     categorical data type."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.CategoricalPredictionDriftMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = MonitoringFeatureDataType.CATEGORICAL  # type: ignore


class CertificateDatastoreCredentials(DatastoreCredentials, discriminator="Certificate"):
    """Certificate datastore credentials configuration.

    :ivar authority_url: Authority URL used for authentication.
    :vartype authority_url: str
    :ivar client_id: [Required] Service principal client ID. Required.
    :vartype client_id: str
    :ivar resource_url: Resource the service principal has access to.
    :vartype resource_url: str
    :ivar secrets: [Required] Service principal secrets. Required.
    :vartype secrets: ~azure.mgmt.machinelearningservices.models.CertificateDatastoreSecrets
    :ivar tenant_id: [Required] ID of the tenant to which the service principal belongs. Required.
    :vartype tenant_id: str
    :ivar thumbprint: [Required] Thumbprint of the certificate used for authentication. Required.
    :vartype thumbprint: str
    :ivar credentials_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credentials_type: str or ~azure.mgmt.machinelearningservices.models.CERTIFICATE
    """

    authority_url: Optional[str] = rest_field(
        name="authorityUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Authority URL used for authentication."""
    client_id: str = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Service principal client ID. Required."""
    resource_url: Optional[str] = rest_field(
        name="resourceUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource the service principal has access to."""
    secrets: "_models.CertificateDatastoreSecrets" = rest_field(visibility=["create", "update"])
    """[Required] Service principal secrets. Required."""
    tenant_id: str = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] ID of the tenant to which the service principal belongs. Required."""
    thumbprint: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Thumbprint of the certificate used for authentication. Required."""
    credentials_type: Literal[CredentialsType.CERTIFICATE] = rest_discriminator(name="credentialsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        client_id: str,
        secrets: "_models.CertificateDatastoreSecrets",
        tenant_id: str,
        thumbprint: str,
        authority_url: Optional[str] = None,
        resource_url: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credentials_type = CredentialsType.CERTIFICATE  # type: ignore


class CertificateDatastoreSecrets(DatastoreSecrets, discriminator="Certificate"):
    """Datastore certificate secrets.

    :ivar certificate: Service principal certificate.
    :vartype certificate: str
    :ivar secrets_type: [Required] Credential type used to authentication with storage. Required.
    :vartype secrets_type: str or ~azure.mgmt.machinelearningservices.models.CERTIFICATE
    """

    certificate: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Service principal certificate."""
    secrets_type: Literal[SecretsType.CERTIFICATE] = rest_discriminator(name="secretsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        certificate: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.secrets_type = SecretsType.CERTIFICATE  # type: ignore


class Classification(AutoMLVertical, discriminator="Classification"):
    """Classification task in AutoML Table vertical.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar cv_split_column_names: Columns to use for CVSplit data.
    :vartype cv_split_column_names: list[str]
    :ivar featurization_settings: Featurization inputs needed for AutoML job.
    :vartype featurization_settings:
     ~azure.mgmt.machinelearningservices.models.TableVerticalFeaturizationSettings
    :ivar limit_settings: Execution constraints for AutoMLJob.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.TableVerticalLimitSettings
    :ivar n_cross_validations: Number of cross validation folds to be applied on training dataset
     when validation dataset is not provided.
    :vartype n_cross_validations: ~azure.mgmt.machinelearningservices.models.NCrossValidations
    :ivar test_data: Test data input.
    :vartype test_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar test_data_size: The fraction of test dataset that needs to be set aside for validation
     purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype test_data_size: float
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar weight_column_name: The name of the sample weight column. Automated ML supports a
     weighted column as an input, causing rows in the data to be weighted up or down.
    :vartype weight_column_name: str
    :ivar positive_label: Positive label for binary metrics calculation.
    :vartype positive_label: str
    :ivar primary_metric: Primary metrics for classification tasks. Known values are:
     "AUCWeighted", "Accuracy", "NormMacroRecall", "AveragePrecisionScoreWeighted", and
     "PrecisionScoreWeighted".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ClassificationPrimaryMetrics
    :ivar training_settings: Inputs for training phase for an AutoML Job.
    :vartype training_settings:
     ~azure.mgmt.machinelearningservices.models.ClassificationTrainingSettings
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Classification in machine
     learning and statistics is a supervised learning approach in which
     the computer program learns from the data given to it and make new observations or
     classifications.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.CLASSIFICATION
    """

    cv_split_column_names: Optional[list[str]] = rest_field(
        name="cvSplitColumnNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """Columns to use for CVSplit data."""
    featurization_settings: Optional["_models.TableVerticalFeaturizationSettings"] = rest_field(
        name="featurizationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization inputs needed for AutoML job."""
    limit_settings: Optional["_models.TableVerticalLimitSettings"] = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Execution constraints for AutoMLJob."""
    n_cross_validations: Optional["_models.NCrossValidations"] = rest_field(
        name="nCrossValidations", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of cross validation folds to be applied on training dataset
     when validation dataset is not provided."""
    test_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="testData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Test data input."""
    test_data_size: Optional[float] = rest_field(
        name="testDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of test dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    weight_column_name: Optional[str] = rest_field(
        name="weightColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the sample weight column. Automated ML supports a weighted column as an input,
     causing rows in the data to be weighted up or down."""
    positive_label: Optional[str] = rest_field(
        name="positiveLabel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Positive label for binary metrics calculation."""
    primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for classification tasks. Known values are: \"AUCWeighted\", \"Accuracy\",
     \"NormMacroRecall\", \"AveragePrecisionScoreWeighted\", and \"PrecisionScoreWeighted\"."""
    training_settings: Optional["_models.ClassificationTrainingSettings"] = rest_field(
        name="trainingSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Inputs for training phase for an AutoML Job."""
    task_type: Literal[TaskType.CLASSIFICATION] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Classification in machine learning and statistics
     is a supervised learning approach in which
     the computer program learns from the data given to it and make new observations or
     classifications."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        cv_split_column_names: Optional[list[str]] = None,
        featurization_settings: Optional["_models.TableVerticalFeaturizationSettings"] = None,
        limit_settings: Optional["_models.TableVerticalLimitSettings"] = None,
        n_cross_validations: Optional["_models.NCrossValidations"] = None,
        test_data: Optional["_models.MLTableJobInput"] = None,
        test_data_size: Optional[float] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        weight_column_name: Optional[str] = None,
        positive_label: Optional[str] = None,
        primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = None,
        training_settings: Optional["_models.ClassificationTrainingSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.CLASSIFICATION  # type: ignore


class TrainingSettings(_Model):
    """Training related configuration.

    :ivar enable_dnn_training: Enable recommendation of DNN models.
    :vartype enable_dnn_training: bool
    :ivar enable_model_explainability: Flag to turn on explainability on best model.
    :vartype enable_model_explainability: bool
    :ivar enable_onnx_compatible_models: Flag for enabling onnx compatible models.
    :vartype enable_onnx_compatible_models: bool
    :ivar enable_stack_ensemble: Enable stack ensemble run.
    :vartype enable_stack_ensemble: bool
    :ivar enable_vote_ensemble: Enable voting ensemble run.
    :vartype enable_vote_ensemble: bool
    :ivar ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model
     generation, multiple fitted models from the previous child runs are downloaded.
     Configure this parameter with a higher value than 300 secs, if more time is needed.
    :vartype ensemble_model_download_timeout: ~datetime.timedelta
    :ivar stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
    :vartype stack_ensemble_settings:
     ~azure.mgmt.machinelearningservices.models.StackEnsembleSettings
    """

    enable_dnn_training: Optional[bool] = rest_field(
        name="enableDnnTraining", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable recommendation of DNN models."""
    enable_model_explainability: Optional[bool] = rest_field(
        name="enableModelExplainability", visibility=["read", "create", "update", "delete", "query"]
    )
    """Flag to turn on explainability on best model."""
    enable_onnx_compatible_models: Optional[bool] = rest_field(
        name="enableOnnxCompatibleModels", visibility=["read", "create", "update", "delete", "query"]
    )
    """Flag for enabling onnx compatible models."""
    enable_stack_ensemble: Optional[bool] = rest_field(
        name="enableStackEnsemble", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable stack ensemble run."""
    enable_vote_ensemble: Optional[bool] = rest_field(
        name="enableVoteEnsemble", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable voting ensemble run."""
    ensemble_model_download_timeout: Optional[datetime.timedelta] = rest_field(
        name="ensembleModelDownloadTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the
     previous child runs are downloaded.
     Configure this parameter with a higher value than 300 secs, if more time is needed."""
    stack_ensemble_settings: Optional["_models.StackEnsembleSettings"] = rest_field(
        name="stackEnsembleSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Stack ensemble settings for stack ensemble run."""

    @overload
    def __init__(
        self,
        *,
        enable_dnn_training: Optional[bool] = None,
        enable_model_explainability: Optional[bool] = None,
        enable_onnx_compatible_models: Optional[bool] = None,
        enable_stack_ensemble: Optional[bool] = None,
        enable_vote_ensemble: Optional[bool] = None,
        ensemble_model_download_timeout: Optional[datetime.timedelta] = None,
        stack_ensemble_settings: Optional["_models.StackEnsembleSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClassificationTrainingSettings(TrainingSettings):
    """Classification Training related configuration.

    :ivar enable_dnn_training: Enable recommendation of DNN models.
    :vartype enable_dnn_training: bool
    :ivar enable_model_explainability: Flag to turn on explainability on best model.
    :vartype enable_model_explainability: bool
    :ivar enable_onnx_compatible_models: Flag for enabling onnx compatible models.
    :vartype enable_onnx_compatible_models: bool
    :ivar enable_stack_ensemble: Enable stack ensemble run.
    :vartype enable_stack_ensemble: bool
    :ivar enable_vote_ensemble: Enable voting ensemble run.
    :vartype enable_vote_ensemble: bool
    :ivar ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model
     generation, multiple fitted models from the previous child runs are downloaded.
     Configure this parameter with a higher value than 300 secs, if more time is needed.
    :vartype ensemble_model_download_timeout: ~datetime.timedelta
    :ivar stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
    :vartype stack_ensemble_settings:
     ~azure.mgmt.machinelearningservices.models.StackEnsembleSettings
    :ivar allowed_training_algorithms: Allowed models for classification task.
    :vartype allowed_training_algorithms: list[str or
     ~azure.mgmt.machinelearningservices.models.ClassificationModels]
    :ivar blocked_training_algorithms: Blocked models for classification task.
    :vartype blocked_training_algorithms: list[str or
     ~azure.mgmt.machinelearningservices.models.ClassificationModels]
    """

    allowed_training_algorithms: Optional[list[Union[str, "_models.ClassificationModels"]]] = rest_field(
        name="allowedTrainingAlgorithms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allowed models for classification task."""
    blocked_training_algorithms: Optional[list[Union[str, "_models.ClassificationModels"]]] = rest_field(
        name="blockedTrainingAlgorithms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Blocked models for classification task."""

    @overload
    def __init__(
        self,
        *,
        enable_dnn_training: Optional[bool] = None,
        enable_model_explainability: Optional[bool] = None,
        enable_onnx_compatible_models: Optional[bool] = None,
        enable_stack_ensemble: Optional[bool] = None,
        enable_vote_ensemble: Optional[bool] = None,
        ensemble_model_download_timeout: Optional[datetime.timedelta] = None,
        stack_ensemble_settings: Optional["_models.StackEnsembleSettings"] = None,
        allowed_training_algorithms: Optional[list[Union[str, "_models.ClassificationModels"]]] = None,
        blocked_training_algorithms: Optional[list[Union[str, "_models.ClassificationModels"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ClusterUpdateParameters(_Model):
    """AmlCompute update parameters.

    :ivar properties: The properties of the amlCompute.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ClusterUpdateProperties
    """

    properties: Optional["_models.ClusterUpdateProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the amlCompute."""

    __flattened_items = ["properties"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ClusterUpdateProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ClusterUpdateProperties(_Model):
    """The properties of a amlCompute that need to be updated.

    :ivar properties: Properties of ClusterUpdate.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ScaleSettingsInformation
    """

    properties: Optional["_models.ScaleSettingsInformation"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of ClusterUpdate."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ScaleSettingsInformation"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeConfiguration(_Model):
    """Configuration for a scoring code asset.

    :ivar code_id: ARM resource ID of the code asset.
    :vartype code_id: str
    :ivar scoring_script: [Required] The script to execute on startup. eg. "score.py". Required.
    :vartype scoring_script: str
    """

    code_id: Optional[str] = rest_field(name="codeId", visibility=["read", "create"])
    """ARM resource ID of the code asset."""
    scoring_script: str = rest_field(name="scoringScript", visibility=["read", "create"])
    """[Required] The script to execute on startup. eg. \"score.py\". Required."""

    @overload
    def __init__(
        self,
        *,
        scoring_script: str,
        code_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.CodeContainerProperties
    """

    properties: "_models.CodeContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.CodeContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeContainerProperties(AssetContainer):
    """Container for code asset versions.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the code container. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the code container. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeVersion(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.CodeVersionProperties
    """

    properties: "_models.CodeVersionProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.CodeVersionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CodeVersionProperties(AssetBase):
    """Code asset version details.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar code_uri: Uri where code is located.
    :vartype code_uri: str
    :ivar provisioning_state: Provisioning state for the code version. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    code_uri: Optional[str] = rest_field(name="codeUri", visibility=["read", "create", "update", "delete", "query"])
    """Uri where code is located."""
    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the code version. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        code_uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CognitiveServicesSku(_Model):
    """CognitiveServicesSku.

    :ivar capacity:
    :vartype capacity: int
    :ivar family:
    :vartype family: str
    :ivar name:
    :vartype name: str
    :ivar size:
    :vartype size: str
    :ivar tier:
    :vartype tier: str
    """

    capacity: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    family: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    size: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    tier: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        capacity: Optional[int] = None,
        family: Optional[str] = None,
        name: Optional[str] = None,
        size: Optional[str] = None,
        tier: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Collection(_Model):
    """Collection.

    :ivar client_id: The msi client id used to collect logging to blob storage. If it's
     null,backend will pick a registered endpoint identity to auth.
    :vartype client_id: str
    :ivar data_collection_mode: Enable or disable data collection. Known values are: "Enabled" and
     "Disabled".
    :vartype data_collection_mode: str or
     ~azure.mgmt.machinelearningservices.models.DataCollectionMode
    :ivar data_id: The data asset arm resource id. Client side will ensure data asset is pointing
     to the blob storage, and backend will collect data to the blob storage.
    :vartype data_id: str
    :ivar sampling_rate: The sampling rate for collection. Sampling rate 1.0 means we collect 100%
     of data by default.
    :vartype sampling_rate: float
    """

    client_id: Optional[str] = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    """The msi client id used to collect logging to blob storage. If it's null,backend will pick a
     registered endpoint identity to auth."""
    data_collection_mode: Optional[Union[str, "_models.DataCollectionMode"]] = rest_field(
        name="dataCollectionMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable or disable data collection. Known values are: \"Enabled\" and \"Disabled\"."""
    data_id: Optional[str] = rest_field(name="dataId", visibility=["read", "create", "update", "delete", "query"])
    """The data asset arm resource id. Client side will ensure data asset is pointing to the blob
     storage, and backend will collect data to the blob storage."""
    sampling_rate: Optional[float] = rest_field(
        name="samplingRate", visibility=["read", "create", "update", "delete", "query"]
    )
    """The sampling rate for collection. Sampling rate 1.0 means we collect 100% of data by default."""

    @overload
    def __init__(
        self,
        *,
        client_id: Optional[str] = None,
        data_collection_mode: Optional[Union[str, "_models.DataCollectionMode"]] = None,
        data_id: Optional[str] = None,
        sampling_rate: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ColumnTransformer(_Model):
    """Column transformer parameters.

    :ivar fields: Fields to apply transformer logic on.
    :vartype fields: list[str]
    :ivar parameters: Different properties to be passed to transformer.
     Input expected is dictionary of key,value pairs in JSON format.
    :vartype parameters: any
    """

    fields: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Fields to apply transformer logic on."""
    parameters: Optional[Any] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Different properties to be passed to transformer.
     Input expected is dictionary of key,value pairs in JSON format."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional[list[str]] = None,
        parameters: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommandJob(JobBaseProperties, discriminator="Command"):
    """Command job definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar code_id: ARM resource ID of the code asset.
    :vartype code_id: str
    :ivar command: [Required] The command to execute on startup of the job. eg. "python train.py".
     Required.
    :vartype command: str
    :ivar distribution: Distribution configuration of the job. If set, this should be one of Mpi,
     Tensorflow, PyTorch, or null.
    :vartype distribution: ~azure.mgmt.machinelearningservices.models.DistributionConfiguration
    :ivar environment_id: [Required] The ARM resource ID of the Environment specification for the
     job. Required.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables included in the job.
    :vartype environment_variables: dict[str, str]
    :ivar inputs: Mapping of input data bindings used in the job.
    :vartype inputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobInput]
    :ivar limits: Command Job limit.
    :vartype limits: ~azure.mgmt.machinelearningservices.models.CommandJobLimits
    :ivar outputs: Mapping of output data bindings used in the job.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar parameters: Input parameters.
    :vartype parameters: any
    :ivar queue_settings: Queue settings for the job.
    :vartype queue_settings: ~azure.mgmt.machinelearningservices.models.QueueSettings
    :ivar resources: Compute Resource configuration for the job.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.JobResourceConfiguration
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.COMMAND
    """

    code_id: Optional[str] = rest_field(name="codeId", visibility=["read", "create"])
    """ARM resource ID of the code asset."""
    command: str = rest_field(visibility=["read", "create"])
    """[Required] The command to execute on startup of the job. eg. \"python train.py\". Required."""
    distribution: Optional["_models.DistributionConfiguration"] = rest_field(visibility=["read", "create"])
    """Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch,
     or null."""
    environment_id: str = rest_field(name="environmentId", visibility=["read", "create"])
    """[Required] The ARM resource ID of the Environment specification for the job. Required."""
    environment_variables: Optional[dict[str, str]] = rest_field(
        name="environmentVariables", visibility=["read", "create"]
    )
    """Environment variables included in the job."""
    inputs: Optional[dict[str, "_models.JobInput"]] = rest_field(visibility=["read", "create"])
    """Mapping of input data bindings used in the job."""
    limits: Optional["_models.CommandJobLimits"] = rest_field(visibility=["read", "create"])
    """Command Job limit."""
    outputs: Optional[dict[str, "_models.JobOutput"]] = rest_field(visibility=["read", "create"])
    """Mapping of output data bindings used in the job."""
    parameters: Optional[Any] = rest_field(visibility=["read"])
    """Input parameters."""
    queue_settings: Optional["_models.QueueSettings"] = rest_field(name="queueSettings", visibility=["read", "create"])
    """Queue settings for the job."""
    resources: Optional["_models.JobResourceConfiguration"] = rest_field(visibility=["read", "create"])
    """Compute Resource configuration for the job."""
    job_type: Literal[JobType.COMMAND] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        command: str,
        environment_id: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        code_id: Optional[str] = None,
        distribution: Optional["_models.DistributionConfiguration"] = None,
        environment_variables: Optional[dict[str, str]] = None,
        inputs: Optional[dict[str, "_models.JobInput"]] = None,
        limits: Optional["_models.CommandJobLimits"] = None,
        outputs: Optional[dict[str, "_models.JobOutput"]] = None,
        queue_settings: Optional["_models.QueueSettings"] = None,
        resources: Optional["_models.JobResourceConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.COMMAND  # type: ignore


class JobLimits(_Model):
    """JobLimits.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CommandJobLimits, SweepJobLimits

    :ivar job_limits_type: [Required] JobLimit type. Required. Known values are: "Command" and
     "Sweep".
    :vartype job_limits_type: str or ~azure.mgmt.machinelearningservices.models.JobLimitsType
    :ivar timeout: The max run duration in ISO 8601 format, after which the job will be cancelled.
     Only supports duration with precision as low as Seconds.
    :vartype timeout: ~datetime.timedelta
    """

    __mapping__: dict[str, _Model] = {}
    job_limits_type: str = rest_discriminator(
        name="jobLimitsType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] JobLimit type. Required. Known values are: \"Command\" and \"Sweep\"."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports
     duration with precision as low as Seconds."""

    @overload
    def __init__(
        self,
        *,
        job_limits_type: str,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommandJobLimits(JobLimits, discriminator="Command"):
    """Command Job limit class.

    :ivar timeout: The max run duration in ISO 8601 format, after which the job will be cancelled.
     Only supports duration with precision as low as Seconds.
    :vartype timeout: ~datetime.timedelta
    :ivar job_limits_type: [Required] JobLimit type. Required.
    :vartype job_limits_type: str or ~azure.mgmt.machinelearningservices.models.COMMAND
    """

    job_limits_type: Literal[JobLimitsType.COMMAND] = rest_discriminator(name="jobLimitsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] JobLimit type. Required."""

    @overload
    def __init__(
        self,
        *,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_limits_type = JobLimitsType.COMMAND  # type: ignore


class ComponentContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ComponentContainerProperties
    """

    properties: "_models.ComponentContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.ComponentContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComponentContainerProperties(AssetContainer):
    """Component container definition.
    <see
    href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command"
    />.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the component container. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the component container. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComponentVersion(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ComponentVersionProperties
    """

    properties: "_models.ComponentVersionProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.ComponentVersionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComponentVersionProperties(AssetBase):
    """Definition of a component version: defines resources that span component types.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar component_spec: Defines Component definition details.
     <see
     href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command"
     />.
    :vartype component_spec: any
    :ivar provisioning_state: Provisioning state for the component version. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    component_spec: Optional[Any] = rest_field(name="componentSpec", visibility=["read", "create"])
    """Defines Component definition details.
     <see
     href=\"https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command\"
     />."""
    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the component version. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        component_spec: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstance(Compute, discriminator="ComputeInstance"):
    """An Azure Machine Learning compute instance.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties: Properties of ComputeInstance.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ComputeInstanceProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.COMPUTE_INSTANCE
    """

    properties: Optional["_models.ComputeInstanceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of ComputeInstance."""
    compute_type: Literal[ComputeType.COMPUTE_INSTANCE] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.ComputeInstanceProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.COMPUTE_INSTANCE  # type: ignore


class ComputeInstanceApplication(_Model):
    """Defines an Aml Instance application and its connectivity endpoint URI.

    :ivar display_name: Name of the ComputeInstance application.
    :vartype display_name: str
    :ivar endpoint_uri: Application' endpoint URI.
    :vartype endpoint_uri: str
    """

    display_name: Optional[str] = rest_field(
        name="displayName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the ComputeInstance application."""
    endpoint_uri: Optional[str] = rest_field(
        name="endpointUri", visibility=["read", "create", "update", "delete", "query"]
    )
    """Application' endpoint URI."""

    @overload
    def __init__(
        self,
        *,
        display_name: Optional[str] = None,
        endpoint_uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceAutologgerSettings(_Model):
    """Specifies settings for autologger.

    :ivar mlflow_autologger: Indicates whether mlflow autologger is enabled for notebooks. Known
     values are: "Enabled" and "Disabled".
    :vartype mlflow_autologger: str or ~azure.mgmt.machinelearningservices.models.MlflowAutologger
    """

    mlflow_autologger: Optional[Union[str, "_models.MlflowAutologger"]] = rest_field(
        name="mlflowAutologger", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether mlflow autologger is enabled for notebooks. Known values are: \"Enabled\" and
     \"Disabled\"."""

    @overload
    def __init__(
        self,
        *,
        mlflow_autologger: Optional[Union[str, "_models.MlflowAutologger"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceConnectivityEndpoints(_Model):
    """Defines all connectivity endpoints and properties for an ComputeInstance.

    :ivar public_ip_address: Public IP Address of this ComputeInstance.
    :vartype public_ip_address: str
    :ivar private_ip_address: Private IP Address of this ComputeInstance (local to the VNET in
     which the compute instance is deployed).
    :vartype private_ip_address: str
    """

    public_ip_address: Optional[str] = rest_field(name="publicIpAddress", visibility=["read"])
    """Public IP Address of this ComputeInstance."""
    private_ip_address: Optional[str] = rest_field(name="privateIpAddress", visibility=["read"])
    """Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is
     deployed)."""


class ComputeInstanceContainer(_Model):
    """Defines an Aml Instance container.

    :ivar name: Name of the ComputeInstance container.
    :vartype name: str
    :ivar autosave: Auto save settings. Known values are: "None", "Local", and "Remote".
    :vartype autosave: str or ~azure.mgmt.machinelearningservices.models.Autosave
    :ivar gpu: Information of GPU.
    :vartype gpu: str
    :ivar network: network of this container. Known values are: "Bridge" and "Host".
    :vartype network: str or ~azure.mgmt.machinelearningservices.models.Network
    :ivar environment: Environment information of this container.
    :vartype environment: ~azure.mgmt.machinelearningservices.models.ComputeInstanceEnvironmentInfo
    :ivar services: services of this containers.
    :vartype services: list[dict[str, any]]
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of the ComputeInstance container."""
    autosave: Optional[Union[str, "_models.Autosave"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Auto save settings. Known values are: \"None\", \"Local\", and \"Remote\"."""
    gpu: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Information of GPU."""
    network: Optional[Union[str, "_models.Network"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """network of this container. Known values are: \"Bridge\" and \"Host\"."""
    environment: Optional["_models.ComputeInstanceEnvironmentInfo"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Environment information of this container."""
    services: Optional[list[dict[str, Any]]] = rest_field(visibility=["read"])
    """services of this containers."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        autosave: Optional[Union[str, "_models.Autosave"]] = None,
        gpu: Optional[str] = None,
        network: Optional[Union[str, "_models.Network"]] = None,
        environment: Optional["_models.ComputeInstanceEnvironmentInfo"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceCreatedBy(_Model):
    """Describes information on user who created this ComputeInstance.

    :ivar user_name: Name of the user.
    :vartype user_name: str
    :ivar user_org_id: Uniquely identifies user' Azure Active Directory organization.
    :vartype user_org_id: str
    :ivar user_id: Uniquely identifies the user within his/her organization.
    :vartype user_id: str
    """

    user_name: Optional[str] = rest_field(name="userName", visibility=["read"])
    """Name of the user."""
    user_org_id: Optional[str] = rest_field(name="userOrgId", visibility=["read"])
    """Uniquely identifies user' Azure Active Directory organization."""
    user_id: Optional[str] = rest_field(name="userId", visibility=["read"])
    """Uniquely identifies the user within his/her organization."""


class ComputeInstanceDataDisk(_Model):
    """Defines an Aml Instance DataDisk.

    :ivar caching: Caching type of Data Disk. Known values are: "None", "ReadOnly", and
     "ReadWrite".
    :vartype caching: str or ~azure.mgmt.machinelearningservices.models.Caching
    :ivar disk_size_gb: The initial disk size in gigabytes.
    :vartype disk_size_gb: int
    :ivar lun: The logical unit number.
    :vartype lun: int
    :ivar storage_account_type: type of this storage account. Known values are: "Standard_LRS" and
     "Premium_LRS".
    :vartype storage_account_type: str or
     ~azure.mgmt.machinelearningservices.models.StorageAccountType
    """

    caching: Optional[Union[str, "_models.Caching"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Caching type of Data Disk. Known values are: \"None\", \"ReadOnly\", and \"ReadWrite\"."""
    disk_size_gb: Optional[int] = rest_field(
        name="diskSizeGB", visibility=["read", "create", "update", "delete", "query"]
    )
    """The initial disk size in gigabytes."""
    lun: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The logical unit number."""
    storage_account_type: Optional[Union[str, "_models.StorageAccountType"]] = rest_field(
        name="storageAccountType", visibility=["read", "create", "update", "delete", "query"]
    )
    """type of this storage account. Known values are: \"Standard_LRS\" and \"Premium_LRS\"."""

    @overload
    def __init__(
        self,
        *,
        caching: Optional[Union[str, "_models.Caching"]] = None,
        disk_size_gb: Optional[int] = None,
        lun: Optional[int] = None,
        storage_account_type: Optional[Union[str, "_models.StorageAccountType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceDataMount(_Model):
    """Defines an Aml Instance DataMount.

    :ivar source: Source of the ComputeInstance data mount.
    :vartype source: str
    :ivar source_type: Data source type. Known values are: "Dataset", "Datastore", and "URI".
    :vartype source_type: str or ~azure.mgmt.machinelearningservices.models.SourceType
    :ivar mount_name: name of the ComputeInstance data mount.
    :vartype mount_name: str
    :ivar mount_action: Mount Action. Known values are: "Mount" and "Unmount".
    :vartype mount_action: str or ~azure.mgmt.machinelearningservices.models.MountAction
    :ivar mount_mode: Mount Mode. Known values are: "ReadOnly" and "ReadWrite".
    :vartype mount_mode: str or ~azure.mgmt.machinelearningservices.models.MountMode
    :ivar created_by: who this data mount created by.
    :vartype created_by: str
    :ivar mount_path: Path of this data mount.
    :vartype mount_path: str
    :ivar mount_state: Mount state. Known values are: "MountRequested", "Mounted", "MountFailed",
     "UnmountRequested", "UnmountFailed", and "Unmounted".
    :vartype mount_state: str or ~azure.mgmt.machinelearningservices.models.MountState
    :ivar mounted_on: Mounted time.
    :vartype mounted_on: ~datetime.datetime
    :ivar error: Error of this data mount.
    :vartype error: str
    """

    source: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Source of the ComputeInstance data mount."""
    source_type: Optional[Union[str, "_models.SourceType"]] = rest_field(
        name="sourceType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Data source type. Known values are: \"Dataset\", \"Datastore\", and \"URI\"."""
    mount_name: Optional[str] = rest_field(name="mountName", visibility=["read", "create", "update", "delete", "query"])
    """name of the ComputeInstance data mount."""
    mount_action: Optional[Union[str, "_models.MountAction"]] = rest_field(
        name="mountAction", visibility=["read", "create", "update", "delete", "query"]
    )
    """Mount Action. Known values are: \"Mount\" and \"Unmount\"."""
    mount_mode: Optional[Union[str, "_models.MountMode"]] = rest_field(
        name="mountMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Mount Mode. Known values are: \"ReadOnly\" and \"ReadWrite\"."""
    created_by: Optional[str] = rest_field(name="createdBy", visibility=["read", "create", "update", "delete", "query"])
    """who this data mount created by."""
    mount_path: Optional[str] = rest_field(name="mountPath", visibility=["read", "create", "update", "delete", "query"])
    """Path of this data mount."""
    mount_state: Optional[Union[str, "_models.MountState"]] = rest_field(
        name="mountState", visibility=["read", "create", "update", "delete", "query"]
    )
    """Mount state. Known values are: \"MountRequested\", \"Mounted\", \"MountFailed\",
     \"UnmountRequested\", \"UnmountFailed\", and \"Unmounted\"."""
    mounted_on: Optional[datetime.datetime] = rest_field(
        name="mountedOn", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Mounted time."""
    error: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Error of this data mount."""

    @overload
    def __init__(
        self,
        *,
        source: Optional[str] = None,
        source_type: Optional[Union[str, "_models.SourceType"]] = None,
        mount_name: Optional[str] = None,
        mount_action: Optional[Union[str, "_models.MountAction"]] = None,
        mount_mode: Optional[Union[str, "_models.MountMode"]] = None,
        created_by: Optional[str] = None,
        mount_path: Optional[str] = None,
        mount_state: Optional[Union[str, "_models.MountState"]] = None,
        mounted_on: Optional[datetime.datetime] = None,
        error: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceEnvironmentInfo(_Model):
    """Environment information.

    :ivar name: name of environment.
    :vartype name: str
    :ivar version: version of environment.
    :vartype version: str
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """name of environment."""
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """version of environment."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceLastOperation(_Model):
    """The last operation on ComputeInstance.

    :ivar operation_name: Name of the last operation. Known values are: "Create", "Start", "Stop",
     "Restart", "Resize", "Reimage", and "Delete".
    :vartype operation_name: str or ~azure.mgmt.machinelearningservices.models.OperationName
    :ivar operation_time: Time of the last operation.
    :vartype operation_time: ~datetime.datetime
    :ivar operation_status: Operation status. Known values are: "InProgress", "Succeeded",
     "CreateFailed", "StartFailed", "StopFailed", "RestartFailed", "ResizeFailed", "ReimageFailed",
     and "DeleteFailed".
    :vartype operation_status: str or ~azure.mgmt.machinelearningservices.models.OperationStatus
    :ivar operation_trigger: Trigger of operation. Known values are: "User", "Schedule", and
     "IdleShutdown".
    :vartype operation_trigger: str or ~azure.mgmt.machinelearningservices.models.OperationTrigger
    """

    operation_name: Optional[Union[str, "_models.OperationName"]] = rest_field(
        name="operationName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the last operation. Known values are: \"Create\", \"Start\", \"Stop\", \"Restart\",
     \"Resize\", \"Reimage\", and \"Delete\"."""
    operation_time: Optional[datetime.datetime] = rest_field(
        name="operationTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Time of the last operation."""
    operation_status: Optional[Union[str, "_models.OperationStatus"]] = rest_field(
        name="operationStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """Operation status. Known values are: \"InProgress\", \"Succeeded\", \"CreateFailed\",
     \"StartFailed\", \"StopFailed\", \"RestartFailed\", \"ResizeFailed\", \"ReimageFailed\", and
     \"DeleteFailed\"."""
    operation_trigger: Optional[Union[str, "_models.OperationTrigger"]] = rest_field(
        name="operationTrigger", visibility=["read", "create", "update", "delete", "query"]
    )
    """Trigger of operation. Known values are: \"User\", \"Schedule\", and \"IdleShutdown\"."""

    @overload
    def __init__(
        self,
        *,
        operation_name: Optional[Union[str, "_models.OperationName"]] = None,
        operation_time: Optional[datetime.datetime] = None,
        operation_status: Optional[Union[str, "_models.OperationStatus"]] = None,
        operation_trigger: Optional[Union[str, "_models.OperationTrigger"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceProperties(_Model):
    """Compute Instance properties.

    :ivar vm_size: Virtual Machine Size.
    :vartype vm_size: str
    :ivar subnet: Subnet.
    :vartype subnet: ~azure.mgmt.machinelearningservices.models.ResourceId
    :ivar application_sharing_policy: Sharing policy for applications on this compute instance.
     Known values are: "Personal" and "Shared".
    :vartype application_sharing_policy: str or
     ~azure.mgmt.machinelearningservices.models.ApplicationSharingPolicy
    :ivar autologger_settings: Specifies settings for autologger.
    :vartype autologger_settings:
     ~azure.mgmt.machinelearningservices.models.ComputeInstanceAutologgerSettings
    :ivar ssh_settings: Specifies policy and settings for SSH access.
    :vartype ssh_settings: ~azure.mgmt.machinelearningservices.models.ComputeInstanceSshSettings
    :ivar custom_services: List of Custom Services added to the compute.
    :vartype custom_services: list[~azure.mgmt.machinelearningservices.models.CustomService]
    :ivar os_image_metadata: Returns metadata about the operating system image for this compute
     instance.
    :vartype os_image_metadata: ~azure.mgmt.machinelearningservices.models.ImageMetadata
    :ivar connectivity_endpoints: Describes all connectivity endpoints available for this
     ComputeInstance.
    :vartype connectivity_endpoints:
     ~azure.mgmt.machinelearningservices.models.ComputeInstanceConnectivityEndpoints
    :ivar applications: Describes available applications and their endpoints on this
     ComputeInstance.
    :vartype applications:
     list[~azure.mgmt.machinelearningservices.models.ComputeInstanceApplication]
    :ivar created_by: Describes information on user who created this ComputeInstance.
    :vartype created_by: ~azure.mgmt.machinelearningservices.models.ComputeInstanceCreatedBy
    :ivar errors: Errors.
    :vartype errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar state: The current state of this ComputeInstance. Known values are: "Creating",
     "CreateFailed", "Deleting", "Running", "Restarting", "Resizing", "JobRunning", "SettingUp",
     "SetupFailed", "Starting", "Stopped", "Stopping", "UserSettingUp", "UserSetupFailed",
     "Unknown", and "Unusable".
    :vartype state: str or ~azure.mgmt.machinelearningservices.models.ComputeInstanceState
    :ivar compute_instance_authorization_type: Compute Instance Authorization type. "personal"
    :vartype compute_instance_authorization_type: str or
     ~azure.mgmt.machinelearningservices.models.ComputeInstancePropertiesComputeInstanceAuthorizationType
    :ivar enable_os_patching: Enable Auto OS Patching.
    :vartype enable_os_patching: bool
    :ivar enable_root_access: Enable root access.
    :vartype enable_root_access: bool
    :ivar enable_sso: Enable SSO (single sign on).
    :vartype enable_sso: bool
    :ivar release_quota_on_stop: Release quota if compute instance stopped.
    :vartype release_quota_on_stop: bool
    :ivar personal_compute_instance_settings: Personal Compute Instance settings.
    :vartype personal_compute_instance_settings:
     ~azure.mgmt.machinelearningservices.models.PersonalComputeInstanceSettings
    :ivar setup_scripts: Details of customized scripts to execute for setting up the cluster.
    :vartype setup_scripts: ~azure.mgmt.machinelearningservices.models.SetupScripts
    :ivar last_operation: The last operation on ComputeInstance.
    :vartype last_operation:
     ~azure.mgmt.machinelearningservices.models.ComputeInstanceLastOperation
    :ivar schedules: The list of schedules to be applied on the computes.
    :vartype schedules: ~azure.mgmt.machinelearningservices.models.ComputeSchedules
    :ivar idle_time_before_shutdown: Stops compute instance after user defined period of
     inactivity. Time is defined in ISO8601 format. Minimum is 15 min, maximum is 3 days.
    :vartype idle_time_before_shutdown: str
    :ivar enable_node_public_ip: Enable node public IP.
    :vartype enable_node_public_ip: bool
    :ivar containers: Describes informations of containers on this ComputeInstance.
    :vartype containers: list[~azure.mgmt.machinelearningservices.models.ComputeInstanceContainer]
    :ivar data_disks: Describes informations of dataDisks on this ComputeInstance.
    :vartype data_disks: list[~azure.mgmt.machinelearningservices.models.ComputeInstanceDataDisk]
    :ivar data_mounts: Describes informations of dataMounts on this ComputeInstance.
    :vartype data_mounts: list[~azure.mgmt.machinelearningservices.models.ComputeInstanceDataMount]
    :ivar versions: ComputeInstance version.
    :vartype versions: ~azure.mgmt.machinelearningservices.models.ComputeInstanceVersion
    """

    vm_size: Optional[str] = rest_field(name="vmSize", visibility=["read", "create", "update", "delete", "query"])
    """Virtual Machine Size."""
    subnet: Optional["_models.ResourceId"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Subnet."""
    application_sharing_policy: Optional[Union[str, "_models.ApplicationSharingPolicy"]] = rest_field(
        name="applicationSharingPolicy", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sharing policy for applications on this compute instance. Known values are: \"Personal\" and
     \"Shared\"."""
    autologger_settings: Optional["_models.ComputeInstanceAutologgerSettings"] = rest_field(
        name="autologgerSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies settings for autologger."""
    ssh_settings: Optional["_models.ComputeInstanceSshSettings"] = rest_field(
        name="sshSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies policy and settings for SSH access."""
    custom_services: Optional[list["_models.CustomService"]] = rest_field(
        name="customServices", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of Custom Services added to the compute."""
    os_image_metadata: Optional["_models.ImageMetadata"] = rest_field(name="osImageMetadata", visibility=["read"])
    """Returns metadata about the operating system image for this compute instance."""
    connectivity_endpoints: Optional["_models.ComputeInstanceConnectivityEndpoints"] = rest_field(
        name="connectivityEndpoints", visibility=["read"]
    )
    """Describes all connectivity endpoints available for this ComputeInstance."""
    applications: Optional[list["_models.ComputeInstanceApplication"]] = rest_field(visibility=["read"])
    """Describes available applications and their endpoints on this ComputeInstance."""
    created_by: Optional["_models.ComputeInstanceCreatedBy"] = rest_field(name="createdBy", visibility=["read"])
    """Describes information on user who created this ComputeInstance."""
    errors: Optional[list["_models.ErrorResponse"]] = rest_field(visibility=["read"])
    """Errors."""
    state: Optional[Union[str, "_models.ComputeInstanceState"]] = rest_field(visibility=["read"])
    """The current state of this ComputeInstance. Known values are: \"Creating\", \"CreateFailed\",
     \"Deleting\", \"Running\", \"Restarting\", \"Resizing\", \"JobRunning\", \"SettingUp\",
     \"SetupFailed\", \"Starting\", \"Stopped\", \"Stopping\", \"UserSettingUp\",
     \"UserSetupFailed\", \"Unknown\", and \"Unusable\"."""
    compute_instance_authorization_type: Optional[
        Union[str, "_models.ComputeInstancePropertiesComputeInstanceAuthorizationType"]
    ] = rest_field(name="computeInstanceAuthorizationType", visibility=["read", "create", "update", "delete", "query"])
    """Compute Instance Authorization type. \"personal\""""
    enable_os_patching: Optional[bool] = rest_field(
        name="enableOSPatching", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable Auto OS Patching."""
    enable_root_access: Optional[bool] = rest_field(
        name="enableRootAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable root access."""
    enable_sso: Optional[bool] = rest_field(
        name="enableSSO", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable SSO (single sign on)."""
    release_quota_on_stop: Optional[bool] = rest_field(
        name="releaseQuotaOnStop", visibility=["read", "create", "update", "delete", "query"]
    )
    """Release quota if compute instance stopped."""
    personal_compute_instance_settings: Optional["_models.PersonalComputeInstanceSettings"] = rest_field(
        name="personalComputeInstanceSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Personal Compute Instance settings."""
    setup_scripts: Optional["_models.SetupScripts"] = rest_field(
        name="setupScripts", visibility=["read", "create", "update", "delete", "query"]
    )
    """Details of customized scripts to execute for setting up the cluster."""
    last_operation: Optional["_models.ComputeInstanceLastOperation"] = rest_field(
        name="lastOperation", visibility=["read"]
    )
    """The last operation on ComputeInstance."""
    schedules: Optional["_models.ComputeSchedules"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of schedules to be applied on the computes."""
    idle_time_before_shutdown: Optional[str] = rest_field(
        name="idleTimeBeforeShutdown", visibility=["read", "create", "update", "delete", "query"]
    )
    """Stops compute instance after user defined period of inactivity. Time is defined in ISO8601
     format. Minimum is 15 min, maximum is 3 days."""
    enable_node_public_ip: Optional[bool] = rest_field(
        name="enableNodePublicIp", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable node public IP."""
    containers: Optional[list["_models.ComputeInstanceContainer"]] = rest_field(visibility=["read"])
    """Describes informations of containers on this ComputeInstance."""
    data_disks: Optional[list["_models.ComputeInstanceDataDisk"]] = rest_field(name="dataDisks", visibility=["read"])
    """Describes informations of dataDisks on this ComputeInstance."""
    data_mounts: Optional[list["_models.ComputeInstanceDataMount"]] = rest_field(name="dataMounts", visibility=["read"])
    """Describes informations of dataMounts on this ComputeInstance."""
    versions: Optional["_models.ComputeInstanceVersion"] = rest_field(visibility=["read"])
    """ComputeInstance version."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        vm_size: Optional[str] = None,
        subnet: Optional["_models.ResourceId"] = None,
        application_sharing_policy: Optional[Union[str, "_models.ApplicationSharingPolicy"]] = None,
        autologger_settings: Optional["_models.ComputeInstanceAutologgerSettings"] = None,
        ssh_settings: Optional["_models.ComputeInstanceSshSettings"] = None,
        custom_services: Optional[list["_models.CustomService"]] = None,
        compute_instance_authorization_type: Optional[
            Union[str, "_models.ComputeInstancePropertiesComputeInstanceAuthorizationType"]
        ] = None,
        enable_os_patching: Optional[bool] = None,
        enable_root_access: Optional[bool] = None,
        enable_sso: Optional[bool] = None,
        release_quota_on_stop: Optional[bool] = None,
        personal_compute_instance_settings: Optional["_models.PersonalComputeInstanceSettings"] = None,
        setup_scripts: Optional["_models.SetupScripts"] = None,
        schedules: Optional["_models.ComputeSchedules"] = None,
        idle_time_before_shutdown: Optional[str] = None,
        enable_node_public_ip: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceSshSettings(_Model):
    """Specifies policy and settings for SSH access.

    :ivar ssh_public_access: Access policy for SSH. Known values are: "Enabled" and "Disabled".
    :vartype ssh_public_access: str or ~azure.mgmt.machinelearningservices.models.SshPublicAccess
    :ivar admin_user_name: Describes the admin user name.
    :vartype admin_user_name: str
    :ivar ssh_port: Describes the port for connecting through SSH.
    :vartype ssh_port: int
    :ivar admin_public_key: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t
     rsa -b 2048" to generate your SSH key pairs.
    :vartype admin_public_key: str
    """

    ssh_public_access: Optional[Union[str, "_models.SshPublicAccess"]] = rest_field(
        name="sshPublicAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Access policy for SSH. Known values are: \"Enabled\" and \"Disabled\"."""
    admin_user_name: Optional[str] = rest_field(name="adminUserName", visibility=["read"])
    """Describes the admin user name."""
    ssh_port: Optional[int] = rest_field(name="sshPort", visibility=["read"])
    """Describes the port for connecting through SSH."""
    admin_public_key: Optional[str] = rest_field(
        name="adminPublicKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the SSH rsa public key file as a string. Use \"ssh-keygen -t rsa -b 2048\" to
     generate your SSH key pairs."""

    @overload
    def __init__(
        self,
        *,
        ssh_public_access: Optional[Union[str, "_models.SshPublicAccess"]] = None,
        admin_public_key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeInstanceVersion(_Model):
    """Version of computeInstance.

    :ivar runtime: Runtime of compute instance.
    :vartype runtime: str
    """

    runtime: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Runtime of compute instance."""

    @overload
    def __init__(
        self,
        *,
        runtime: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeRecurrenceSchedule(_Model):
    """ComputeRecurrenceSchedule.

    :ivar hours: [Required] List of hours for the schedule. Required.
    :vartype hours: list[int]
    :ivar minutes: [Required] List of minutes for the schedule. Required.
    :vartype minutes: list[int]
    :ivar month_days: List of month days for the schedule.
    :vartype month_days: list[int]
    :ivar week_days: List of days for the schedule.
    :vartype week_days: list[str or ~azure.mgmt.machinelearningservices.models.ComputeWeekDay]
    """

    hours: list[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] List of hours for the schedule. Required."""
    minutes: list[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] List of minutes for the schedule. Required."""
    month_days: Optional[list[int]] = rest_field(
        name="monthDays", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of month days for the schedule."""
    week_days: Optional[list[Union[str, "_models.ComputeWeekDay"]]] = rest_field(
        name="weekDays", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of days for the schedule."""

    @overload
    def __init__(
        self,
        *,
        hours: list[int],
        minutes: list[int],
        month_days: Optional[list[int]] = None,
        week_days: Optional[list[Union[str, "_models.ComputeWeekDay"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeResource(ProxyResource):
    """Machine Learning compute object wrapped into ARM resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: The resource-specific properties for this resource.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.Compute
    :ivar location: Specifies the location of the resource.
    :vartype location: str
    :ivar tags: Contains resource tags defined as key/value pairs.
    :vartype tags: dict[str, str]
    :ivar sku: The sku of the workspace.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    :ivar identity: The identity of the resource.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    """

    properties: Optional["_models.Compute"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource-specific properties for this resource."""
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the location of the resource."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Contains resource tags defined as key/value pairs."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The sku of the workspace."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity of the resource."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.Compute"] = None,
        location: Optional[str] = None,
        tags: Optional[dict[str, str]] = None,
        sku: Optional["_models.Sku"] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeRuntimeDto(_Model):
    """ComputeRuntimeDto.

    :ivar spark_runtime_version:
    :vartype spark_runtime_version: str
    """

    spark_runtime_version: Optional[str] = rest_field(
        name="sparkRuntimeVersion", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        spark_runtime_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeSchedules(_Model):
    """The list of schedules to be applied on the computes.

    :ivar compute_start_stop: The list of compute start stop schedules to be applied.
    :vartype compute_start_stop:
     list[~azure.mgmt.machinelearningservices.models.ComputeStartStopSchedule]
    """

    compute_start_stop: Optional[list["_models.ComputeStartStopSchedule"]] = rest_field(
        name="computeStartStop", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of compute start stop schedules to be applied."""

    @overload
    def __init__(
        self,
        *,
        compute_start_stop: Optional[list["_models.ComputeStartStopSchedule"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeStartStopSchedule(_Model):
    """Compute start stop schedule properties.

    :ivar id: A system assigned id for the schedule.
    :vartype id: str
    :ivar provisioning_status: The current deployment state of schedule. Known values are:
     "Completed", "Provisioning", and "Failed".
    :vartype provisioning_status: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningStatus
    :ivar status: Is the schedule enabled or disabled?. Known values are: "Enabled" and "Disabled".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.ScheduleStatus
    :ivar action: [Required] The compute power action. Known values are: "Start" and "Stop".
    :vartype action: str or ~azure.mgmt.machinelearningservices.models.ComputePowerAction
    :ivar trigger_type: [Required] The schedule trigger type. Known values are: "Recurrence" and
     "Cron".
    :vartype trigger_type: str or ~azure.mgmt.machinelearningservices.models.ComputeTriggerType
    :ivar recurrence: Required if triggerType is Recurrence.
    :vartype recurrence: ~azure.mgmt.machinelearningservices.models.Recurrence
    :ivar cron: Required if triggerType is Cron.
    :vartype cron: ~azure.mgmt.machinelearningservices.models.Cron
    :ivar schedule: [Deprecated] Not used any more.
    :vartype schedule: ~azure.mgmt.machinelearningservices.models.ScheduleBase
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """A system assigned id for the schedule."""
    provisioning_status: Optional[Union[str, "_models.ProvisioningStatus"]] = rest_field(
        name="provisioningStatus", visibility=["read"]
    )
    """The current deployment state of schedule. Known values are: \"Completed\", \"Provisioning\",
     and \"Failed\"."""
    status: Optional[Union[str, "_models.ScheduleStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Is the schedule enabled or disabled?. Known values are: \"Enabled\" and \"Disabled\"."""
    action: Optional[Union[str, "_models.ComputePowerAction"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The compute power action. Known values are: \"Start\" and \"Stop\"."""
    trigger_type: Optional[Union[str, "_models.ComputeTriggerType"]] = rest_field(
        name="triggerType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The schedule trigger type. Known values are: \"Recurrence\" and \"Cron\"."""
    recurrence: Optional["_models.Recurrence"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Required if triggerType is Recurrence."""
    cron: Optional["_models.Cron"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Required if triggerType is Cron."""
    schedule: Optional["_models.ScheduleBase"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Deprecated] Not used any more."""

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.ScheduleStatus"]] = None,
        action: Optional[Union[str, "_models.ComputePowerAction"]] = None,
        trigger_type: Optional[Union[str, "_models.ComputeTriggerType"]] = None,
        recurrence: Optional["_models.Recurrence"] = None,
        cron: Optional["_models.Cron"] = None,
        schedule: Optional["_models.ScheduleBase"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerResourceRequirements(_Model):
    """Resource requirements for each container instance within an online deployment.

    :ivar container_resource_limits: Container resource limit info:.
    :vartype container_resource_limits:
     ~azure.mgmt.machinelearningservices.models.ContainerResourceSettings
    :ivar container_resource_requests: Container resource request info:.
    :vartype container_resource_requests:
     ~azure.mgmt.machinelearningservices.models.ContainerResourceSettings
    """

    container_resource_limits: Optional["_models.ContainerResourceSettings"] = rest_field(
        name="containerResourceLimits", visibility=["read", "create", "update", "delete", "query"]
    )
    """Container resource limit info:."""
    container_resource_requests: Optional["_models.ContainerResourceSettings"] = rest_field(
        name="containerResourceRequests", visibility=["read", "create", "update", "delete", "query"]
    )
    """Container resource request info:."""

    @overload
    def __init__(
        self,
        *,
        container_resource_limits: Optional["_models.ContainerResourceSettings"] = None,
        container_resource_requests: Optional["_models.ContainerResourceSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContainerResourceSettings(_Model):
    """ContainerResourceSettings.

    :ivar cpu: Number of vCPUs request/limit for container. More info:
     `https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
     <https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>`_.
    :vartype cpu: str
    :ivar gpu: Number of Nvidia GPU cards request/limit for container. More info:
     `https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
     <https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>`_.
    :vartype gpu: str
    :ivar memory: Memory size request/limit for container. More info:
     `https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
     <https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>`_.
    :vartype memory: str
    """

    cpu: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Number of vCPUs request/limit for container. More info:
     `https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
     <https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>`_."""
    gpu: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Number of Nvidia GPU cards request/limit for container. More info:
     `https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
     <https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>`_."""
    memory: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Memory size request/limit for container. More info:
     `https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
     <https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/>`_."""

    @overload
    def __init__(
        self,
        *,
        cpu: Optional[str] = None,
        gpu: Optional[str] = None,
        memory: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContentSafety(_Model):
    """ContentSafety.

    :ivar content_safety_level: Specifies the current safety level for content safety. Known values
     are: "Blocking" and "Deferred".
    :vartype content_safety_level: str or
     ~azure.mgmt.machinelearningservices.models.ContentSafetyLevel
    :ivar content_safety_status: [Required] Specifies the status of content safety. Required. Known
     values are: "Enabled" and "Disabled".
    :vartype content_safety_status: str or
     ~azure.mgmt.machinelearningservices.models.ContentSafetyStatus
    """

    content_safety_level: Optional[Union[str, "_models.ContentSafetyLevel"]] = rest_field(
        name="contentSafetyLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the current safety level for content safety. Known values are: \"Blocking\" and
     \"Deferred\"."""
    content_safety_status: Union[str, "_models.ContentSafetyStatus"] = rest_field(
        name="contentSafetyStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Specifies the status of content safety. Required. Known values are: \"Enabled\" and
     \"Disabled\"."""

    @overload
    def __init__(
        self,
        *,
        content_safety_status: Union[str, "_models.ContentSafetyStatus"],
        content_safety_level: Optional[Union[str, "_models.ContentSafetyLevel"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointDeploymentResourceProperties(_Model):
    """EndpointDeploymentResourceProperties.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    ContentSafetyEndpointDeploymentResourceProperties, OpenAIEndpointDeploymentResourceProperties,
    SpeechEndpointDeploymentResourceProperties, ManagedOnlineEndpointDeploymentResourceProperties

    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar type: Kind of the deployment. Required. Default value is None.
    :vartype type: str
    """

    __mapping__: dict[str, _Model] = {}
    failure_reason: Optional[str] = rest_field(
        name="failureReason", visibility=["read", "create", "update", "delete", "query"]
    )
    """The failure reason if the creation failed."""
    provisioning_state: Optional[Union[str, "_models.DefaultResourceProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Read-only provision state status property. Known values are: \"NotStarted\", \"Failed\",
     \"Creating\", \"Updating\", \"Succeeded\", \"Deleting\", \"Accepted\", \"Canceled\",
     \"Scaling\", and \"Disabled\"."""
    type: str = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])
    """Kind of the deployment. Required. Default value is None."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        failure_reason: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContentSafetyEndpointDeploymentResourceProperties(
    EndpointDeploymentResourceProperties, discriminator="Azure.ContentSafety"
):  # pylint: disable=name-too-long
    """ContentSafetyEndpointDeploymentResourceProperties.

    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar model: Model used for the endpoint deployment. Required.
    :vartype model: ~azure.mgmt.machinelearningservices.models.EndpointDeploymentModel
    :ivar rai_policy_name: The name of RAI policy.
    :vartype rai_policy_name: str
    :ivar sku:
    :vartype sku: ~azure.mgmt.machinelearningservices.models.CognitiveServicesSku
    :ivar version_upgrade_option: Deployment model version upgrade option. Known values are:
     "OnceNewDefaultVersionAvailable", "OnceCurrentVersionExpired", and "NoAutoUpgrade".
    :vartype version_upgrade_option: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentModelVersionUpgradeOption
    :ivar type: Kind of the deployment. Required. Default value is "Azure.ContentSafety".
    :vartype type: str
    """

    model: "_models.EndpointDeploymentModel" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model used for the endpoint deployment. Required."""
    rai_policy_name: Optional[str] = rest_field(
        name="raiPolicyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of RAI policy."""
    sku: Optional["_models.CognitiveServicesSku"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    version_upgrade_option: Optional[Union[str, "_models.DeploymentModelVersionUpgradeOption"]] = rest_field(
        name="versionUpgradeOption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Deployment model version upgrade option. Known values are: \"OnceNewDefaultVersionAvailable\",
     \"OnceCurrentVersionExpired\", and \"NoAutoUpgrade\"."""
    type: Literal["Azure.ContentSafety"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Kind of the deployment. Required. Default value is \"Azure.ContentSafety\"."""

    @overload
    def __init__(
        self,
        *,
        model: "_models.EndpointDeploymentModel",
        failure_reason: Optional[str] = None,
        rai_policy_name: Optional[str] = None,
        sku: Optional["_models.CognitiveServicesSku"] = None,
        version_upgrade_option: Optional[Union[str, "_models.DeploymentModelVersionUpgradeOption"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = "Azure.ContentSafety"  # type: ignore


class EndpointResourceProperties(_Model):
    """EndpointResourceProperties.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    ContentSafetyEndpointResourceProperties, OpenAIEndpointResourceProperties,
    SpeechEndpointResourceProperties, ManagedOnlineEndpointResourceProperties,
    ServerlessEndpointResourceProperties

    :ivar associated_resource_id: Byo resource id for creating the built-in model service
     endpoints.
    :vartype associated_resource_id: str
    :ivar deployments: Deployments info.
    :vartype deployments:
     list[~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourcePropertiesBasicResource]
    :ivar endpoint_type: Type of the endpoint. Required. Known values are: "Azure.OpenAI",
     "Azure.Speech", "Azure.ContentSafety", "Azure.Llama", "managedOnlineEndpoint", and
     "serverlessEndpoint".
    :vartype endpoint_type: str or ~azure.mgmt.machinelearningservices.models.EndpointType
    :ivar endpoint_uri: Uri of the endpoint.
    :vartype endpoint_uri: str
    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar location: Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace.
    :vartype location: str
    :ivar name: Name of the endpoint.
    :vartype name: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar should_create_ai_services_endpoint: Whether the proxy (non-byo) endpoint is a regular
     endpoint or a OneKeyV2 AI services account endpoint.
    :vartype should_create_ai_services_endpoint: bool
    """

    __mapping__: dict[str, _Model] = {}
    associated_resource_id: Optional[str] = rest_field(
        name="associatedResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Byo resource id for creating the built-in model service endpoints."""
    deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Deployments info."""
    endpoint_type: str = rest_discriminator(
        name="endpointType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of the endpoint. Required. Known values are: \"Azure.OpenAI\", \"Azure.Speech\",
     \"Azure.ContentSafety\", \"Azure.Llama\", \"managedOnlineEndpoint\", and
     \"serverlessEndpoint\"."""
    endpoint_uri: Optional[str] = rest_field(
        name="endpointUri", visibility=["read", "create", "update", "delete", "query"]
    )
    """Uri of the endpoint."""
    failure_reason: Optional[str] = rest_field(
        name="failureReason", visibility=["read", "create", "update", "delete", "query"]
    )
    """The failure reason if the creation failed."""
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of the endpoint."""
    provisioning_state: Optional[Union[str, "_models.DefaultResourceProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Read-only provision state status property. Known values are: \"NotStarted\", \"Failed\",
     \"Creating\", \"Updating\", \"Succeeded\", \"Deleting\", \"Accepted\", \"Canceled\",
     \"Scaling\", and \"Disabled\"."""
    should_create_ai_services_endpoint: Optional[bool] = rest_field(
        name="shouldCreateAiServicesEndpoint", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether the proxy (non-byo) endpoint is a regular endpoint or a OneKeyV2 AI services account
     endpoint."""

    @overload
    def __init__(
        self,
        *,
        endpoint_type: str,
        associated_resource_id: Optional[str] = None,
        deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = None,
        endpoint_uri: Optional[str] = None,
        failure_reason: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        should_create_ai_services_endpoint: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ContentSafetyEndpointResourceProperties(EndpointResourceProperties, discriminator="Azure.ContentSafety"):
    """ContentSafetyEndpointResourceProperties.

    :ivar associated_resource_id: Byo resource id for creating the built-in model service
     endpoints.
    :vartype associated_resource_id: str
    :ivar deployments: Deployments info.
    :vartype deployments:
     list[~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourcePropertiesBasicResource]
    :ivar endpoint_uri: Uri of the endpoint.
    :vartype endpoint_uri: str
    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar location: Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace.
    :vartype location: str
    :ivar name: Name of the endpoint.
    :vartype name: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar should_create_ai_services_endpoint: Whether the proxy (non-byo) endpoint is a regular
     endpoint or a OneKeyV2 AI services account endpoint.
    :vartype should_create_ai_services_endpoint: bool
    :ivar endpoint_type: Type of the endpoint. Required.
    :vartype endpoint_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_CONTENT_SAFETY
    """

    endpoint_type: Literal[EndpointType.AZURE_CONTENT_SAFETY] = rest_discriminator(name="endpointType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        associated_resource_id: Optional[str] = None,
        deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = None,
        endpoint_uri: Optional[str] = None,
        failure_reason: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        should_create_ai_services_endpoint: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_type = EndpointType.AZURE_CONTENT_SAFETY  # type: ignore


class CosmosDbSettings(_Model):
    """CosmosDbSettings.

    :ivar collections_throughput:
    :vartype collections_throughput: int
    """

    collections_throughput: Optional[int] = rest_field(
        name="collectionsThroughput", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        collections_throughput: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduleActionBase(_Model):
    """ScheduleActionBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    JobScheduleAction, CreateMonitorAction, EndpointScheduleAction

    :ivar action_type: [Required] Specifies the action type of the schedule. Required. Known values
     are: "CreateJob", "InvokeBatchEndpoint", and "CreateMonitor".
    :vartype action_type: str or ~azure.mgmt.machinelearningservices.models.ScheduleActionType
    """

    __mapping__: dict[str, _Model] = {}
    action_type: str = rest_discriminator(name="actionType", visibility=["read", "create", "update"])
    """[Required] Specifies the action type of the schedule. Required. Known values are:
     \"CreateJob\", \"InvokeBatchEndpoint\", and \"CreateMonitor\"."""

    @overload
    def __init__(
        self,
        *,
        action_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreateMonitorAction(ScheduleActionBase, discriminator="CreateMonitor"):
    """CreateMonitorAction.

    :ivar monitor_definition: [Required] Defines the monitor. Required.
    :vartype monitor_definition: ~azure.mgmt.machinelearningservices.models.MonitorDefinition
    :ivar action_type: [Required] Specifies the action type of the schedule. Required.
    :vartype action_type: str or ~azure.mgmt.machinelearningservices.models.CREATE_MONITOR
    """

    monitor_definition: "_models.MonitorDefinition" = rest_field(
        name="monitorDefinition", visibility=["read", "create"]
    )
    """[Required] Defines the monitor. Required."""
    action_type: Literal[ScheduleActionType.CREATE_MONITOR] = rest_discriminator(name="actionType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the action type of the schedule. Required."""

    @overload
    def __init__(
        self,
        *,
        monitor_definition: "_models.MonitorDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.action_type = ScheduleActionType.CREATE_MONITOR  # type: ignore


class Cron(_Model):
    """The workflow trigger cron for ComputeStartStop schedule type.

    :ivar start_time: The start time in yyyy-MM-ddTHH:mm:ss format.
    :vartype start_time: str
    :ivar time_zone: Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_.
    :vartype time_zone: str
    :ivar expression: [Required] Specifies cron expression of schedule.
     The expression should follow NCronTab format.
    :vartype expression: str
    """

    start_time: Optional[str] = rest_field(name="startTime", visibility=["read", "create", "update", "delete", "query"])
    """The start time in yyyy-MM-ddTHH:mm:ss format."""
    time_zone: Optional[str] = rest_field(name="timeZone", visibility=["read", "create", "update", "delete", "query"])
    """Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_."""
    expression: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Specifies cron expression of schedule.
     The expression should follow NCronTab format."""

    @overload
    def __init__(
        self,
        *,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
        expression: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TriggerBase(_Model):
    """TriggerBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CronTrigger, RecurrenceTrigger

    :ivar end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer
     `https://en.wikipedia.org/wiki/ISO_8601 <https://en.wikipedia.org/wiki/ISO_8601>`_.
     Recommented format would be "2022-06-01T00:00:01"
     If not present, the schedule will run indefinitely.
    :vartype end_time: str
    :ivar start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC
     offset.
    :vartype start_time: str
    :ivar time_zone: Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_.
    :vartype time_zone: str
    :ivar trigger_type: [Required]. Required. Known values are: "Recurrence" and "Cron".
    :vartype trigger_type: str or ~azure.mgmt.machinelearningservices.models.TriggerType
    """

    __mapping__: dict[str, _Model] = {}
    end_time: Optional[str] = rest_field(name="endTime", visibility=["read", "create", "update", "delete", "query"])
    """Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer
     `https://en.wikipedia.org/wiki/ISO_8601 <https://en.wikipedia.org/wiki/ISO_8601>`_.
     Recommented format would be \"2022-06-01T00:00:01\"
     If not present, the schedule will run indefinitely."""
    start_time: Optional[str] = rest_field(name="startTime", visibility=["read", "create", "update", "delete", "query"])
    """Specifies start time of schedule in ISO 8601 format, but without a UTC offset."""
    time_zone: Optional[str] = rest_field(name="timeZone", visibility=["read", "create", "update", "delete", "query"])
    """Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_."""
    trigger_type: str = rest_discriminator(name="triggerType", visibility=["read", "create", "update"])
    """[Required]. Required. Known values are: \"Recurrence\" and \"Cron\"."""

    @overload
    def __init__(
        self,
        *,
        trigger_type: str,
        end_time: Optional[str] = None,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CronTrigger(TriggerBase, discriminator="Cron"):
    """CronTrigger.

    :ivar end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer
     `https://en.wikipedia.org/wiki/ISO_8601 <https://en.wikipedia.org/wiki/ISO_8601>`_.
     Recommented format would be "2022-06-01T00:00:01"
     If not present, the schedule will run indefinitely.
    :vartype end_time: str
    :ivar start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC
     offset.
    :vartype start_time: str
    :ivar time_zone: Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_.
    :vartype time_zone: str
    :ivar expression: [Required] Specifies cron expression of schedule.
     The expression should follow NCronTab format. Required.
    :vartype expression: str
    :ivar trigger_type: [Required]. Required.
    :vartype trigger_type: str or ~azure.mgmt.machinelearningservices.models.CRON
    """

    expression: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Specifies cron expression of schedule.
     The expression should follow NCronTab format. Required."""
    trigger_type: Literal[TriggerType.CRON] = rest_discriminator(name="triggerType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required]. Required."""

    @overload
    def __init__(
        self,
        *,
        expression: str,
        end_time: Optional[str] = None,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.trigger_type = TriggerType.CRON  # type: ignore


class CustomForecastHorizon(ForecastHorizon, discriminator="Custom"):
    """The desired maximum forecast horizon in units of time-series frequency.

    :ivar value: [Required] Forecast horizon value. Required.
    :vartype value: int
    :ivar mode: [Required] Set forecast horizon value selection mode. Required. Use the custom
     forecast horizon.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    value: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Forecast horizon value. Required."""
    mode: Literal[ForecastHorizonMode.CUSTOM] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Set forecast horizon value selection mode. Required. Use the custom forecast
     horizon."""

    @overload
    def __init__(
        self,
        *,
        value: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = ForecastHorizonMode.CUSTOM  # type: ignore


class CustomKeys(_Model):
    """Custom Keys credential object.

    :ivar keys_property:
    :vartype keys_property: dict[str, str]
    """

    keys_property: Optional[dict[str, str]] = rest_field(
        name="keys", visibility=["read", "create", "update", "delete", "query"], original_tsp_name="keys"
    )

    @overload
    def __init__(
        self,
        *,
        keys_property: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomKeysWorkspaceConnectionProperties(WorkspaceConnectionPropertiesV2, discriminator="CustomKeys"):
    """Category:= CustomKeys
    AuthType:= CustomKeys (as type discriminator)
    Credentials:= {CustomKeys} as
    Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.CustomKeys
    Target:= {any value}
    Use Metadata property bag for ApiVersion and other metadata fields.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials: Custom Keys credential object.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.CustomKeys
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.CUSTOM_KEYS
    """

    credentials: Optional["_models.CustomKeys"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Custom Keys credential object."""
    auth_type: Literal[ConnectionAuthType.CUSTOM_KEYS] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.CustomKeys"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.CUSTOM_KEYS  # type: ignore


class CustomMetricThreshold(_Model):
    """CustomMetricThreshold.

    :ivar metric: [Required] The user-defined metric to calculate. Required.
    :vartype metric: str
    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    """

    metric: str = rest_field(visibility=["read", "create"])
    """[Required] The user-defined metric to calculate. Required."""
    threshold: Optional["_models.MonitoringThreshold"] = rest_field(visibility=["read", "create"])
    """The threshold value. If null, a default value will be set depending on the selected metric."""

    @overload
    def __init__(
        self,
        *,
        metric: str,
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomModelFineTuning(FineTuningVertical, discriminator="Custom"):
    """CustomModelFineTuning.

    :ivar model: [Required] Input model for fine tuning. Required.
    :vartype model: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar task_type: [Required] Fine tuning task type. Required. Known values are:
     "ChatCompletion", "TextCompletion", "TextClassification", "QuestionAnswering",
     "TextSummarization", "TokenClassification", "TextTranslation", "ImageClassification",
     "ImageInstanceSegmentation", "ImageObjectDetection", and "VideoMultiObjectTracking".
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.FineTuningTaskType
    :ivar training_data: [Required] Training data for fine tuning. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar validation_data: Validation data for fine tuning.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar hyper_parameters: HyperParameters for fine tuning custom model.
    :vartype hyper_parameters: dict[str, str]
    :ivar model_provider: [Required] Enum to determine the type of fine tuning. Required. Fine
     tuning using custom model.
    :vartype model_provider: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    hyper_parameters: Optional[dict[str, str]] = rest_field(
        name="hyperParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """HyperParameters for fine tuning custom model."""
    model_provider: Literal[ModelProvider.CUSTOM] = rest_discriminator(name="modelProvider", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Enum to determine the type of fine tuning. Required. Fine tuning using custom model."""

    @overload
    def __init__(
        self,
        *,
        model: "_models.JobInput",
        task_type: Union[str, "_models.FineTuningTaskType"],
        training_data: "_models.JobInput",
        validation_data: Optional["_models.JobInput"] = None,
        hyper_parameters: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.model_provider = ModelProvider.CUSTOM  # type: ignore


class JobInput(_Model):
    """Command job definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CustomModelJobInput, LiteralJobInput, MLFlowModelJobInput, MLTableJobInput,
    TritonModelJobInput, UriFileJobInput, UriFolderJobInput

    :ivar description: Description for the input.
    :vartype description: str
    :ivar job_input_type: [Required] Specifies the type of job. Required. Known values are:
     "literal", "uri_file", "uri_folder", "mltable", "custom_model", "mlflow_model", and
     "triton_model".
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.JobInputType
    """

    __mapping__: dict[str, _Model] = {}
    description: Optional[str] = rest_field(visibility=["read", "create"])
    """Description for the input."""
    job_input_type: str = rest_discriminator(name="jobInputType", visibility=["read", "create"])
    """[Required] Specifies the type of job. Required. Known values are: \"literal\", \"uri_file\",
     \"uri_folder\", \"mltable\", \"custom_model\", \"mlflow_model\", and \"triton_model\"."""

    @overload
    def __init__(
        self,
        *,
        job_input_type: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomModelJobInput(JobInput, discriminator="custom_model"):
    """CustomModelJobInput.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar mode: Enum to determine the input data delivery mode. Known values are: "ReadOnlyMount",
     "ReadWriteMount", "Download", "Direct", "EvalMount", and "EvalDownload".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.InputDeliveryMode
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.CUSTOM_MODEL
    """

    mode: Optional[Union[str, "_models.InputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Enum to determine the input data delivery mode. Known values are: \"ReadOnlyMount\",
     \"ReadWriteMount\", \"Download\", \"Direct\", \"EvalMount\", and \"EvalDownload\"."""
    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input Asset URI. Required."""
    job_input_type: Literal[JobInputType.CUSTOM_MODEL] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        uri: str,
        description: Optional[str] = None,
        mode: Optional[Union[str, "_models.InputDeliveryMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.CUSTOM_MODEL  # type: ignore


class JobOutput(_Model):
    """Job output definition container information on where to find job output/logs.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CustomModelJobOutput, MLFlowModelJobOutput, MLTableJobOutput, TritonModelJobOutput,
    UriFileJobOutput, UriFolderJobOutput

    :ivar description: Description for the output.
    :vartype description: str
    :ivar job_output_type: [Required] Specifies the type of job. Required. Known values are:
     "uri_file", "uri_folder", "mltable", "custom_model", "mlflow_model", and "triton_model".
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.JobOutputType
    """

    __mapping__: dict[str, _Model] = {}
    description: Optional[str] = rest_field(visibility=["read", "create"])
    """Description for the output."""
    job_output_type: str = rest_discriminator(name="jobOutputType", visibility=["read", "create"])
    """[Required] Specifies the type of job. Required. Known values are: \"uri_file\", \"uri_folder\",
     \"mltable\", \"custom_model\", \"mlflow_model\", and \"triton_model\"."""

    @overload
    def __init__(
        self,
        *,
        job_output_type: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomModelJobOutput(JobOutput, discriminator="custom_model"):
    """CustomModelJobOutput.

    :ivar description: Description for the output.
    :vartype description: str
    :ivar asset_name: Output Asset Name.
    :vartype asset_name: str
    :ivar mode: Output data delivery mode enums. Known values are: "ReadWriteMount", "Upload", and
     "Direct".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.OutputDeliveryMode
    :ivar uri: Output Asset URI.
    :vartype uri: str
    :ivar job_output_type: [Required] Specifies the type of job. Required.
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.CUSTOM_MODEL
    """

    asset_name: Optional[str] = rest_field(name="assetName", visibility=["read", "create", "update", "delete", "query"])
    """Output Asset Name."""
    mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Output data delivery mode enums. Known values are: \"ReadWriteMount\", \"Upload\", and
     \"Direct\"."""
    uri: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Output Asset URI."""
    job_output_type: Literal[JobOutputType.CUSTOM_MODEL] = rest_discriminator(name="jobOutputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = None,
        uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_output_type = JobOutputType.CUSTOM_MODEL  # type: ignore


class MonitoringSignalBase(_Model):
    """MonitoringSignalBase.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CustomMonitoringSignal, DataDriftMonitoringSignal, DataQualityMonitoringSignal,
    FeatureAttributionDriftMonitoringSignal, PredictionDriftMonitoringSignal

    :ivar notification_types: The current notification mode for this signal.
    :vartype notification_types: list[str or
     ~azure.mgmt.machinelearningservices.models.MonitoringNotificationType]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar signal_type: [Required] Specifies the type of signal to monitor. Required. Known values
     are: "DataDrift", "PredictionDrift", "DataQuality", "FeatureAttributionDrift", and "Custom".
    :vartype signal_type: str or ~azure.mgmt.machinelearningservices.models.MonitoringSignalType
    """

    __mapping__: dict[str, _Model] = {}
    notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = rest_field(
        name="notificationTypes", visibility=["read", "create"]
    )
    """The current notification mode for this signal."""
    properties: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Property dictionary. Properties can be added, but not removed or altered."""
    signal_type: str = rest_discriminator(name="signalType", visibility=["read", "create"])
    """[Required] Specifies the type of signal to monitor. Required. Known values are: \"DataDrift\",
     \"PredictionDrift\", \"DataQuality\", \"FeatureAttributionDrift\", and \"Custom\"."""

    @overload
    def __init__(
        self,
        *,
        signal_type: str,
        notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = None,
        properties: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomMonitoringSignal(MonitoringSignalBase, discriminator="Custom"):
    """CustomMonitoringSignal.

    :ivar notification_types: The current notification mode for this signal.
    :vartype notification_types: list[str or
     ~azure.mgmt.machinelearningservices.models.MonitoringNotificationType]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar component_id: [Required] Reference to the component asset used to calculate the custom
     metrics. Required.
    :vartype component_id: str
    :ivar input_assets: Monitoring assets to take as input. Key is the component input port name,
     value is the data asset.
    :vartype input_assets: dict[str,
     ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase]
    :ivar inputs: Extra component parameters to take as input. Key is the component literal input
     port name, value is the parameter value.
    :vartype inputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobInput]
    :ivar metric_thresholds: [Required] A list of metrics to calculate and their associated
     thresholds. Required.
    :vartype metric_thresholds:
     list[~azure.mgmt.machinelearningservices.models.CustomMetricThreshold]
    :ivar signal_type: [Required] Specifies the type of signal to monitor. Required. Tracks a
     custom signal provided by users.
    :vartype signal_type: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    component_id: str = rest_field(name="componentId", visibility=["read", "create"])
    """[Required] Reference to the component asset used to calculate the custom metrics. Required."""
    input_assets: Optional[dict[str, "_models.MonitoringInputDataBase"]] = rest_field(
        name="inputAssets", visibility=["read", "create"]
    )
    """Monitoring assets to take as input. Key is the component input port name, value is the data
     asset."""
    inputs: Optional[dict[str, "_models.JobInput"]] = rest_field(visibility=["read", "create"])
    """Extra component parameters to take as input. Key is the component literal input port name,
     value is the parameter value."""
    metric_thresholds: list["_models.CustomMetricThreshold"] = rest_field(
        name="metricThresholds", visibility=["read", "create"]
    )
    """[Required] A list of metrics to calculate and their associated thresholds. Required."""
    signal_type: Literal[MonitoringSignalType.CUSTOM] = rest_discriminator(name="signalType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. Tracks a custom signal provided
     by users."""

    @overload
    def __init__(
        self,
        *,
        component_id: str,
        metric_thresholds: list["_models.CustomMetricThreshold"],
        notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = None,
        properties: Optional[dict[str, str]] = None,
        input_assets: Optional[dict[str, "_models.MonitoringInputDataBase"]] = None,
        inputs: Optional[dict[str, "_models.JobInput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.signal_type = MonitoringSignalType.CUSTOM  # type: ignore


class CustomNCrossValidations(NCrossValidations, discriminator="Custom"):
    """N-Cross validations are specified by user.

    :ivar value: [Required] N-Cross validations value. Required.
    :vartype value: int
    :ivar mode: [Required] Mode for determining N-Cross validations. Required. Use custom N-Cross
     validations value.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    value: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] N-Cross validations value. Required."""
    mode: Literal[NCrossValidationsMode.CUSTOM] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Mode for determining N-Cross validations. Required. Use custom N-Cross validations
     value."""

    @overload
    def __init__(
        self,
        *,
        value: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = NCrossValidationsMode.CUSTOM  # type: ignore


class CustomSeasonality(Seasonality, discriminator="Custom"):
    """CustomSeasonality.

    :ivar value: [Required] Seasonality value. Required.
    :vartype value: int
    :ivar mode: [Required] Seasonality mode. Required. Use the custom seasonality value.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    value: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Seasonality value. Required."""
    mode: Literal[SeasonalityMode.CUSTOM] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Seasonality mode. Required. Use the custom seasonality value."""

    @overload
    def __init__(
        self,
        *,
        value: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = SeasonalityMode.CUSTOM  # type: ignore


class CustomService(_Model):
    """Specifies the custom service configuration.

    :ivar name: Name of the Custom Service.
    :vartype name: str
    :ivar image: Describes the Image Specifications.
    :vartype image: ~azure.mgmt.machinelearningservices.models.Image
    :ivar environment_variables: Environment Variable for the container.
    :vartype environment_variables: dict[str,
     ~azure.mgmt.machinelearningservices.models.EnvironmentVariable]
    :ivar docker: Describes the docker settings for the image.
    :vartype docker: ~azure.mgmt.machinelearningservices.models.Docker
    :ivar endpoints: Configuring the endpoints for the container.
    :vartype endpoints: list[~azure.mgmt.machinelearningservices.models.Endpoint]
    :ivar volumes: Configuring the volumes for the container.
    :vartype volumes: list[~azure.mgmt.machinelearningservices.models.VolumeDefinition]
    :ivar kernel: Describes the jupyter kernel settings for the image if its a custom environment.
    :vartype kernel: ~azure.mgmt.machinelearningservices.models.JupyterKernelConfig
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of the Custom Service."""
    image: Optional["_models.Image"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Describes the Image Specifications."""
    environment_variables: Optional[dict[str, "_models.EnvironmentVariable"]] = rest_field(
        name="environmentVariables", visibility=["read", "create", "update", "delete", "query"]
    )
    """Environment Variable for the container."""
    docker: Optional["_models.Docker"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Describes the docker settings for the image."""
    endpoints: Optional[list["_models.Endpoint"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuring the endpoints for the container."""
    volumes: Optional[list["_models.VolumeDefinition"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuring the volumes for the container."""
    kernel: Optional["_models.JupyterKernelConfig"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Describes the jupyter kernel settings for the image if its a custom environment."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        image: Optional["_models.Image"] = None,
        environment_variables: Optional[dict[str, "_models.EnvironmentVariable"]] = None,
        docker: Optional["_models.Docker"] = None,
        endpoints: Optional[list["_models.Endpoint"]] = None,
        volumes: Optional[list["_models.VolumeDefinition"]] = None,
        kernel: Optional["_models.JupyterKernelConfig"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomTargetLags(TargetLags, discriminator="Custom"):
    """CustomTargetLags.

    :ivar values_property: [Required] Set target lags values. Required.
    :vartype values_property: list[int]
    :ivar mode: [Required] Set target lags mode - Auto/Custom. Required. Use the custom target
     lags.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    values_property: list[int] = rest_field(
        name="values", visibility=["read", "create", "update", "delete", "query"], original_tsp_name="values"
    )
    """[Required] Set target lags values. Required."""
    mode: Literal[TargetLagsMode.CUSTOM] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Set target lags mode - Auto/Custom. Required. Use the custom target lags."""

    @overload
    def __init__(
        self,
        *,
        values_property: list[int],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = TargetLagsMode.CUSTOM  # type: ignore


class CustomTargetRollingWindowSize(TargetRollingWindowSize, discriminator="Custom"):
    """CustomTargetRollingWindowSize.

    :ivar value: [Required] TargetRollingWindowSize value. Required.
    :vartype value: int
    :ivar mode: [Required] TargetRollingWindowSiz detection mode. Required. Use the specified
     rolling window size.
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.CUSTOM
    """

    value: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] TargetRollingWindowSize value. Required."""
    mode: Literal[TargetRollingWindowSizeMode.CUSTOM] = rest_discriminator(name="mode", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] TargetRollingWindowSiz detection mode. Required. Use the specified rolling window
     size."""

    @overload
    def __init__(
        self,
        *,
        value: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.mode = TargetRollingWindowSizeMode.CUSTOM  # type: ignore


class Databricks(Compute, discriminator="Databricks"):
    """A DataFactory compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties:
    :vartype properties: ~azure.mgmt.machinelearningservices.models.DatabricksProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.DATABRICKS
    """

    properties: Optional["_models.DatabricksProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    compute_type: Literal[ComputeType.DATABRICKS] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.DatabricksProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.DATABRICKS  # type: ignore


class DatabricksComputeSecrets(ComputeSecrets, discriminator="Databricks"):
    """Secrets related to a Machine Learning compute based on Databricks.

    :ivar databricks_access_token: access token for databricks account.
    :vartype databricks_access_token: str
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.DATABRICKS
    """

    databricks_access_token: Optional[str] = rest_field(
        name="databricksAccessToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """access token for databricks account."""
    compute_type: Literal[ComputeType.DATABRICKS] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        databricks_access_token: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.DATABRICKS  # type: ignore


class DatabricksProperties(_Model):
    """Properties of Databricks.

    :ivar databricks_access_token: Databricks access token.
    :vartype databricks_access_token: str
    :ivar workspace_url: Workspace Url.
    :vartype workspace_url: str
    """

    databricks_access_token: Optional[str] = rest_field(
        name="databricksAccessToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """Databricks access token."""
    workspace_url: Optional[str] = rest_field(
        name="workspaceUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Workspace Url."""

    @overload
    def __init__(
        self,
        *,
        databricks_access_token: Optional[str] = None,
        workspace_url: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataCollector(_Model):
    """DataCollector.

    :ivar collections: [Required] The collection configuration. Each collection has it own
     configuration to collect model data and the name of collection can be arbitrary string.
     Model data collector can be used for either payload logging or custom logging or both of them.
     Collection request and response are reserved for payload logging, others are for custom
     logging. Required.
    :vartype collections: dict[str, ~azure.mgmt.machinelearningservices.models.Collection]
    :ivar request_logging: The request logging configuration for mdc, it includes advanced logging
     settings for all collections. It's optional.
    :vartype request_logging: ~azure.mgmt.machinelearningservices.models.RequestLogging
    :ivar rolling_rate: When model data is collected to blob storage, we need to roll the data to
     different path to avoid logging all of them in a single blob file.
     If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
     If it's day, all data will be collected in blob path /yyyy/MM/dd/.
     The other benefit of rolling path is that model monitoring ui is able to select a time range of
     data very quickly. Known values are: "Year", "Month", "Day", "Hour", and "Minute".
    :vartype rolling_rate: str or ~azure.mgmt.machinelearningservices.models.RollingRateType
    """

    collections: dict[str, "_models.Collection"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The collection configuration. Each collection has it own configuration to collect
     model data and the name of collection can be arbitrary string.
     Model data collector can be used for either payload logging or custom logging or both of them.
     Collection request and response are reserved for payload logging, others are for custom
     logging. Required."""
    request_logging: Optional["_models.RequestLogging"] = rest_field(
        name="requestLogging", visibility=["read", "create", "update", "delete", "query"]
    )
    """The request logging configuration for mdc, it includes advanced logging settings for all
     collections. It's optional."""
    rolling_rate: Optional[Union[str, "_models.RollingRateType"]] = rest_field(
        name="rollingRate", visibility=["read", "create", "update", "delete", "query"]
    )
    """When model data is collected to blob storage, we need to roll the data to different path to
     avoid logging all of them in a single blob file.
     If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
     If it's day, all data will be collected in blob path /yyyy/MM/dd/.
     The other benefit of rolling path is that model monitoring ui is able to select a time range of
     data very quickly. Known values are: \"Year\", \"Month\", \"Day\", \"Hour\", and \"Minute\"."""

    @overload
    def __init__(
        self,
        *,
        collections: dict[str, "_models.Collection"],
        request_logging: Optional["_models.RequestLogging"] = None,
        rolling_rate: Optional[Union[str, "_models.RollingRateType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.DataContainerProperties
    """

    properties: "_models.DataContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.DataContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataContainerProperties(AssetContainer):
    """Container for data asset versions.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar data_type: [Required] Specifies the type of data. Required. Known values are: "uri_file",
     "uri_folder", and "mltable".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.DataType
    """

    data_type: Union[str, "_models.DataType"] = rest_field(name="dataType", visibility=["read", "create"])
    """[Required] Specifies the type of data. Required. Known values are: \"uri_file\",
     \"uri_folder\", and \"mltable\"."""

    @overload
    def __init__(
        self,
        *,
        data_type: Union[str, "_models.DataType"],
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataDriftMonitoringSignal(MonitoringSignalBase, discriminator="DataDrift"):
    """DataDriftMonitoringSignal.

    :ivar notification_types: The current notification mode for this signal.
    :vartype notification_types: list[str or
     ~azure.mgmt.machinelearningservices.models.MonitoringNotificationType]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar feature_data_type_override: A dictionary that maps feature names to their respective data
     types.
    :vartype feature_data_type_override: dict[str, str or
     ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType]
    :ivar feature_importance_settings: The settings for computing feature importance.
    :vartype feature_importance_settings:
     ~azure.mgmt.machinelearningservices.models.FeatureImportanceSettings
    :ivar features: The feature filter which identifies which feature to calculate drift over.
    :vartype features: ~azure.mgmt.machinelearningservices.models.MonitoringFeatureFilterBase
    :ivar metric_thresholds: [Required] A list of metrics to calculate and their associated
     thresholds. Required.
    :vartype metric_thresholds:
     list[~azure.mgmt.machinelearningservices.models.DataDriftMetricThresholdBase]
    :ivar production_data: [Required] The data which drift will be calculated for. Required.
    :vartype production_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar reference_data: [Required] The data to calculate drift against. Required.
    :vartype reference_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar signal_type: [Required] Specifies the type of signal to monitor. Required. Tracks model
     input data distribution change, comparing against training data or past production data.
    :vartype signal_type: str or ~azure.mgmt.machinelearningservices.models.DATA_DRIFT
    """

    feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = rest_field(
        name="featureDataTypeOverride", visibility=["read", "create"]
    )
    """A dictionary that maps feature names to their respective data types."""
    feature_importance_settings: Optional["_models.FeatureImportanceSettings"] = rest_field(
        name="featureImportanceSettings", visibility=["read", "create"]
    )
    """The settings for computing feature importance."""
    features: Optional["_models.MonitoringFeatureFilterBase"] = rest_field(visibility=["read", "create"])
    """The feature filter which identifies which feature to calculate drift over."""
    metric_thresholds: list["_models.DataDriftMetricThresholdBase"] = rest_field(
        name="metricThresholds", visibility=["read", "create"]
    )
    """[Required] A list of metrics to calculate and their associated thresholds. Required."""
    production_data: "_models.MonitoringInputDataBase" = rest_field(
        name="productionData", visibility=["read", "create"]
    )
    """[Required] The data which drift will be calculated for. Required."""
    reference_data: "_models.MonitoringInputDataBase" = rest_field(name="referenceData", visibility=["read", "create"])
    """[Required] The data to calculate drift against. Required."""
    signal_type: Literal[MonitoringSignalType.DATA_DRIFT] = rest_discriminator(name="signalType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. Tracks model input data
     distribution change, comparing against training data or past production data."""

    @overload
    def __init__(
        self,
        *,
        metric_thresholds: list["_models.DataDriftMetricThresholdBase"],
        production_data: "_models.MonitoringInputDataBase",
        reference_data: "_models.MonitoringInputDataBase",
        notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = None,
        properties: Optional[dict[str, str]] = None,
        feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = None,
        feature_importance_settings: Optional["_models.FeatureImportanceSettings"] = None,
        features: Optional["_models.MonitoringFeatureFilterBase"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.signal_type = MonitoringSignalType.DATA_DRIFT  # type: ignore


class DataFactory(Compute, discriminator="DataFactory"):
    """A DataFactory compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.DATA_FACTORY
    """

    compute_type: Literal[ComputeType.DATA_FACTORY] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.DATA_FACTORY  # type: ignore


class DataGenerationVertical(_Model):
    """DataGenerationVertical.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    LabelGeneration

    :ivar data_generation_task_type: [Required] DataGeneration Task type. Required. Known values
     are: "Conversation", "Math", "Nli", "NluQa", and "Summarization".
    :vartype data_generation_task_type: str or
     ~azure.mgmt.machinelearningservices.models.DataGenerationTaskType
    :ivar data_generation_type: [Required] Enum to determine the type of Data Generation. Required.
     Known values are: "LabelGeneration" and "DataGeneration".
    :vartype data_generation_type: str or
     ~azure.mgmt.machinelearningservices.models.DataGenerationType
    :ivar prompt_settings: Prompt Settings.
    :vartype prompt_settings: ~azure.mgmt.machinelearningservices.models.PromptSettings
    :ivar teacher_model_endpoint: [Required] Teacher Model Endpoint Details. Required.
    :vartype teacher_model_endpoint:
     ~azure.mgmt.machinelearningservices.models.TeacherModelEndpoint
    :ivar teacher_model_settings:
    :vartype teacher_model_settings:
     ~azure.mgmt.machinelearningservices.models.TeacherModelSettings
    """

    __mapping__: dict[str, _Model] = {}
    data_generation_task_type: Union[str, "_models.DataGenerationTaskType"] = rest_field(
        name="dataGenerationTaskType", visibility=["read", "create"]
    )
    """[Required] DataGeneration Task type. Required. Known values are: \"Conversation\", \"Math\",
     \"Nli\", \"NluQa\", and \"Summarization\"."""
    data_generation_type: str = rest_discriminator(name="dataGenerationType", visibility=["read", "create"])
    """[Required] Enum to determine the type of Data Generation. Required. Known values are:
     \"LabelGeneration\" and \"DataGeneration\"."""
    prompt_settings: Optional["_models.PromptSettings"] = rest_field(
        name="promptSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Prompt Settings."""
    teacher_model_endpoint: "_models.TeacherModelEndpoint" = rest_field(
        name="teacherModelEndpoint", visibility=["read", "create"]
    )
    """[Required] Teacher Model Endpoint Details. Required."""
    teacher_model_settings: Optional["_models.TeacherModelSettings"] = rest_field(
        name="teacherModelSettings", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        data_generation_task_type: Union[str, "_models.DataGenerationTaskType"],
        data_generation_type: str,
        teacher_model_endpoint: "_models.TeacherModelEndpoint",
        prompt_settings: Optional["_models.PromptSettings"] = None,
        teacher_model_settings: Optional["_models.TeacherModelSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataLakeAnalytics(Compute, discriminator="DataLakeAnalytics"):
    """A DataLakeAnalytics compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties:
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.DataLakeAnalyticsSchemaProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.DATA_LAKE_ANALYTICS
    """

    properties: Optional["_models.DataLakeAnalyticsSchemaProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    compute_type: Literal[ComputeType.DATA_LAKE_ANALYTICS] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.DataLakeAnalyticsSchemaProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.DATA_LAKE_ANALYTICS  # type: ignore


class DataLakeAnalyticsSchemaProperties(_Model):
    """DataLakeAnalyticsSchemaProperties.

    :ivar data_lake_store_account_name: DataLake Store Account Name.
    :vartype data_lake_store_account_name: str
    """

    data_lake_store_account_name: Optional[str] = rest_field(
        name="dataLakeStoreAccountName", visibility=["read", "create", "update", "delete", "query"]
    )
    """DataLake Store Account Name."""

    @overload
    def __init__(
        self,
        *,
        data_lake_store_account_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataPathAssetReference(AssetReferenceBase, discriminator="DataPath"):
    """Reference to an asset via its path in a datastore.

    :ivar datastore_id: ARM resource ID of the datastore where the asset is located.
    :vartype datastore_id: str
    :ivar path: The path of the file/directory in the datastore.
    :vartype path: str
    :ivar reference_type: [Required] Specifies the type of asset reference. Required.
    :vartype reference_type: str or ~azure.mgmt.machinelearningservices.models.DATA_PATH
    """

    datastore_id: Optional[str] = rest_field(
        name="datastoreId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM resource ID of the datastore where the asset is located."""
    path: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The path of the file/directory in the datastore."""
    reference_type: Literal[ReferenceType.DATA_PATH] = rest_discriminator(name="referenceType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of asset reference. Required."""

    @overload
    def __init__(
        self,
        *,
        datastore_id: Optional[str] = None,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.reference_type = ReferenceType.DATA_PATH  # type: ignore


class DataQualityMonitoringSignal(MonitoringSignalBase, discriminator="DataQuality"):
    """DataQualityMonitoringSignal.

    :ivar notification_types: The current notification mode for this signal.
    :vartype notification_types: list[str or
     ~azure.mgmt.machinelearningservices.models.MonitoringNotificationType]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar feature_data_type_override: A dictionary that maps feature names to their respective data
     types.
    :vartype feature_data_type_override: dict[str, str or
     ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType]
    :ivar feature_importance_settings: The settings for computing feature importance.
    :vartype feature_importance_settings:
     ~azure.mgmt.machinelearningservices.models.FeatureImportanceSettings
    :ivar features: The features to calculate drift over.
    :vartype features: ~azure.mgmt.machinelearningservices.models.MonitoringFeatureFilterBase
    :ivar metric_thresholds: [Required] A list of metrics to calculate and their associated
     thresholds. Required.
    :vartype metric_thresholds:
     list[~azure.mgmt.machinelearningservices.models.DataQualityMetricThresholdBase]
    :ivar production_data: [Required] The data produced by the production service which drift will
     be calculated for. Required.
    :vartype production_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar reference_data: [Required] The data to calculate drift against. Required.
    :vartype reference_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar signal_type: [Required] Specifies the type of signal to monitor. Required. Tracks model
     input data integrity.
    :vartype signal_type: str or ~azure.mgmt.machinelearningservices.models.DATA_QUALITY
    """

    feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = rest_field(
        name="featureDataTypeOverride", visibility=["read", "create"]
    )
    """A dictionary that maps feature names to their respective data types."""
    feature_importance_settings: Optional["_models.FeatureImportanceSettings"] = rest_field(
        name="featureImportanceSettings", visibility=["read", "create"]
    )
    """The settings for computing feature importance."""
    features: Optional["_models.MonitoringFeatureFilterBase"] = rest_field(visibility=["read", "create"])
    """The features to calculate drift over."""
    metric_thresholds: list["_models.DataQualityMetricThresholdBase"] = rest_field(
        name="metricThresholds", visibility=["read", "create"]
    )
    """[Required] A list of metrics to calculate and their associated thresholds. Required."""
    production_data: "_models.MonitoringInputDataBase" = rest_field(
        name="productionData", visibility=["read", "create"]
    )
    """[Required] The data produced by the production service which drift will be calculated for.
     Required."""
    reference_data: "_models.MonitoringInputDataBase" = rest_field(name="referenceData", visibility=["read", "create"])
    """[Required] The data to calculate drift against. Required."""
    signal_type: Literal[MonitoringSignalType.DATA_QUALITY] = rest_discriminator(name="signalType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. Tracks model input data
     integrity."""

    @overload
    def __init__(
        self,
        *,
        metric_thresholds: list["_models.DataQualityMetricThresholdBase"],
        production_data: "_models.MonitoringInputDataBase",
        reference_data: "_models.MonitoringInputDataBase",
        notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = None,
        properties: Optional[dict[str, str]] = None,
        feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = None,
        feature_importance_settings: Optional["_models.FeatureImportanceSettings"] = None,
        features: Optional["_models.MonitoringFeatureFilterBase"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.signal_type = MonitoringSignalType.DATA_QUALITY  # type: ignore


class DatasetReference(_Model):
    """Dataset reference object.

    :ivar name: The name of the dataset reference.
    :vartype name: str
    :ivar id: The fully qualified ARM id of the dataset reference.
    :vartype id: str
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the dataset reference."""
    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The fully qualified ARM id of the dataset reference."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Datastore(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.DatastoreProperties
    """

    properties: "_models.DatastoreProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.DatastoreProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataVersionBase(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.DataVersionBaseProperties
    """

    properties: "_models.DataVersionBaseProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.DataVersionBaseProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataVersionBaseProperties(AssetBase):
    """Data version base definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    MLTableData, UriFileDataVersion, UriFolderDataVersion

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_type: [Required] Specifies the type of data. Required. Known values are: "uri_file",
     "uri_folder", and "mltable".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.DataType
    :ivar data_uri: [Required] Uri of the data. Example:
     `https://go.microsoft.com/fwlink/?linkid=2202330
     <https://go.microsoft.com/fwlink/?linkid=2202330>`_. Required.
    :vartype data_uri: str
    """

    __mapping__: dict[str, _Model] = {}
    data_type: str = rest_discriminator(name="dataType", visibility=["read", "create"])
    """[Required] Specifies the type of data. Required. Known values are: \"uri_file\",
     \"uri_folder\", and \"mltable\"."""
    data_uri: str = rest_field(name="dataUri", visibility=["read", "create"])
    """[Required] Uri of the data. Example: `https://go.microsoft.com/fwlink/?linkid=2202330
     <https://go.microsoft.com/fwlink/?linkid=2202330>`_. Required."""

    @overload
    def __init__(
        self,
        *,
        data_type: str,
        data_uri: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineScaleSettings(_Model):
    """Online deployment scaling configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DefaultScaleSettings, TargetUtilizationScaleSettings

    :ivar scale_type: [Required] Type of deployment scaling algorithm. Required. Known values are:
     "Default" and "TargetUtilization".
    :vartype scale_type: str or ~azure.mgmt.machinelearningservices.models.ScaleType
    """

    __mapping__: dict[str, _Model] = {}
    scale_type: str = rest_discriminator(name="scaleType", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Type of deployment scaling algorithm. Required. Known values are: \"Default\" and
     \"TargetUtilization\"."""

    @overload
    def __init__(
        self,
        *,
        scale_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DefaultScaleSettings(OnlineScaleSettings, discriminator="Default"):
    """DefaultScaleSettings.

    :ivar scale_type: [Required] Type of deployment scaling algorithm. Required.
    :vartype scale_type: str or ~azure.mgmt.machinelearningservices.models.DEFAULT
    """

    scale_type: Literal[ScaleType.DEFAULT] = rest_discriminator(name="scaleType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Type of deployment scaling algorithm. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.scale_type = ScaleType.DEFAULT  # type: ignore


class DeltaModelCurrentState(_Model):
    """Contract for DeltaModelCurrentState.

    :ivar count: Gets or sets Count of instances with model.
    :vartype count: int
    :ivar sample_instance_id: Gets or sets sample of instances with model.
    :vartype sample_instance_id: str
    :ivar status: Gets or sets status.
    :vartype status: str
    """

    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets Count of instances with model."""
    sample_instance_id: Optional[str] = rest_field(
        name="sampleInstanceID", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets sample of instances with model."""
    status: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets status."""

    @overload
    def __init__(
        self,
        *,
        count: Optional[int] = None,
        sample_instance_id: Optional[str] = None,
        status: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeltaModelListRequest(_Model):
    """DeltaModelListRequest.

    :ivar count: Gets or sets number of delta models to return. Default: -1, means that all will be
     returned.
    :vartype count: int
    :ivar skip_token: Gets or sets skip token for paginated response.
    :vartype skip_token: str
    :ivar target_base_model: Gets or sets target base model.
    :vartype target_base_model: str
    """

    count: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets number of delta models to return. Default: -1, means that all will be returned."""
    skip_token: Optional[str] = rest_field(name="skipToken", visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets skip token for paginated response."""
    target_base_model: Optional[str] = rest_field(
        name="targetBaseModel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets target base model."""

    @overload
    def __init__(
        self,
        *,
        count: Optional[int] = None,
        skip_token: Optional[str] = None,
        target_base_model: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeltaModelModifyRequest(_Model):
    """Contract base for DeltaModelChangeRequest. Used for adding or removing.

    :ivar add_delta_models: Gets or sets delta models to remove.
    :vartype add_delta_models: list[str]
    :ivar remove_delta_models: Gets or sets delta models to remove.
    :vartype remove_delta_models: list[str]
    :ivar target_base_model: Gets or sets target base model.
    :vartype target_base_model: str
    """

    add_delta_models: Optional[list[str]] = rest_field(
        name="addDeltaModels", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets delta models to remove."""
    remove_delta_models: Optional[list[str]] = rest_field(
        name="removeDeltaModels", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets delta models to remove."""
    target_base_model: Optional[str] = rest_field(
        name="targetBaseModel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets target base model."""

    @overload
    def __init__(
        self,
        *,
        add_delta_models: Optional[list[str]] = None,
        remove_delta_models: Optional[list[str]] = None,
        target_base_model: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeltaModelStatusRequest(_Model):
    """DeltaModelStatusRequest.

    :ivar delta_models: Gets or sets collection of delta models to retrieve status for.
    :vartype delta_models: list[str]
    :ivar target_base_model: Gets or sets target base model.
    :vartype target_base_model: str
    """

    delta_models: Optional[list[str]] = rest_field(
        name="deltaModels", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets collection of delta models to retrieve status for."""
    target_base_model: Optional[str] = rest_field(
        name="targetBaseModel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets target base model."""

    @overload
    def __init__(
        self,
        *,
        delta_models: Optional[list[str]] = None,
        target_base_model: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeltaModelStatusResponse(_Model):
    """Contract returning to user the delta models.

    :ivar actual_instance_count: Gets or sets actual instance count.
    :vartype actual_instance_count: int
    :ivar delta_models: Gets or sets dictionary representing modelID and its current state.
    :vartype delta_models: dict[str,
     list[~azure.mgmt.machinelearningservices.models.DeltaModelCurrentState]]
    :ivar expected_instance_count: Gets or sets expected instance count.
    :vartype expected_instance_count: int
    :ivar revision_id: Gets or sets revision ID.
    :vartype revision_id: str
    :ivar target_base_model: Gets or sets target base model.
    :vartype target_base_model: str
    """

    actual_instance_count: Optional[int] = rest_field(
        name="actualInstanceCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets actual instance count."""
    delta_models: Optional[dict[str, list["_models.DeltaModelCurrentState"]]] = rest_field(
        name="deltaModels", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets dictionary representing modelID and its current state."""
    expected_instance_count: Optional[int] = rest_field(
        name="expectedInstanceCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets expected instance count."""
    revision_id: Optional[str] = rest_field(
        name="revisionId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets revision ID."""
    target_base_model: Optional[str] = rest_field(
        name="targetBaseModel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets target base model."""

    @overload
    def __init__(
        self,
        *,
        actual_instance_count: Optional[int] = None,
        delta_models: Optional[dict[str, list["_models.DeltaModelCurrentState"]]] = None,
        expected_instance_count: Optional[int] = None,
        revision_id: Optional[str] = None,
        target_base_model: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeploymentLogs(_Model):
    """DeploymentLogs.

    :ivar content: The retrieved online deployment logs.
    :vartype content: str
    """

    content: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The retrieved online deployment logs."""

    @overload
    def __init__(
        self,
        *,
        content: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeploymentLogsRequest(_Model):
    """DeploymentLogsRequest.

    :ivar container_type: The type of container to retrieve logs from. Known values are:
     "StorageInitializer" and "InferenceServer".
    :vartype container_type: str or ~azure.mgmt.machinelearningservices.models.ContainerType
    :ivar tail: The maximum number of lines to tail.
    :vartype tail: int
    """

    container_type: Optional[Union[str, "_models.ContainerType"]] = rest_field(
        name="containerType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of container to retrieve logs from. Known values are: \"StorageInitializer\" and
     \"InferenceServer\"."""
    tail: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The maximum number of lines to tail."""

    @overload
    def __init__(
        self,
        *,
        container_type: Optional[Union[str, "_models.ContainerType"]] = None,
        tail: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceConfiguration(_Model):
    """ResourceConfiguration.

    :ivar instance_count: Optional number of instances or nodes used by the compute target.
    :vartype instance_count: int
    :ivar instance_type: Optional type of VM used as supported by the compute target.
    :vartype instance_type: str
    :ivar properties: Additional properties bag.
    :vartype properties: dict[str, any]
    """

    instance_count: Optional[int] = rest_field(name="instanceCount", visibility=["read", "create"])
    """Optional number of instances or nodes used by the compute target."""
    instance_type: Optional[str] = rest_field(name="instanceType", visibility=["read", "create"])
    """Optional type of VM used as supported by the compute target."""
    properties: Optional[dict[str, Any]] = rest_field(visibility=["read", "create"])
    """Additional properties bag."""

    @overload
    def __init__(
        self,
        *,
        instance_count: Optional[int] = None,
        instance_type: Optional[str] = None,
        properties: Optional[dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DeploymentResourceConfiguration(ResourceConfiguration):
    """DeploymentResourceConfiguration.

    :ivar instance_count: Optional number of instances or nodes used by the compute target.
    :vartype instance_count: int
    :ivar instance_type: Optional type of VM used as supported by the compute target.
    :vartype instance_type: str
    :ivar properties: Additional properties bag.
    :vartype properties: dict[str, any]
    """

    @overload
    def __init__(
        self,
        *,
        instance_count: Optional[int] = None,
        instance_type: Optional[str] = None,
        properties: Optional[dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DestinationAsset(_Model):
    """Publishing destination registry asset information.

    :ivar destination_name: Destination asset name.
    :vartype destination_name: str
    :ivar destination_version: Destination asset version.
    :vartype destination_version: str
    :ivar registry_name: Destination registry name.
    :vartype registry_name: str
    """

    destination_name: Optional[str] = rest_field(
        name="destinationName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Destination asset name."""
    destination_version: Optional[str] = rest_field(
        name="destinationVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Destination asset version."""
    registry_name: Optional[str] = rest_field(
        name="registryName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Destination registry name."""

    @overload
    def __init__(
        self,
        *,
        destination_name: Optional[str] = None,
        destination_version: Optional[str] = None,
        registry_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiagnoseRequestProperties(_Model):
    """DiagnoseRequestProperties.

    :ivar application_insights: Setting for diagnosing dependent application insights.
    :vartype application_insights: dict[str, any]
    :ivar container_registry: Setting for diagnosing dependent container registry.
    :vartype container_registry: dict[str, any]
    :ivar dns_resolution: Setting for diagnosing dns resolution.
    :vartype dns_resolution: dict[str, any]
    :ivar key_vault: Setting for diagnosing dependent key vault.
    :vartype key_vault: dict[str, any]
    :ivar nsg: Setting for diagnosing network security group.
    :vartype nsg: dict[str, any]
    :ivar others: Setting for diagnosing unclassified category of problems.
    :vartype others: dict[str, any]
    :ivar required_resource_providers: Setting for diagnosing the presence of required resource
     providers in the workspace.
    :vartype required_resource_providers: dict[str, any]
    :ivar resource_lock: Setting for diagnosing resource lock.
    :vartype resource_lock: dict[str, any]
    :ivar storage_account: Setting for diagnosing dependent storage account.
    :vartype storage_account: dict[str, any]
    :ivar udr: Setting for diagnosing user defined routing.
    :vartype udr: dict[str, any]
    """

    application_insights: Optional[dict[str, Any]] = rest_field(
        name="applicationInsights", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing dependent application insights."""
    container_registry: Optional[dict[str, Any]] = rest_field(
        name="containerRegistry", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing dependent container registry."""
    dns_resolution: Optional[dict[str, Any]] = rest_field(
        name="dnsResolution", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing dns resolution."""
    key_vault: Optional[dict[str, Any]] = rest_field(
        name="keyVault", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing dependent key vault."""
    nsg: Optional[dict[str, Any]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Setting for diagnosing network security group."""
    others: Optional[dict[str, Any]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Setting for diagnosing unclassified category of problems."""
    required_resource_providers: Optional[dict[str, Any]] = rest_field(
        name="requiredResourceProviders", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing the presence of required resource providers in the workspace."""
    resource_lock: Optional[dict[str, Any]] = rest_field(
        name="resourceLock", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing resource lock."""
    storage_account: Optional[dict[str, Any]] = rest_field(
        name="storageAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Setting for diagnosing dependent storage account."""
    udr: Optional[dict[str, Any]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Setting for diagnosing user defined routing."""

    @overload
    def __init__(
        self,
        *,
        application_insights: Optional[dict[str, Any]] = None,
        container_registry: Optional[dict[str, Any]] = None,
        dns_resolution: Optional[dict[str, Any]] = None,
        key_vault: Optional[dict[str, Any]] = None,
        nsg: Optional[dict[str, Any]] = None,
        others: Optional[dict[str, Any]] = None,
        required_resource_providers: Optional[dict[str, Any]] = None,
        resource_lock: Optional[dict[str, Any]] = None,
        storage_account: Optional[dict[str, Any]] = None,
        udr: Optional[dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiagnoseResponseResult(_Model):
    """DiagnoseResponseResult.

    :ivar value:
    :vartype value: ~azure.mgmt.machinelearningservices.models.DiagnoseResponseResultValue
    """

    value: Optional["_models.DiagnoseResponseResultValue"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        value: Optional["_models.DiagnoseResponseResultValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiagnoseResponseResultValue(_Model):
    """DiagnoseResponseResultValue.

    :ivar user_defined_route_results:
    :vartype user_defined_route_results:
     list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar network_security_rule_results:
    :vartype network_security_rule_results:
     list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar resource_lock_results:
    :vartype resource_lock_results: list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar dns_resolution_results:
    :vartype dns_resolution_results:
     list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar storage_account_results:
    :vartype storage_account_results:
     list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar key_vault_results:
    :vartype key_vault_results: list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar container_registry_results:
    :vartype container_registry_results:
     list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar application_insights_results:
    :vartype application_insights_results:
     list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    :ivar other_results:
    :vartype other_results: list[~azure.mgmt.machinelearningservices.models.DiagnoseResult]
    """

    user_defined_route_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="userDefinedRouteResults", visibility=["read", "create", "update", "delete", "query"]
    )
    network_security_rule_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="networkSecurityRuleResults", visibility=["read", "create", "update", "delete", "query"]
    )
    resource_lock_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="resourceLockResults", visibility=["read", "create", "update", "delete", "query"]
    )
    dns_resolution_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="dnsResolutionResults", visibility=["read", "create", "update", "delete", "query"]
    )
    storage_account_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="storageAccountResults", visibility=["read", "create", "update", "delete", "query"]
    )
    key_vault_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="keyVaultResults", visibility=["read", "create", "update", "delete", "query"]
    )
    container_registry_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="containerRegistryResults", visibility=["read", "create", "update", "delete", "query"]
    )
    application_insights_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="applicationInsightsResults", visibility=["read", "create", "update", "delete", "query"]
    )
    other_results: Optional[list["_models.DiagnoseResult"]] = rest_field(
        name="otherResults", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        user_defined_route_results: Optional[list["_models.DiagnoseResult"]] = None,
        network_security_rule_results: Optional[list["_models.DiagnoseResult"]] = None,
        resource_lock_results: Optional[list["_models.DiagnoseResult"]] = None,
        dns_resolution_results: Optional[list["_models.DiagnoseResult"]] = None,
        storage_account_results: Optional[list["_models.DiagnoseResult"]] = None,
        key_vault_results: Optional[list["_models.DiagnoseResult"]] = None,
        container_registry_results: Optional[list["_models.DiagnoseResult"]] = None,
        application_insights_results: Optional[list["_models.DiagnoseResult"]] = None,
        other_results: Optional[list["_models.DiagnoseResult"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiagnoseResult(_Model):
    """Result of Diagnose.

    :ivar code: Code for workspace setup error.
    :vartype code: str
    :ivar level: Level of workspace setup error. Known values are: "Warning", "Error", and
     "Information".
    :vartype level: str or ~azure.mgmt.machinelearningservices.models.DiagnoseResultLevel
    :ivar message: Message of workspace setup error.
    :vartype message: str
    """

    code: Optional[str] = rest_field(visibility=["read"])
    """Code for workspace setup error."""
    level: Optional[Union[str, "_models.DiagnoseResultLevel"]] = rest_field(visibility=["read"])
    """Level of workspace setup error. Known values are: \"Warning\", \"Error\", and \"Information\"."""
    message: Optional[str] = rest_field(visibility=["read"])
    """Message of workspace setup error."""


class DiagnoseWorkspaceParameters(_Model):
    """Parameters to diagnose a workspace.

    :ivar value:
    :vartype value: ~azure.mgmt.machinelearningservices.models.DiagnoseRequestProperties
    """

    value: Optional["_models.DiagnoseRequestProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        value: Optional["_models.DiagnoseRequestProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DistillationJob(JobBaseProperties, discriminator="Distillation"):
    """Distillation Job definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar data_generation_details: [Required]. Required.
    :vartype data_generation_details:
     ~azure.mgmt.machinelearningservices.models.DataGenerationVertical
    :ivar finetuning_details: [Required]. Required.
    :vartype finetuning_details: ~azure.mgmt.machinelearningservices.models.FinetuningDetails
    :ivar outputs: [Required]. Required.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar queue_settings: Queue settings for the job.
    :vartype queue_settings: ~azure.mgmt.machinelearningservices.models.QueueSettings
    :ivar resources: Instance types and other resources for the job.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.JobResources
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.DISTILLATION
    """

    data_generation_details: "_models.DataGenerationVertical" = rest_field(
        name="dataGenerationDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required]. Required."""
    finetuning_details: "_models.FinetuningDetails" = rest_field(
        name="finetuningDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required]. Required."""
    outputs: dict[str, "_models.JobOutput"] = rest_field(visibility=["read", "create"])
    """[Required]. Required."""
    queue_settings: Optional["_models.QueueSettings"] = rest_field(name="queueSettings", visibility=["read", "create"])
    """Queue settings for the job."""
    resources: Optional["_models.JobResources"] = rest_field(visibility=["read", "create"])
    """Instance types and other resources for the job."""
    job_type: Literal[JobType.DISTILLATION] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        data_generation_details: "_models.DataGenerationVertical",
        finetuning_details: "_models.FinetuningDetails",
        outputs: dict[str, "_models.JobOutput"],
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        queue_settings: Optional["_models.QueueSettings"] = None,
        resources: Optional["_models.JobResources"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.DISTILLATION  # type: ignore


class DistributionConfiguration(_Model):
    """Base definition for job distribution configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    Mpi, PyTorch, TensorFlow

    :ivar distribution_type: [Required] Specifies the type of distribution framework. Required.
     Known values are: "PyTorch", "TensorFlow", and "Mpi".
    :vartype distribution_type: str or ~azure.mgmt.machinelearningservices.models.DistributionType
    """

    __mapping__: dict[str, _Model] = {}
    distribution_type: str = rest_discriminator(name="distributionType", visibility=["read", "create"])
    """[Required] Specifies the type of distribution framework. Required. Known values are:
     \"PyTorch\", \"TensorFlow\", and \"Mpi\"."""

    @overload
    def __init__(
        self,
        *,
        distribution_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Docker(_Model):
    """Docker.

    :ivar privileged: Indicate whether container shall run in privileged or non-privileged mode.
    :vartype privileged: bool
    """

    privileged: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicate whether container shall run in privileged or non-privileged mode."""

    @overload
    def __init__(
        self,
        *,
        privileged: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DockerCredential(DataReferenceCredential, discriminator="DockerCredentials"):
    """Credential for docker with username and password.

    :ivar password: DockerCredential user password.
    :vartype password: str
    :ivar user_name: DockerCredential user name.
    :vartype user_name: str
    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credential_type: str or ~azure.mgmt.machinelearningservices.models.DOCKER_CREDENTIALS
    """

    password: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """DockerCredential user password."""
    user_name: Optional[str] = rest_field(name="userName", visibility=["read", "create", "update", "delete", "query"])
    """DockerCredential user name."""
    credential_type: Literal[DataReferenceCredentialType.DOCKER_CREDENTIALS] = rest_discriminator(name="credentialType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        password: Optional[str] = None,
        user_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credential_type = DataReferenceCredentialType.DOCKER_CREDENTIALS  # type: ignore


class EncryptionKeyVaultUpdateProperties(_Model):
    """EncryptionKeyVaultUpdateProperties.

    :ivar key_identifier: Required.
    :vartype key_identifier: str
    """

    key_identifier: str = rest_field(name="keyIdentifier", visibility=["read", "create", "update", "delete", "query"])
    """Required."""

    @overload
    def __init__(
        self,
        *,
        key_identifier: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EncryptionProperty(_Model):
    """EncryptionProperty.

    :ivar cosmos_db_resource_id: The byok cosmosdb account that customer brings to store customer's
     data
     with encryption.
    :vartype cosmos_db_resource_id: str
    :ivar identity: Identity to be used with the keyVault.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityForCmk
    :ivar key_vault_properties: KeyVault details to do the encryption. Required.
    :vartype key_vault_properties: ~azure.mgmt.machinelearningservices.models.KeyVaultProperties
    :ivar search_account_resource_id: The byok search account that customer brings to store
     customer's data
     with encryption.
    :vartype search_account_resource_id: str
    :ivar status: Indicates whether or not the encryption is enabled for the workspace. Required.
     Known values are: "Enabled" and "Disabled".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.EncryptionStatus
    :ivar storage_account_resource_id: The byok storage account that customer brings to store
     customer's data
     with encryption.
    :vartype storage_account_resource_id: str
    """

    cosmos_db_resource_id: Optional[str] = rest_field(
        name="cosmosDbResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The byok cosmosdb account that customer brings to store customer's data
     with encryption."""
    identity: Optional["_models.IdentityForCmk"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Identity to be used with the keyVault."""
    key_vault_properties: "_models.KeyVaultProperties" = rest_field(
        name="keyVaultProperties", visibility=["read", "create", "update", "delete", "query"]
    )
    """KeyVault details to do the encryption. Required."""
    search_account_resource_id: Optional[str] = rest_field(
        name="searchAccountResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The byok search account that customer brings to store customer's data
     with encryption."""
    status: Union[str, "_models.EncryptionStatus"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether or not the encryption is enabled for the workspace. Required. Known values
     are: \"Enabled\" and \"Disabled\"."""
    storage_account_resource_id: Optional[str] = rest_field(
        name="storageAccountResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The byok storage account that customer brings to store customer's data
     with encryption."""

    @overload
    def __init__(
        self,
        *,
        key_vault_properties: "_models.KeyVaultProperties",
        status: Union[str, "_models.EncryptionStatus"],
        cosmos_db_resource_id: Optional[str] = None,
        identity: Optional["_models.IdentityForCmk"] = None,
        search_account_resource_id: Optional[str] = None,
        storage_account_resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EncryptionUpdateProperties(_Model):
    """EncryptionUpdateProperties.

    :ivar key_vault_properties: Required.
    :vartype key_vault_properties:
     ~azure.mgmt.machinelearningservices.models.EncryptionKeyVaultUpdateProperties
    """

    key_vault_properties: "_models.EncryptionKeyVaultUpdateProperties" = rest_field(
        name="keyVaultProperties", visibility=["read", "create", "update", "delete", "query"]
    )
    """Required."""

    @overload
    def __init__(
        self,
        *,
        key_vault_properties: "_models.EncryptionKeyVaultUpdateProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Endpoint(_Model):
    """Endpoint.

    :ivar protocol: Endpoint Communication Protocol. Known values are: "tcp", "udp", and "http".
    :vartype protocol: str or ~azure.mgmt.machinelearningservices.models.Protocol
    :ivar name: Name of the Endpoint.
    :vartype name: str
    :ivar target: Application port inside the container.
    :vartype target: int
    :ivar published: Port over which the application is exposed from container.
    :vartype published: int
    :ivar host_ip: Host IP over which the application is exposed from the container.
    :vartype host_ip: str
    """

    protocol: Optional[Union[str, "_models.Protocol"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Endpoint Communication Protocol. Known values are: \"tcp\", \"udp\", and \"http\"."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of the Endpoint."""
    target: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Application port inside the container."""
    published: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Port over which the application is exposed from container."""
    host_ip: Optional[str] = rest_field(name="hostIp", visibility=["read", "create", "update", "delete", "query"])
    """Host IP over which the application is exposed from the container."""

    @overload
    def __init__(
        self,
        *,
        protocol: Optional[Union[str, "_models.Protocol"]] = None,
        name: Optional[str] = None,
        target: Optional[int] = None,
        published: Optional[int] = None,
        host_ip: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointAuthKeys(_Model):
    """Keys for endpoint authentication.

    :ivar primary_key: The primary key.
    :vartype primary_key: str
    :ivar secondary_key: The secondary key.
    :vartype secondary_key: str
    """

    primary_key: Optional[str] = rest_field(name="primaryKey", visibility=["read", "create"])
    """The primary key."""
    secondary_key: Optional[str] = rest_field(name="secondaryKey", visibility=["read", "create"])
    """The secondary key."""

    @overload
    def __init__(
        self,
        *,
        primary_key: Optional[str] = None,
        secondary_key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointAuthToken(_Model):
    """Service Token.

    :ivar access_token: Access token for endpoint authentication.
    :vartype access_token: str
    :ivar expiry_time_utc: Access token expiry time (UTC).
    :vartype expiry_time_utc: int
    :ivar refresh_after_time_utc: Refresh access token after time (UTC).
    :vartype refresh_after_time_utc: int
    :ivar token_type: Access token type.
    :vartype token_type: str
    """

    access_token: Optional[str] = rest_field(
        name="accessToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """Access token for endpoint authentication."""
    expiry_time_utc: Optional[int] = rest_field(
        name="expiryTimeUtc", visibility=["read", "create", "update", "delete", "query"]
    )
    """Access token expiry time (UTC)."""
    refresh_after_time_utc: Optional[int] = rest_field(
        name="refreshAfterTimeUtc", visibility=["read", "create", "update", "delete", "query"]
    )
    """Refresh access token after time (UTC)."""
    token_type: Optional[str] = rest_field(name="tokenType", visibility=["read", "create", "update", "delete", "query"])
    """Access token type."""

    @overload
    def __init__(
        self,
        *,
        access_token: Optional[str] = None,
        expiry_time_utc: Optional[int] = None,
        refresh_after_time_utc: Optional[int] = None,
        token_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointDeploymentModel(_Model):
    """EndpointDeploymentModel.

    :ivar format: Model format.
    :vartype format: str
    :ivar name: Model name.
    :vartype name: str
    :ivar source: Optional. Deployment model source ARM resource ID.
    :vartype source: str
    :ivar version: Model version.
    :vartype version: str
    """

    format: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model format."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model name."""
    source: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional. Deployment model source ARM resource ID."""
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model version."""

    @overload
    def __init__(
        self,
        *,
        format: Optional[str] = None,
        name: Optional[str] = None,
        source: Optional[str] = None,
        version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointDeploymentResourcePropertiesBasicResource(ProxyResource):  # pylint: disable=name-too-long
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Required.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourceProperties
    """

    properties: "_models.EndpointDeploymentResourceProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.EndpointDeploymentResourceProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointKeys(_Model):
    """EndpointKeys.

    :ivar keys_property: Dictionary of Keys for the endpoint.
    :vartype keys_property: ~azure.mgmt.machinelearningservices.models.AccountApiKeys
    """

    keys_property: Optional["_models.AccountApiKeys"] = rest_field(
        name="keys", visibility=["read", "create", "update", "delete", "query"], original_tsp_name="keys"
    )
    """Dictionary of Keys for the endpoint."""

    @overload
    def __init__(
        self,
        *,
        keys_property: Optional["_models.AccountApiKeys"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelDeprecationProperties(_Model):
    """EndpointModelDeprecationProperties.

    :ivar fine_tune: The datetime of deprecation of the fineTune Model.
    :vartype fine_tune: ~datetime.datetime
    :ivar inference: The datetime of deprecation of the inference Model.
    :vartype inference: ~datetime.datetime
    """

    fine_tune: Optional[datetime.datetime] = rest_field(
        name="fineTune", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The datetime of deprecation of the fineTune Model."""
    inference: Optional[datetime.datetime] = rest_field(
        visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The datetime of deprecation of the inference Model."""

    @overload
    def __init__(
        self,
        *,
        fine_tune: Optional[datetime.datetime] = None,
        inference: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelProperties(_Model):
    """Endpoint Model properties.

    :ivar capabilities: The capabilities.
    :vartype capabilities: dict[str, str]
    :ivar deprecation:
    :vartype deprecation:
     ~azure.mgmt.machinelearningservices.models.EndpointModelDeprecationProperties
    :ivar finetune_capabilities: The capabilities for finetune models.
    :vartype finetune_capabilities: dict[str, str]
    :ivar format: Deployment model format.
    :vartype format: str
    :ivar is_default_version: If the model is default version.
    :vartype is_default_version: bool
    :ivar lifecycle_status: Model lifecycle status. Known values are: "GenerallyAvailable" and
     "Preview".
    :vartype lifecycle_status: str or
     ~azure.mgmt.machinelearningservices.models.ModelLifecycleStatus
    :ivar max_capacity: The max capacity.
    :vartype max_capacity: int
    :ivar name: Deployment model name.
    :vartype name: str
    :ivar skus: The list of Model Sku.
    :vartype skus: list[~azure.mgmt.machinelearningservices.models.EndpointModelSkuProperties]
    :ivar system_data:
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar version: Optional. Deployment model version. If version is not specified, a default
     version will be assigned. The default version is different for different models and might
     change when there is new version available for a model. Default version for a model could be
     found from list models API.
    :vartype version: str
    """

    capabilities: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The capabilities."""
    deprecation: Optional["_models.EndpointModelDeprecationProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    finetune_capabilities: Optional[dict[str, str]] = rest_field(
        name="finetuneCapabilities", visibility=["read", "create", "update", "delete", "query"]
    )
    """The capabilities for finetune models."""
    format: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Deployment model format."""
    is_default_version: Optional[bool] = rest_field(
        name="isDefaultVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """If the model is default version."""
    lifecycle_status: Optional[Union[str, "_models.ModelLifecycleStatus"]] = rest_field(
        name="lifecycleStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """Model lifecycle status. Known values are: \"GenerallyAvailable\" and \"Preview\"."""
    max_capacity: Optional[int] = rest_field(
        name="maxCapacity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The max capacity."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Deployment model name."""
    skus: Optional[list["_models.EndpointModelSkuProperties"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of Model Sku."""
    system_data: Optional["_models.SystemData"] = rest_field(
        name="systemData", visibility=["read", "create", "update", "delete", "query"]
    )
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional. Deployment model version. If version is not specified, a default version will be
     assigned. The default version is different for different models and might change when there is
     new version available for a model. Default version for a model could be found from list models
     API."""

    @overload
    def __init__(
        self,
        *,
        capabilities: Optional[dict[str, str]] = None,
        deprecation: Optional["_models.EndpointModelDeprecationProperties"] = None,
        finetune_capabilities: Optional[dict[str, str]] = None,
        format: Optional[str] = None,
        is_default_version: Optional[bool] = None,
        lifecycle_status: Optional[Union[str, "_models.ModelLifecycleStatus"]] = None,
        max_capacity: Optional[int] = None,
        name: Optional[str] = None,
        skus: Optional[list["_models.EndpointModelSkuProperties"]] = None,
        system_data: Optional["_models.SystemData"] = None,
        version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModels(_Model):
    """Paged collection of EndpointModelProperties items.

    :ivar value: The EndpointModelProperties items on this page. Required.
    :vartype value: list[~azure.mgmt.machinelearningservices.models.EndpointModelProperties]
    :ivar next_link: The link to the next page of items.
    :vartype next_link: str
    """

    value: list["_models.EndpointModelProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The EndpointModelProperties items on this page. Required."""
    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read", "create", "update", "delete", "query"])
    """The link to the next page of items."""

    @overload
    def __init__(
        self,
        *,
        value: list["_models.EndpointModelProperties"],
        next_link: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelSkuCapacityProperties(_Model):
    """EndpointModelSkuCapacityProperties.

    :ivar default: The default capacity.
    :vartype default: int
    :ivar maximum: The maximum capacity.
    :vartype maximum: int
    """

    default: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The default capacity."""
    maximum: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The maximum capacity."""

    @overload
    def __init__(
        self,
        *,
        default: Optional[int] = None,
        maximum: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelSkuProperties(_Model):
    """EndpointModelSkuProperties.

    :ivar capacity:
    :vartype capacity:
     ~azure.mgmt.machinelearningservices.models.EndpointModelSkuCapacityProperties
    :ivar connection_ids: The list of ARM id for the connection support this SKU.
    :vartype connection_ids: list[str]
    :ivar deprecation_date: The datetime of deprecation of the model SKU.
    :vartype deprecation_date: ~datetime.datetime
    :ivar name: The name of the model SKU.
    :vartype name: str
    :ivar rate_limits:
    :vartype rate_limits:
     list[~azure.mgmt.machinelearningservices.models.EndpointModelSkuRateLimitProperties]
    :ivar usage_name: The usage name of the model SKU.
    :vartype usage_name: str
    """

    capacity: Optional["_models.EndpointModelSkuCapacityProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    connection_ids: Optional[list[str]] = rest_field(
        name="connectionIds", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of ARM id for the connection support this SKU."""
    deprecation_date: Optional[datetime.datetime] = rest_field(
        name="deprecationDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The datetime of deprecation of the model SKU."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the model SKU."""
    rate_limits: Optional[list["_models.EndpointModelSkuRateLimitProperties"]] = rest_field(
        name="rateLimits", visibility=["read", "create", "update", "delete", "query"]
    )
    usage_name: Optional[str] = rest_field(name="usageName", visibility=["read", "create", "update", "delete", "query"])
    """The usage name of the model SKU."""

    @overload
    def __init__(
        self,
        *,
        capacity: Optional["_models.EndpointModelSkuCapacityProperties"] = None,
        connection_ids: Optional[list[str]] = None,
        deprecation_date: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        rate_limits: Optional[list["_models.EndpointModelSkuRateLimitProperties"]] = None,
        usage_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelSkuRateLimitProperties(_Model):
    """EndpointModelSkuRateLimitProperties.

    :ivar count: The count value of Call Rate Limit.
    :vartype count: float
    :ivar renewal_period: The renewal period in seconds of Call Rate Limit.
    :vartype renewal_period: float
    :ivar rules: The call rate limit for the model.
    :vartype rules:
     list[~azure.mgmt.machinelearningservices.models.EndpointModelSkuRateLimitRuleProperties]
    """

    count: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The count value of Call Rate Limit."""
    renewal_period: Optional[float] = rest_field(
        name="renewalPeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The renewal period in seconds of Call Rate Limit."""
    rules: Optional[list["_models.EndpointModelSkuRateLimitRuleProperties"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The call rate limit for the model."""

    @overload
    def __init__(
        self,
        *,
        count: Optional[float] = None,
        renewal_period: Optional[float] = None,
        rules: Optional[list["_models.EndpointModelSkuRateLimitRuleProperties"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelSkuRateLimitRulePatternProperties(_Model):  # pylint: disable=name-too-long
    """EndpointModelSkuRateLimitRulePatternProperties.

    :ivar method:
    :vartype method: str
    :ivar path:
    :vartype path: str
    """

    method: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    path: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        method: Optional[str] = None,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointModelSkuRateLimitRuleProperties(_Model):
    """EndpointModelSkuRateLimitRuleProperties.

    :ivar count:
    :vartype count: float
    :ivar dynamic_throttling_enabled: If the dynamic throttling is enabled.
    :vartype dynamic_throttling_enabled: bool
    :ivar key:
    :vartype key: str
    :ivar match_patterns:
    :vartype match_patterns:
     list[~azure.mgmt.machinelearningservices.models.EndpointModelSkuRateLimitRulePatternProperties]
    :ivar min_count:
    :vartype min_count: float
    :ivar renewal_period:
    :vartype renewal_period: float
    """

    count: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    dynamic_throttling_enabled: Optional[bool] = rest_field(
        name="dynamicThrottlingEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """If the dynamic throttling is enabled."""
    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    match_patterns: Optional[list["_models.EndpointModelSkuRateLimitRulePatternProperties"]] = rest_field(
        name="matchPatterns", visibility=["read", "create", "update", "delete", "query"]
    )
    min_count: Optional[float] = rest_field(name="minCount", visibility=["read", "create", "update", "delete", "query"])
    renewal_period: Optional[float] = rest_field(
        name="renewalPeriod", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        count: Optional[float] = None,
        dynamic_throttling_enabled: Optional[bool] = None,
        key: Optional[str] = None,
        match_patterns: Optional[list["_models.EndpointModelSkuRateLimitRulePatternProperties"]] = None,
        min_count: Optional[float] = None,
        renewal_period: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointResourcePropertiesBasicResource(ProxyResource):
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.EndpointResourceProperties
    """

    properties: "_models.EndpointResourceProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.EndpointResourceProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EndpointScheduleAction(ScheduleActionBase, discriminator="InvokeBatchEndpoint"):
    """EndpointScheduleAction.

    :ivar endpoint_invocation_definition: [Required] Defines Schedule action definition details.
     <see href="TBD" />. Required.
    :vartype endpoint_invocation_definition: dict[str, any]
    :ivar action_type: [Required] Specifies the action type of the schedule. Required.
    :vartype action_type: str or ~azure.mgmt.machinelearningservices.models.INVOKE_BATCH_ENDPOINT
    """

    endpoint_invocation_definition: dict[str, Any] = rest_field(
        name="endpointInvocationDefinition", visibility=["read", "create", "update"]
    )
    """[Required] Defines Schedule action definition details.
     <see href=\"TBD\" />. Required."""
    action_type: Literal[ScheduleActionType.INVOKE_BATCH_ENDPOINT] = rest_discriminator(name="actionType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the action type of the schedule. Required."""

    @overload
    def __init__(
        self,
        *,
        endpoint_invocation_definition: dict[str, Any],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.action_type = ScheduleActionType.INVOKE_BATCH_ENDPOINT  # type: ignore


class EnvironmentContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.EnvironmentContainerProperties
    """

    properties: "_models.EnvironmentContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.EnvironmentContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EnvironmentContainerProperties(AssetContainer):
    """Container for environment specification versions.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the environment container. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the environment container. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EnvironmentVariable(_Model):
    """EnvironmentVariable.

    :ivar type: Type of Environment Variable. "local"
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.EnvironmentVariableType
    :ivar value: Value of the Environment variable.
    :vartype value: str
    """

    type: Optional[Union[str, "_models.EnvironmentVariableType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of Environment Variable. \"local\""""
    value: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of the Environment variable."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.EnvironmentVariableType"]] = None,
        value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EnvironmentVersion(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.EnvironmentVersionProperties
    """

    properties: "_models.EnvironmentVersionProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.EnvironmentVersionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EnvironmentVersionProperties(AssetBase):
    """Environment version details.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar auto_rebuild: AutoRebuild setting for the derived image. Known values are: "Disabled" and
     "OnBaseImageUpdate".
    :vartype auto_rebuild: str or ~azure.mgmt.machinelearningservices.models.AutoRebuildSetting
    :ivar build: Configuration settings for Docker build context.
    :vartype build: ~azure.mgmt.machinelearningservices.models.BuildContext
    :ivar conda_file: Standard configuration file used by Conda that lets you install any kind of
     package, including Python, R, and C/C++ packages.
     <see
     href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment"
     />.
    :vartype conda_file: str
    :ivar environment_type: Environment type is either user managed or curated by the Azure ML
     service
     <see
     href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments"
     />. Known values are: "Curated" and "UserCreated".
    :vartype environment_type: str or ~azure.mgmt.machinelearningservices.models.EnvironmentType
    :ivar image: Name of the image that will be used for the environment.
     <seealso
     href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image"
     />.
    :vartype image: str
    :ivar image_details: Environment image details.
    :vartype image_details: ~azure.mgmt.machinelearningservices.models.ImageDetails
    :ivar inference_config: Defines configuration specific to inference.
    :vartype inference_config:
     ~azure.mgmt.machinelearningservices.models.InferenceContainerProperties
    :ivar os_type: The type of operating system. Known values are: "Linux" and "Windows".
    :vartype os_type: str or ~azure.mgmt.machinelearningservices.models.OperatingSystemType
    :ivar provisioning_state: Provisioning state for the environment version. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    :ivar stage: Stage in the environment lifecycle assigned to this environment.
    :vartype stage: str
    """

    auto_rebuild: Optional[Union[str, "_models.AutoRebuildSetting"]] = rest_field(
        name="autoRebuild", visibility=["read", "create"]
    )
    """AutoRebuild setting for the derived image. Known values are: \"Disabled\" and
     \"OnBaseImageUpdate\"."""
    build: Optional["_models.BuildContext"] = rest_field(visibility=["read", "create"])
    """Configuration settings for Docker build context."""
    conda_file: Optional[str] = rest_field(name="condaFile", visibility=["read", "create"])
    """Standard configuration file used by Conda that lets you install any kind of package, including
     Python, R, and C/C++ packages.
     <see
     href=\"https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment\"
     />."""
    environment_type: Optional[Union[str, "_models.EnvironmentType"]] = rest_field(
        name="environmentType", visibility=["read"]
    )
    """Environment type is either user managed or curated by the Azure ML service
     <see
     href=\"https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments\"
     />. Known values are: \"Curated\" and \"UserCreated\"."""
    image: Optional[str] = rest_field(visibility=["read", "create"])
    """Name of the image that will be used for the environment.
     <seealso
     href=\"https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image\"
     />."""
    image_details: Optional["_models.ImageDetails"] = rest_field(
        name="imageDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """Environment image details."""
    inference_config: Optional["_models.InferenceContainerProperties"] = rest_field(
        name="inferenceConfig", visibility=["read", "create"]
    )
    """Defines configuration specific to inference."""
    os_type: Optional[Union[str, "_models.OperatingSystemType"]] = rest_field(
        name="osType", visibility=["read", "create"]
    )
    """The type of operating system. Known values are: \"Linux\" and \"Windows\"."""
    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the environment version. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    stage: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Stage in the environment lifecycle assigned to this environment."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        auto_rebuild: Optional[Union[str, "_models.AutoRebuildSetting"]] = None,
        build: Optional["_models.BuildContext"] = None,
        conda_file: Optional[str] = None,
        image: Optional[str] = None,
        image_details: Optional["_models.ImageDetails"] = None,
        inference_config: Optional["_models.InferenceContainerProperties"] = None,
        os_type: Optional[Union[str, "_models.OperatingSystemType"]] = None,
        stage: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorAdditionalInfo(_Model):
    """The resource management error additional info.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    type: Optional[str] = rest_field(visibility=["read"])
    """The additional info type."""
    info: Optional[Any] = rest_field(visibility=["read"])
    """The additional info."""


class ErrorDetail(_Model):
    """The error detail.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.mgmt.machinelearningservices.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.mgmt.machinelearningservices.models.ErrorAdditionalInfo]
    """

    code: Optional[str] = rest_field(visibility=["read"])
    """The error code."""
    message: Optional[str] = rest_field(visibility=["read"])
    """The error message."""
    target: Optional[str] = rest_field(visibility=["read"])
    """The error target."""
    details: Optional[list["_models.ErrorDetail"]] = rest_field(visibility=["read"])
    """The error details."""
    additional_info: Optional[list["_models.ErrorAdditionalInfo"]] = rest_field(
        name="additionalInfo", visibility=["read"]
    )
    """The error additional info."""


class ErrorResponse(_Model):
    """Error response.

    :ivar error: The error object.
    :vartype error: ~azure.mgmt.machinelearningservices.models.ErrorDetail
    """

    error: Optional["_models.ErrorDetail"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error object."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetail"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EstimatedVMPrice(_Model):
    """The estimated price info for using a VM of a particular OS type, tier, etc.

    :ivar retail_price: Retail price. Required.
    :vartype retail_price: float
    :ivar os_type: OS type. Required. Known values are: "Linux" and "Windows".
    :vartype os_type: str or ~azure.mgmt.machinelearningservices.models.VMPriceOSType
    :ivar vm_tier: VM tier. Required. Known values are: "Standard", "LowPriority", and "Spot".
    :vartype vm_tier: str or ~azure.mgmt.machinelearningservices.models.VMTier
    """

    retail_price: float = rest_field(name="retailPrice", visibility=["read", "create", "update", "delete", "query"])
    """Retail price. Required."""
    os_type: Union[str, "_models.VMPriceOSType"] = rest_field(
        name="osType", visibility=["read", "create", "update", "delete", "query"]
    )
    """OS type. Required. Known values are: \"Linux\" and \"Windows\"."""
    vm_tier: Union[str, "_models.VMTier"] = rest_field(
        name="vmTier", visibility=["read", "create", "update", "delete", "query"]
    )
    """VM tier. Required. Known values are: \"Standard\", \"LowPriority\", and \"Spot\"."""

    @overload
    def __init__(
        self,
        *,
        retail_price: float,
        os_type: Union[str, "_models.VMPriceOSType"],
        vm_tier: Union[str, "_models.VMTier"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EstimatedVMPrices(_Model):
    """The estimated price info for using a VM.

    :ivar billing_currency: Billing currency. Required. "USD"
    :vartype billing_currency: str or ~azure.mgmt.machinelearningservices.models.BillingCurrency
    :ivar unit_of_measure: Unit of time measure. Required. "OneHour"
    :vartype unit_of_measure: str or ~azure.mgmt.machinelearningservices.models.UnitOfMeasure
    :ivar values_property: List of estimated VM prices. Required.
    :vartype values_property: list[~azure.mgmt.machinelearningservices.models.EstimatedVMPrice]
    """

    billing_currency: Union[str, "_models.BillingCurrency"] = rest_field(
        name="billingCurrency", visibility=["read", "create", "update", "delete", "query"]
    )
    """Billing currency. Required. \"USD\""""
    unit_of_measure: Union[str, "_models.UnitOfMeasure"] = rest_field(
        name="unitOfMeasure", visibility=["read", "create", "update", "delete", "query"]
    )
    """Unit of time measure. Required. \"OneHour\""""
    values_property: list["_models.EstimatedVMPrice"] = rest_field(
        name="values", visibility=["read", "create", "update", "delete", "query"], original_tsp_name="values"
    )
    """List of estimated VM prices. Required."""

    @overload
    def __init__(
        self,
        *,
        billing_currency: Union[str, "_models.BillingCurrency"],
        unit_of_measure: Union[str, "_models.UnitOfMeasure"],
        values_property: list["_models.EstimatedVMPrice"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExternalFQDNResponse(_Model):
    """ExternalFQDNResponse.

    :ivar value:
    :vartype value: list[~azure.mgmt.machinelearningservices.models.FQDNEndpointsPropertyBag]
    """

    value: Optional[list["_models.FQDNEndpointsPropertyBag"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        value: Optional[list["_models.FQDNEndpointsPropertyBag"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Feature(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.FeatureProperties
    """

    properties: "_models.FeatureProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.FeatureProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeatureAttributionDriftMonitoringSignal(MonitoringSignalBase, discriminator="FeatureAttributionDrift"):
    """FeatureAttributionDriftMonitoringSignal.

    :ivar notification_types: The current notification mode for this signal.
    :vartype notification_types: list[str or
     ~azure.mgmt.machinelearningservices.models.MonitoringNotificationType]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar feature_data_type_override: A dictionary that maps feature names to their respective data
     types.
    :vartype feature_data_type_override: dict[str, str or
     ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType]
    :ivar feature_importance_settings: [Required] The settings for computing feature importance.
     Required.
    :vartype feature_importance_settings:
     ~azure.mgmt.machinelearningservices.models.FeatureImportanceSettings
    :ivar metric_threshold: [Required] A list of metrics to calculate and their associated
     thresholds. Required.
    :vartype metric_threshold:
     ~azure.mgmt.machinelearningservices.models.FeatureAttributionMetricThreshold
    :ivar production_data: [Required] The data which drift will be calculated for. Required.
    :vartype production_data:
     list[~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase]
    :ivar reference_data: [Required] The data to calculate drift against. Required.
    :vartype reference_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar signal_type: [Required] Specifies the type of signal to monitor. Required. Tracks feature
     importance change in production, comparing against feature importance at training time.
    :vartype signal_type: str or
     ~azure.mgmt.machinelearningservices.models.FEATURE_ATTRIBUTION_DRIFT
    """

    feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = rest_field(
        name="featureDataTypeOverride", visibility=["read", "create"]
    )
    """A dictionary that maps feature names to their respective data types."""
    feature_importance_settings: "_models.FeatureImportanceSettings" = rest_field(
        name="featureImportanceSettings", visibility=["read", "create"]
    )
    """[Required] The settings for computing feature importance. Required."""
    metric_threshold: "_models.FeatureAttributionMetricThreshold" = rest_field(
        name="metricThreshold", visibility=["read", "create"]
    )
    """[Required] A list of metrics to calculate and their associated thresholds. Required."""
    production_data: list["_models.MonitoringInputDataBase"] = rest_field(
        name="productionData", visibility=["read", "create"]
    )
    """[Required] The data which drift will be calculated for. Required."""
    reference_data: "_models.MonitoringInputDataBase" = rest_field(name="referenceData", visibility=["read", "create"])
    """[Required] The data to calculate drift against. Required."""
    signal_type: Literal[MonitoringSignalType.FEATURE_ATTRIBUTION_DRIFT] = rest_discriminator(name="signalType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. Tracks feature importance change
     in production, comparing against feature importance at training time."""

    @overload
    def __init__(
        self,
        *,
        feature_importance_settings: "_models.FeatureImportanceSettings",
        metric_threshold: "_models.FeatureAttributionMetricThreshold",
        production_data: list["_models.MonitoringInputDataBase"],
        reference_data: "_models.MonitoringInputDataBase",
        notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = None,
        properties: Optional[dict[str, str]] = None,
        feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.signal_type = MonitoringSignalType.FEATURE_ATTRIBUTION_DRIFT  # type: ignore


class FeatureAttributionMetricThreshold(_Model):
    """FeatureAttributionMetricThreshold.

    :ivar metric: [Required] The feature attribution metric to calculate. Required.
     "NormalizedDiscountedCumulativeGain"
    :vartype metric: str or ~azure.mgmt.machinelearningservices.models.FeatureAttributionMetric
    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    """

    metric: Union[str, "_models.FeatureAttributionMetric"] = rest_field(visibility=["read", "create"])
    """[Required] The feature attribution metric to calculate. Required.
     \"NormalizedDiscountedCumulativeGain\""""
    threshold: Optional["_models.MonitoringThreshold"] = rest_field(visibility=["read", "create"])
    """The threshold value. If null, a default value will be set depending on the selected metric."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.FeatureAttributionMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeatureImportanceSettings(_Model):
    """FeatureImportanceSettings.

    :ivar mode: The mode of operation for computing feature importance. Known values are:
     "Disabled" and "Enabled".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.FeatureImportanceMode
    :ivar target_column: The name of the target column within the input data asset.
    :vartype target_column: str
    """

    mode: Optional[Union[str, "_models.FeatureImportanceMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The mode of operation for computing feature importance. Known values are: \"Disabled\" and
     \"Enabled\"."""
    target_column: Optional[str] = rest_field(
        name="targetColumn", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the target column within the input data asset."""

    @overload
    def __init__(
        self,
        *,
        mode: Optional[Union[str, "_models.FeatureImportanceMode"]] = None,
        target_column: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeatureProperties(ResourceBase):
    """DTO object representing feature.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar data_type: Specifies type. Known values are: "String", "Integer", "Long", "Float",
     "Double", "Binary", "Datetime", and "Boolean".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.FeatureDataType
    :ivar feature_name: Specifies name.
    :vartype feature_name: str
    """

    data_type: Optional[Union[str, "_models.FeatureDataType"]] = rest_field(
        name="dataType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies type. Known values are: \"String\", \"Integer\", \"Long\", \"Float\", \"Double\",
     \"Binary\", \"Datetime\", and \"Boolean\"."""
    feature_name: Optional[str] = rest_field(
        name="featureName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies name."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        data_type: Optional[Union[str, "_models.FeatureDataType"]] = None,
        feature_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.FeaturesetContainerProperties
    """

    properties: "_models.FeaturesetContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.FeaturesetContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetContainerProperties(AssetContainer):
    """DTO object representing feature set.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the featureset container. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the featureset container. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetSpecification(_Model):
    """DTO object representing specification.

    :ivar path: Specifies the spec path.
    :vartype path: str
    """

    path: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the spec path."""

    @overload
    def __init__(
        self,
        *,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetVersion(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.FeaturesetVersionProperties
    """

    properties: "_models.FeaturesetVersionProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.FeaturesetVersionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetVersionBackfillRequest(_Model):
    """Request payload for creating a backfill request for a given feature set version.

    :ivar data_availability_status: Specified the data availability status that you want to
     backfill.
    :vartype data_availability_status: list[str or
     ~azure.mgmt.machinelearningservices.models.DataAvailabilityStatus]
    :ivar description: Specifies description.
    :vartype description: str
    :ivar display_name: Specifies description.
    :vartype display_name: str
    :ivar feature_window: Specifies the backfill feature window to be materialized.
    :vartype feature_window: ~azure.mgmt.machinelearningservices.models.FeatureWindow
    :ivar job_id: Specify the jobId to retry the failed materialization.
    :vartype job_id: str
    :ivar properties: Specifies the properties.
    :vartype properties: dict[str, str]
    :ivar resource: Specifies the compute resource settings.
    :vartype resource: ~azure.mgmt.machinelearningservices.models.MaterializationComputeResource
    :ivar spark_configuration: Specifies the spark compute settings.
    :vartype spark_configuration: dict[str, str]
    :ivar tags: Specifies the tags.
    :vartype tags: dict[str, str]
    """

    data_availability_status: Optional[list[Union[str, "_models.DataAvailabilityStatus"]]] = rest_field(
        name="dataAvailabilityStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specified the data availability status that you want to backfill."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies description."""
    display_name: Optional[str] = rest_field(
        name="displayName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies description."""
    feature_window: Optional["_models.FeatureWindow"] = rest_field(
        name="featureWindow", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the backfill feature window to be materialized."""
    job_id: Optional[str] = rest_field(name="jobId", visibility=["read", "create", "update", "delete", "query"])
    """Specify the jobId to retry the failed materialization."""
    properties: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the properties."""
    resource: Optional["_models.MaterializationComputeResource"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the compute resource settings."""
    spark_configuration: Optional[dict[str, str]] = rest_field(
        name="sparkConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the spark compute settings."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the tags."""

    @overload
    def __init__(
        self,
        *,
        data_availability_status: Optional[list[Union[str, "_models.DataAvailabilityStatus"]]] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        feature_window: Optional["_models.FeatureWindow"] = None,
        job_id: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        resource: Optional["_models.MaterializationComputeResource"] = None,
        spark_configuration: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetVersionBackfillResponse(_Model):
    """Response payload for creating a backfill request for a given feature set version.

    :ivar job_ids: List of jobs submitted as part of the backfill request.
    :vartype job_ids: list[str]
    """

    job_ids: Optional[list[str]] = rest_field(name="jobIds", visibility=["read", "create", "update", "delete", "query"])
    """List of jobs submitted as part of the backfill request."""

    @overload
    def __init__(
        self,
        *,
        job_ids: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturesetVersionProperties(AssetBase):
    """DTO object representing feature set version.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar entities: Specifies list of entities.
    :vartype entities: list[str]
    :ivar materialization_settings: Specifies the materialization settings.
    :vartype materialization_settings:
     ~azure.mgmt.machinelearningservices.models.MaterializationSettings
    :ivar provisioning_state: Provisioning state for the featureset version container. Known values
     are: "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    :ivar specification: Specifies the feature spec details.
    :vartype specification: ~azure.mgmt.machinelearningservices.models.FeaturesetSpecification
    :ivar stage: Specifies the asset stage.
    :vartype stage: str
    """

    entities: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies list of entities."""
    materialization_settings: Optional["_models.MaterializationSettings"] = rest_field(
        name="materializationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the materialization settings."""
    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the featureset version container. Known values are: \"Succeeded\",
     \"Failed\", \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    specification: Optional["_models.FeaturesetSpecification"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the feature spec details."""
    stage: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the asset stage."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        entities: Optional[list[str]] = None,
        materialization_settings: Optional["_models.MaterializationSettings"] = None,
        specification: Optional["_models.FeaturesetSpecification"] = None,
        stage: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturestoreEntityContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.FeaturestoreEntityContainerProperties
    """

    properties: "_models.FeaturestoreEntityContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.FeaturestoreEntityContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturestoreEntityContainerProperties(AssetContainer):
    """DTO object representing feature entity.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the featurestore entity container. Known
     values are: "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the featurestore entity container. Known values are: \"Succeeded\",
     \"Failed\", \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturestoreEntityVersion(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.FeaturestoreEntityVersionProperties
    """

    properties: "_models.FeaturestoreEntityVersionProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.FeaturestoreEntityVersionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturestoreEntityVersionProperties(AssetBase):
    """DTO object representing feature entity version.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar index_columns: Specifies index columns.
    :vartype index_columns: list[~azure.mgmt.machinelearningservices.models.IndexColumn]
    :ivar provisioning_state: Provisioning state for the featurestore entity version. Known values
     are: "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    :ivar stage: Specifies the asset stage.
    :vartype stage: str
    """

    index_columns: Optional[list["_models.IndexColumn"]] = rest_field(
        name="indexColumns", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies index columns."""
    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the featurestore entity version. Known values are: \"Succeeded\",
     \"Failed\", \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    stage: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the asset stage."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        index_columns: Optional[list["_models.IndexColumn"]] = None,
        stage: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeatureStoreSettings(_Model):
    """FeatureStoreSettings.

    :ivar compute_runtime:
    :vartype compute_runtime: ~azure.mgmt.machinelearningservices.models.ComputeRuntimeDto
    :ivar offline_store_connection_name:
    :vartype offline_store_connection_name: str
    :ivar online_store_connection_name:
    :vartype online_store_connection_name: str
    """

    compute_runtime: Optional["_models.ComputeRuntimeDto"] = rest_field(
        name="computeRuntime", visibility=["read", "create", "update", "delete", "query"]
    )
    offline_store_connection_name: Optional[str] = rest_field(
        name="offlineStoreConnectionName", visibility=["read", "create", "update", "delete", "query"]
    )
    online_store_connection_name: Optional[str] = rest_field(
        name="onlineStoreConnectionName", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        compute_runtime: Optional["_models.ComputeRuntimeDto"] = None,
        offline_store_connection_name: Optional[str] = None,
        online_store_connection_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeatureSubset(MonitoringFeatureFilterBase, discriminator="FeatureSubset"):
    """FeatureSubset.

    :ivar features: [Required] The list of features to include. Required.
    :vartype features: list[str]
    :ivar filter_type: [Required] Specifies the feature filter to leverage when selecting features
     to calculate metrics over. Required. Includes a user-defined subset of features.
    :vartype filter_type: str or ~azure.mgmt.machinelearningservices.models.FEATURE_SUBSET
    """

    features: list[str] = rest_field(visibility=["read", "create"])
    """[Required] The list of features to include. Required."""
    filter_type: Literal[MonitoringFeatureFilterType.FEATURE_SUBSET] = rest_discriminator(name="filterType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the feature filter to leverage when selecting features to calculate
     metrics over. Required. Includes a user-defined subset of features."""

    @overload
    def __init__(
        self,
        *,
        features: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.filter_type = MonitoringFeatureFilterType.FEATURE_SUBSET  # type: ignore


class FeatureWindow(_Model):
    """Specifies the feature window.

    :ivar feature_window_end: Specifies the feature window end time.
    :vartype feature_window_end: ~datetime.datetime
    :ivar feature_window_start: Specifies the feature window start time.
    :vartype feature_window_start: ~datetime.datetime
    """

    feature_window_end: Optional[datetime.datetime] = rest_field(
        name="featureWindowEnd", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Specifies the feature window end time."""
    feature_window_start: Optional[datetime.datetime] = rest_field(
        name="featureWindowStart", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Specifies the feature window start time."""

    @overload
    def __init__(
        self,
        *,
        feature_window_end: Optional[datetime.datetime] = None,
        feature_window_start: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FeaturizationSettings(_Model):
    """Featurization Configuration.

    :ivar dataset_language: Dataset language, useful for the text data.
    :vartype dataset_language: str
    """

    dataset_language: Optional[str] = rest_field(
        name="datasetLanguage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Dataset language, useful for the text data."""

    @overload
    def __init__(
        self,
        *,
        dataset_language: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FinetuningDetails(_Model):
    """FinetuningDetails.

    :ivar hyper_parameters: Finetuning Hyperparameters.
    :vartype hyper_parameters: dict[str, str]
    :ivar student_model: [Required] Student model for fine tuning. Required.
    :vartype student_model: ~azure.mgmt.machinelearningservices.models.JobInput
    """

    hyper_parameters: Optional[dict[str, str]] = rest_field(
        name="hyperParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Finetuning Hyperparameters."""
    student_model: "_models.JobInput" = rest_field(
        name="studentModel", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Student model for fine tuning. Required."""

    @overload
    def __init__(
        self,
        *,
        student_model: "_models.JobInput",
        hyper_parameters: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FineTuningJob(JobBaseProperties, discriminator="FineTuning"):
    """FineTuning Job definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar fine_tuning_details: [Required]. Required.
    :vartype fine_tuning_details: ~azure.mgmt.machinelearningservices.models.FineTuningVertical
    :ivar outputs: [Required]. Required.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar queue_settings: Queue settings for the job.
    :vartype queue_settings: ~azure.mgmt.machinelearningservices.models.QueueSettings
    :ivar resources: Instance types and other resources for the job.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.JobResources
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.FINE_TUNING
    """

    fine_tuning_details: "_models.FineTuningVertical" = rest_field(
        name="fineTuningDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required]. Required."""
    outputs: dict[str, "_models.JobOutput"] = rest_field(visibility=["read", "create"])
    """[Required]. Required."""
    queue_settings: Optional["_models.QueueSettings"] = rest_field(name="queueSettings", visibility=["read", "create"])
    """Queue settings for the job."""
    resources: Optional["_models.JobResources"] = rest_field(visibility=["read", "create"])
    """Instance types and other resources for the job."""
    job_type: Literal[JobType.FINE_TUNING] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        fine_tuning_details: "_models.FineTuningVertical",
        outputs: dict[str, "_models.JobOutput"],
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        queue_settings: Optional["_models.QueueSettings"] = None,
        resources: Optional["_models.JobResources"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.FINE_TUNING  # type: ignore


class MonitoringInputDataBase(_Model):
    """Monitoring input data base definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    FixedInputData, RollingInputData, StaticInputData

    :ivar columns: Mapping of column names to special uses.
    :vartype columns: dict[str, str]
    :ivar data_context: The context metadata of the data source.
    :vartype data_context: str
    :ivar input_data_type: [Required] Specifies the type of signal to monitor. Required. Known
     values are: "Static", "Rolling", and "Fixed".
    :vartype input_data_type: str or
     ~azure.mgmt.machinelearningservices.models.MonitoringInputDataType
    :ivar job_input_type: [Required] Specifies the type of job. Required. Known values are:
     "literal", "uri_file", "uri_folder", "mltable", "custom_model", "mlflow_model", and
     "triton_model".
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.JobInputType
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    """

    __mapping__: dict[str, _Model] = {}
    columns: Optional[dict[str, str]] = rest_field(visibility=["read", "create"])
    """Mapping of column names to special uses."""
    data_context: Optional[str] = rest_field(name="dataContext", visibility=["read", "create"])
    """The context metadata of the data source."""
    input_data_type: str = rest_discriminator(name="inputDataType", visibility=["read", "create"])
    """[Required] Specifies the type of signal to monitor. Required. Known values are: \"Static\",
     \"Rolling\", and \"Fixed\"."""
    job_input_type: Union[str, "_models.JobInputType"] = rest_field(name="jobInputType", visibility=["read", "create"])
    """[Required] Specifies the type of job. Required. Known values are: \"literal\", \"uri_file\",
     \"uri_folder\", \"mltable\", \"custom_model\", \"mlflow_model\", and \"triton_model\"."""
    uri: str = rest_field(visibility=["read", "create"])
    """[Required] Input Asset URI. Required."""

    @overload
    def __init__(
        self,
        *,
        input_data_type: str,
        job_input_type: Union[str, "_models.JobInputType"],
        uri: str,
        columns: Optional[dict[str, str]] = None,
        data_context: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FixedInputData(MonitoringInputDataBase, discriminator="Fixed"):
    """Fixed input data definition.

    :ivar columns: Mapping of column names to special uses.
    :vartype columns: dict[str, str]
    :ivar data_context: The context metadata of the data source.
    :vartype data_context: str
    :ivar job_input_type: [Required] Specifies the type of job. Required. Known values are:
     "literal", "uri_file", "uri_folder", "mltable", "custom_model", "mlflow_model", and
     "triton_model".
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.JobInputType
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar input_data_type: [Required] Specifies the type of signal to monitor. Required. An input
     data with tabular format which doesn't require preprocessing.
    :vartype input_data_type: str or ~azure.mgmt.machinelearningservices.models.FIXED
    """

    input_data_type: Literal[MonitoringInputDataType.FIXED] = rest_discriminator(name="inputDataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. An input data with tabular format
     which doesn't require preprocessing."""

    @overload
    def __init__(
        self,
        *,
        job_input_type: Union[str, "_models.JobInputType"],
        uri: str,
        columns: Optional[dict[str, str]] = None,
        data_context: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.input_data_type = MonitoringInputDataType.FIXED  # type: ignore


class FlavorData(_Model):
    """FlavorData.

    :ivar data: Model flavor-specific data.
    :vartype data: dict[str, str]
    """

    data: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model flavor-specific data."""

    @overload
    def __init__(
        self,
        *,
        data: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Forecasting(AutoMLVertical, discriminator="Forecasting"):
    """Forecasting task in AutoML Table vertical.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar cv_split_column_names: Columns to use for CVSplit data.
    :vartype cv_split_column_names: list[str]
    :ivar featurization_settings: Featurization inputs needed for AutoML job.
    :vartype featurization_settings:
     ~azure.mgmt.machinelearningservices.models.TableVerticalFeaturizationSettings
    :ivar limit_settings: Execution constraints for AutoMLJob.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.TableVerticalLimitSettings
    :ivar n_cross_validations: Number of cross validation folds to be applied on training dataset
     when validation dataset is not provided.
    :vartype n_cross_validations: ~azure.mgmt.machinelearningservices.models.NCrossValidations
    :ivar test_data: Test data input.
    :vartype test_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar test_data_size: The fraction of test dataset that needs to be set aside for validation
     purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype test_data_size: float
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar weight_column_name: The name of the sample weight column. Automated ML supports a
     weighted column as an input, causing rows in the data to be weighted up or down.
    :vartype weight_column_name: str
    :ivar forecasting_settings: Forecasting task specific inputs.
    :vartype forecasting_settings: ~azure.mgmt.machinelearningservices.models.ForecastingSettings
    :ivar primary_metric: Primary metrics for Forecasting task. Known values are:
     "SpearmanCorrelation", "NormalizedRootMeanSquaredError", "R2Score", and
     "NormalizedMeanAbsoluteError".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ForecastingPrimaryMetrics
    :ivar training_settings: Inputs for training phase for an AutoML Job.
    :vartype training_settings:
     ~azure.mgmt.machinelearningservices.models.ForecastingTrainingSettings
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Forecasting is a special kind of
     regression task that deals with time-series data and creates forecasting model
     that can be used to predict the near future values based on the inputs.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.FORECASTING
    """

    cv_split_column_names: Optional[list[str]] = rest_field(
        name="cvSplitColumnNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """Columns to use for CVSplit data."""
    featurization_settings: Optional["_models.TableVerticalFeaturizationSettings"] = rest_field(
        name="featurizationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization inputs needed for AutoML job."""
    limit_settings: Optional["_models.TableVerticalLimitSettings"] = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Execution constraints for AutoMLJob."""
    n_cross_validations: Optional["_models.NCrossValidations"] = rest_field(
        name="nCrossValidations", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of cross validation folds to be applied on training dataset
     when validation dataset is not provided."""
    test_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="testData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Test data input."""
    test_data_size: Optional[float] = rest_field(
        name="testDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of test dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    weight_column_name: Optional[str] = rest_field(
        name="weightColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the sample weight column. Automated ML supports a weighted column as an input,
     causing rows in the data to be weighted up or down."""
    forecasting_settings: Optional["_models.ForecastingSettings"] = rest_field(
        name="forecastingSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Forecasting task specific inputs."""
    primary_metric: Optional[Union[str, "_models.ForecastingPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for Forecasting task. Known values are: \"SpearmanCorrelation\",
     \"NormalizedRootMeanSquaredError\", \"R2Score\", and \"NormalizedMeanAbsoluteError\"."""
    training_settings: Optional["_models.ForecastingTrainingSettings"] = rest_field(
        name="trainingSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Inputs for training phase for an AutoML Job."""
    task_type: Literal[TaskType.FORECASTING] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Forecasting is a special kind of regression task
     that deals with time-series data and creates forecasting model
     that can be used to predict the near future values based on the inputs."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        cv_split_column_names: Optional[list[str]] = None,
        featurization_settings: Optional["_models.TableVerticalFeaturizationSettings"] = None,
        limit_settings: Optional["_models.TableVerticalLimitSettings"] = None,
        n_cross_validations: Optional["_models.NCrossValidations"] = None,
        test_data: Optional["_models.MLTableJobInput"] = None,
        test_data_size: Optional[float] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        weight_column_name: Optional[str] = None,
        forecasting_settings: Optional["_models.ForecastingSettings"] = None,
        primary_metric: Optional[Union[str, "_models.ForecastingPrimaryMetrics"]] = None,
        training_settings: Optional["_models.ForecastingTrainingSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.FORECASTING  # type: ignore


class ForecastingSettings(_Model):
    """Forecasting specific parameters.

    :ivar country_or_region_for_holidays: Country or region for holidays for forecasting tasks.
     These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
    :vartype country_or_region_for_holidays: str
    :ivar cv_step_size: Number of periods between the origin time of one CV fold and the next fold.
     For
     example, if ``CVStepSize`` = 3 for daily data, the origin time for each fold will be
     three days apart.
    :vartype cv_step_size: int
    :ivar feature_lags: Flag for generating lags for the numeric features. Known values are: "None"
     and "Auto".
    :vartype feature_lags: str or ~azure.mgmt.machinelearningservices.models.FeatureLags
    :ivar forecast_horizon: The desired maximum forecast horizon in units of time-series frequency.
    :vartype forecast_horizon: ~azure.mgmt.machinelearningservices.models.ForecastHorizon
    :ivar frequency: When forecasting, this parameter represents the period with which the forecast
     is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency
     by default.
    :vartype frequency: str
    :ivar seasonality: Set time series seasonality as an integer multiple of the series frequency.
     If seasonality is set to 'auto', it will be inferred.
    :vartype seasonality: ~azure.mgmt.machinelearningservices.models.Seasonality
    :ivar short_series_handling_config: The parameter defining how if AutoML should handle short
     time series. Known values are: "None", "Auto", "Pad", and "Drop".
    :vartype short_series_handling_config: str or
     ~azure.mgmt.machinelearningservices.models.ShortSeriesHandlingConfiguration
    :ivar target_aggregate_function: Target aggregate function. Known values are: "None", "Sum",
     "Max", "Min", and "Mean".
    :vartype target_aggregate_function: str or
     ~azure.mgmt.machinelearningservices.models.TargetAggregationFunction
    :ivar target_lags: The number of past periods to lag from the target column.
    :vartype target_lags: ~azure.mgmt.machinelearningservices.models.TargetLags
    :ivar target_rolling_window_size: The number of past periods used to create a rolling window
     average of the target column.
    :vartype target_rolling_window_size:
     ~azure.mgmt.machinelearningservices.models.TargetRollingWindowSize
    :ivar time_column_name: The name of the time column. This parameter is required when
     forecasting to specify the datetime column in the input data used for building the time series
     and inferring its frequency.
    :vartype time_column_name: str
    :ivar time_series_id_column_names: The names of columns used to group a timeseries. It can be
     used to create multiple series.
     If grain is not defined, the data set is assumed to be one time-series. This parameter is used
     with task type forecasting.
    :vartype time_series_id_column_names: list[str]
    :ivar use_stl: Configure STL Decomposition of the time-series target column. Known values are:
     "None", "Season", and "SeasonTrend".
    :vartype use_stl: str or ~azure.mgmt.machinelearningservices.models.UseStl
    """

    country_or_region_for_holidays: Optional[str] = rest_field(
        name="countryOrRegionForHolidays", visibility=["read", "create", "update", "delete", "query"]
    )
    """Country or region for holidays for forecasting tasks.
     These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'."""
    cv_step_size: Optional[int] = rest_field(
        name="cvStepSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of periods between the origin time of one CV fold and the next fold. For
     example, if ``CVStepSize`` = 3 for daily data, the origin time for each fold will be
     three days apart."""
    feature_lags: Optional[Union[str, "_models.FeatureLags"]] = rest_field(
        name="featureLags", visibility=["read", "create", "update", "delete", "query"]
    )
    """Flag for generating lags for the numeric features. Known values are: \"None\" and \"Auto\"."""
    forecast_horizon: Optional["_models.ForecastHorizon"] = rest_field(
        name="forecastHorizon", visibility=["read", "create", "update", "delete", "query"]
    )
    """The desired maximum forecast horizon in units of time-series frequency."""
    frequency: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """When forecasting, this parameter represents the period with which the forecast is desired, for
     example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default."""
    seasonality: Optional["_models.Seasonality"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Set time series seasonality as an integer multiple of the series frequency.
     If seasonality is set to 'auto', it will be inferred."""
    short_series_handling_config: Optional[Union[str, "_models.ShortSeriesHandlingConfiguration"]] = rest_field(
        name="shortSeriesHandlingConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """The parameter defining how if AutoML should handle short time series. Known values are:
     \"None\", \"Auto\", \"Pad\", and \"Drop\"."""
    target_aggregate_function: Optional[Union[str, "_models.TargetAggregationFunction"]] = rest_field(
        name="targetAggregateFunction", visibility=["read", "create", "update", "delete", "query"]
    )
    """Target aggregate function. Known values are: \"None\", \"Sum\", \"Max\", \"Min\", and \"Mean\"."""
    target_lags: Optional["_models.TargetLags"] = rest_field(
        name="targetLags", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of past periods to lag from the target column."""
    target_rolling_window_size: Optional["_models.TargetRollingWindowSize"] = rest_field(
        name="targetRollingWindowSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of past periods used to create a rolling window average of the target column."""
    time_column_name: Optional[str] = rest_field(
        name="timeColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the time column. This parameter is required when forecasting to specify the
     datetime column in the input data used for building the time series and inferring its
     frequency."""
    time_series_id_column_names: Optional[list[str]] = rest_field(
        name="timeSeriesIdColumnNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The names of columns used to group a timeseries. It can be used to create multiple series.
     If grain is not defined, the data set is assumed to be one time-series. This parameter is used
     with task type forecasting."""
    use_stl: Optional[Union[str, "_models.UseStl"]] = rest_field(
        name="useStl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Configure STL Decomposition of the time-series target column. Known values are: \"None\",
     \"Season\", and \"SeasonTrend\"."""

    @overload
    def __init__(
        self,
        *,
        country_or_region_for_holidays: Optional[str] = None,
        cv_step_size: Optional[int] = None,
        feature_lags: Optional[Union[str, "_models.FeatureLags"]] = None,
        forecast_horizon: Optional["_models.ForecastHorizon"] = None,
        frequency: Optional[str] = None,
        seasonality: Optional["_models.Seasonality"] = None,
        short_series_handling_config: Optional[Union[str, "_models.ShortSeriesHandlingConfiguration"]] = None,
        target_aggregate_function: Optional[Union[str, "_models.TargetAggregationFunction"]] = None,
        target_lags: Optional["_models.TargetLags"] = None,
        target_rolling_window_size: Optional["_models.TargetRollingWindowSize"] = None,
        time_column_name: Optional[str] = None,
        time_series_id_column_names: Optional[list[str]] = None,
        use_stl: Optional[Union[str, "_models.UseStl"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastingTrainingSettings(TrainingSettings):
    """Forecasting Training related configuration.

    :ivar enable_dnn_training: Enable recommendation of DNN models.
    :vartype enable_dnn_training: bool
    :ivar enable_model_explainability: Flag to turn on explainability on best model.
    :vartype enable_model_explainability: bool
    :ivar enable_onnx_compatible_models: Flag for enabling onnx compatible models.
    :vartype enable_onnx_compatible_models: bool
    :ivar enable_stack_ensemble: Enable stack ensemble run.
    :vartype enable_stack_ensemble: bool
    :ivar enable_vote_ensemble: Enable voting ensemble run.
    :vartype enable_vote_ensemble: bool
    :ivar ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model
     generation, multiple fitted models from the previous child runs are downloaded.
     Configure this parameter with a higher value than 300 secs, if more time is needed.
    :vartype ensemble_model_download_timeout: ~datetime.timedelta
    :ivar stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
    :vartype stack_ensemble_settings:
     ~azure.mgmt.machinelearningservices.models.StackEnsembleSettings
    :ivar allowed_training_algorithms: Allowed models for forecasting task.
    :vartype allowed_training_algorithms: list[str or
     ~azure.mgmt.machinelearningservices.models.ForecastingModels]
    :ivar blocked_training_algorithms: Blocked models for forecasting task.
    :vartype blocked_training_algorithms: list[str or
     ~azure.mgmt.machinelearningservices.models.ForecastingModels]
    """

    allowed_training_algorithms: Optional[list[Union[str, "_models.ForecastingModels"]]] = rest_field(
        name="allowedTrainingAlgorithms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allowed models for forecasting task."""
    blocked_training_algorithms: Optional[list[Union[str, "_models.ForecastingModels"]]] = rest_field(
        name="blockedTrainingAlgorithms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Blocked models for forecasting task."""

    @overload
    def __init__(
        self,
        *,
        enable_dnn_training: Optional[bool] = None,
        enable_model_explainability: Optional[bool] = None,
        enable_onnx_compatible_models: Optional[bool] = None,
        enable_stack_ensemble: Optional[bool] = None,
        enable_vote_ensemble: Optional[bool] = None,
        ensemble_model_download_timeout: Optional[datetime.timedelta] = None,
        stack_ensemble_settings: Optional["_models.StackEnsembleSettings"] = None,
        allowed_training_algorithms: Optional[list[Union[str, "_models.ForecastingModels"]]] = None,
        blocked_training_algorithms: Optional[list[Union[str, "_models.ForecastingModels"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FQDNEndpoint(_Model):
    """FQDNEndpoint.

    :ivar domain_name:
    :vartype domain_name: str
    :ivar endpoint_details:
    :vartype endpoint_details: list[~azure.mgmt.machinelearningservices.models.FQDNEndpointDetail]
    """

    domain_name: Optional[str] = rest_field(
        name="domainName", visibility=["read", "create", "update", "delete", "query"]
    )
    endpoint_details: Optional[list["_models.FQDNEndpointDetail"]] = rest_field(
        name="endpointDetails", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        domain_name: Optional[str] = None,
        endpoint_details: Optional[list["_models.FQDNEndpointDetail"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FQDNEndpointDetail(_Model):
    """FQDNEndpointDetail.

    :ivar port:
    :vartype port: int
    """

    port: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        port: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FQDNEndpoints(_Model):
    """FQDNEndpoints.

    :ivar category:
    :vartype category: str
    :ivar endpoints:
    :vartype endpoints: list[~azure.mgmt.machinelearningservices.models.FQDNEndpoint]
    """

    category: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    endpoints: Optional[list["_models.FQDNEndpoint"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        category: Optional[str] = None,
        endpoints: Optional[list["_models.FQDNEndpoint"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FQDNEndpointsPropertyBag(_Model):
    """Property bag for FQDN endpoints result.

    :ivar properties:
    :vartype properties: ~azure.mgmt.machinelearningservices.models.FQDNEndpoints
    """

    properties: Optional["_models.FQDNEndpoints"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.FQDNEndpoints"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OutboundRule(_Model):
    """Outbound Rule for the managed network of a machine learning workspace.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    FqdnOutboundRule, PrivateEndpointOutboundRule, ServiceTagOutboundRule

    :ivar category: Category of a managed network Outbound Rule of a machine learning workspace.
     Known values are: "Required", "Recommended", "UserDefined", and "Dependency".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.RuleCategory
    :ivar status: Type of a managed network Outbound Rule of a machine learning workspace. Known
     values are: "Inactive", "Active", "Provisioning", "Deleting", and "Failed".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.RuleStatus
    :ivar type: Type of a managed network Outbound Rule of a machine learning workspace. Required.
     Known values are: "FQDN", "PrivateEndpoint", and "ServiceTag".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.RuleType
    :ivar error_information: Error information about an outbound rule of a machine learning
     workspace if RuleStatus is failed.
    :vartype error_information: str
    :ivar parent_rule_names:
    :vartype parent_rule_names: list[str]
    """

    __mapping__: dict[str, _Model] = {}
    category: Optional[Union[str, "_models.RuleCategory"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Category of a managed network Outbound Rule of a machine learning workspace. Known values are:
     \"Required\", \"Recommended\", \"UserDefined\", and \"Dependency\"."""
    status: Optional[Union[str, "_models.RuleStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of a managed network Outbound Rule of a machine learning workspace. Known values are:
     \"Inactive\", \"Active\", \"Provisioning\", \"Deleting\", and \"Failed\"."""
    type: str = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])
    """Type of a managed network Outbound Rule of a machine learning workspace. Required. Known values
     are: \"FQDN\", \"PrivateEndpoint\", and \"ServiceTag\"."""
    error_information: Optional[str] = rest_field(name="errorInformation", visibility=["read"])
    """Error information about an outbound rule of a machine learning workspace if RuleStatus is
     failed."""
    parent_rule_names: Optional[list[str]] = rest_field(name="parentRuleNames", visibility=["read"])

    @overload
    def __init__(
        self,
        *,
        type: str,
        category: Optional[Union[str, "_models.RuleCategory"]] = None,
        status: Optional[Union[str, "_models.RuleStatus"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FqdnOutboundRule(OutboundRule, discriminator="FQDN"):
    """FQDN Outbound Rule for the managed network of a machine learning workspace.

    :ivar category: Category of a managed network Outbound Rule of a machine learning workspace.
     Known values are: "Required", "Recommended", "UserDefined", and "Dependency".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.RuleCategory
    :ivar status: Type of a managed network Outbound Rule of a machine learning workspace. Known
     values are: "Inactive", "Active", "Provisioning", "Deleting", and "Failed".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.RuleStatus
    :ivar error_information: Error information about an outbound rule of a machine learning
     workspace if RuleStatus is failed.
    :vartype error_information: str
    :ivar parent_rule_names:
    :vartype parent_rule_names: list[str]
    :ivar destination:
    :vartype destination: str
    :ivar type: Type of a managed network Outbound Rule of a machine learning workspace. Required.
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.FQDN
    """

    destination: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    type: Literal[RuleType.FQDN] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of a managed network Outbound Rule of a machine learning workspace. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.RuleCategory"]] = None,
        status: Optional[Union[str, "_models.RuleStatus"]] = None,
        destination: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = RuleType.FQDN  # type: ignore


class GetBlobReferenceForConsumptionDto(_Model):
    """GetBlobReferenceForConsumptionDto.

    :ivar blob_uri: Blob uri, example: `https://blob.windows.core.net/Container/Path
     <https://blob.windows.core.net/Container/Path>`_.
    :vartype blob_uri: str
    :ivar credential: Credential info to access storage account.
    :vartype credential: ~azure.mgmt.machinelearningservices.models.DataReferenceCredential
    :ivar storage_account_arm_id: The ARM id of the storage account.
    :vartype storage_account_arm_id: str
    """

    blob_uri: Optional[str] = rest_field(name="blobUri", visibility=["read", "create", "update", "delete", "query"])
    """Blob uri, example: `https://blob.windows.core.net/Container/Path
     <https://blob.windows.core.net/Container/Path>`_."""
    credential: Optional["_models.DataReferenceCredential"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Credential info to access storage account."""
    storage_account_arm_id: Optional[str] = rest_field(
        name="storageAccountArmId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The ARM id of the storage account."""

    @overload
    def __init__(
        self,
        *,
        blob_uri: Optional[str] = None,
        credential: Optional["_models.DataReferenceCredential"] = None,
        storage_account_arm_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GetBlobReferenceSASRequestDto(_Model):
    """BlobReferenceSASRequest for getBlobReferenceSAS API.

    :ivar asset_id: Id of the asset to be accessed.
    :vartype asset_id: str
    :ivar blob_uri: Blob uri of the asset to be accessed.
    :vartype blob_uri: str
    """

    asset_id: Optional[str] = rest_field(name="assetId", visibility=["read", "create", "update", "delete", "query"])
    """Id of the asset to be accessed."""
    blob_uri: Optional[str] = rest_field(name="blobUri", visibility=["read", "create", "update", "delete", "query"])
    """Blob uri of the asset to be accessed."""

    @overload
    def __init__(
        self,
        *,
        asset_id: Optional[str] = None,
        blob_uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GetBlobReferenceSASResponseDto(_Model):
    """BlobReferenceSASResponse for getBlobReferenceSAS API.

    :ivar blob_reference_for_consumption: Blob reference for consumption details.
    :vartype blob_reference_for_consumption:
     ~azure.mgmt.machinelearningservices.models.GetBlobReferenceForConsumptionDto
    """

    blob_reference_for_consumption: Optional["_models.GetBlobReferenceForConsumptionDto"] = rest_field(
        name="blobReferenceForConsumption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Blob reference for consumption details."""

    @overload
    def __init__(
        self,
        *,
        blob_reference_for_consumption: Optional["_models.GetBlobReferenceForConsumptionDto"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GridSamplingAlgorithm(SamplingAlgorithm, discriminator="Grid"):
    """Defines a Sampling Algorithm that exhaustively generates every value combination in the space.

    :ivar sampling_algorithm_type: [Required] The algorithm used for generating hyperparameter
     values, along with configuration properties. Required.
    :vartype sampling_algorithm_type: str or ~azure.mgmt.machinelearningservices.models.GRID
    """

    sampling_algorithm_type: Literal[SamplingAlgorithmType.GRID] = rest_discriminator(name="samplingAlgorithmType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] The algorithm used for generating hyperparameter values, along with configuration
     properties. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.sampling_algorithm_type = SamplingAlgorithmType.GRID  # type: ignore


class GroupEnvironmentConfiguration(_Model):
    """Environment configuration options.

    :ivar environment_id: ARM resource ID of the environment specification for the inference pool.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the inference pool.
    :vartype environment_variables:
     list[~azure.mgmt.machinelearningservices.models.StringStringKeyValuePair]
    :ivar liveness_probe: Liveness probe monitors the health of the container regularly.
    :vartype liveness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar readiness_probe: Readiness probe validates if the container is ready to serve traffic.
     The properties and defaults are the same as liveness probe.
    :vartype readiness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar startup_probe: This verifies whether the application within a container is started.
     Startup probes run before any other probe, and, unless it finishes successfully, disables other
     probes.
    :vartype startup_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    """

    environment_id: Optional[str] = rest_field(
        name="environmentId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM resource ID of the environment specification for the inference pool."""
    environment_variables: Optional[list["_models.StringStringKeyValuePair"]] = rest_field(
        name="environmentVariables", visibility=["read", "create", "update", "delete", "query"]
    )
    """Environment variables configuration for the inference pool."""
    liveness_probe: Optional["_models.ProbeSettings"] = rest_field(
        name="livenessProbe", visibility=["read", "create", "update", "delete", "query"]
    )
    """Liveness probe monitors the health of the container regularly."""
    readiness_probe: Optional["_models.ProbeSettings"] = rest_field(
        name="readinessProbe", visibility=["read", "create", "update", "delete", "query"]
    )
    """Readiness probe validates if the container is ready to serve traffic. The properties and
     defaults are the same as liveness probe."""
    startup_probe: Optional["_models.ProbeSettings"] = rest_field(
        name="startupProbe", visibility=["read", "create", "update", "delete", "query"]
    )
    """This verifies whether the application within a container is started. Startup probes run before
     any other probe, and, unless it finishes successfully, disables other probes."""

    @overload
    def __init__(
        self,
        *,
        environment_id: Optional[str] = None,
        environment_variables: Optional[list["_models.StringStringKeyValuePair"]] = None,
        liveness_probe: Optional["_models.ProbeSettings"] = None,
        readiness_probe: Optional["_models.ProbeSettings"] = None,
        startup_probe: Optional["_models.ProbeSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GroupModelConfiguration(_Model):
    """Model configuration options.

    :ivar model_id: The URI path to the model.
    :vartype model_id: str
    """

    model_id: Optional[str] = rest_field(name="modelId", visibility=["read", "create", "update", "delete", "query"])
    """The URI path to the model."""

    @overload
    def __init__(
        self,
        *,
        model_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GroupStatus(_Model):
    """GroupStatus.

    :ivar actual_capacity_info: Gets or sets the actual capacity info for the group.
    :vartype actual_capacity_info: ~azure.mgmt.machinelearningservices.models.ActualCapacityInfo
    :ivar endpoint_count: Gets or sets the actual number of endpoints in the group.
    :vartype endpoint_count: int
    :ivar requested_capacity: Gets or sets the request number of instances for the group.
    :vartype requested_capacity: int
    """

    actual_capacity_info: Optional["_models.ActualCapacityInfo"] = rest_field(
        name="actualCapacityInfo", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets the actual capacity info for the group."""
    endpoint_count: Optional[int] = rest_field(
        name="endpointCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets the actual number of endpoints in the group."""
    requested_capacity: Optional[int] = rest_field(
        name="requestedCapacity", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets the request number of instances for the group."""

    @overload
    def __init__(
        self,
        *,
        actual_capacity_info: Optional["_models.ActualCapacityInfo"] = None,
        endpoint_count: Optional[int] = None,
        requested_capacity: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HDInsight(Compute, discriminator="HDInsight"):
    """A HDInsight compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties:
    :vartype properties: ~azure.mgmt.machinelearningservices.models.HDInsightProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.HD_INSIGHT
    """

    properties: Optional["_models.HDInsightProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    compute_type: Literal[ComputeType.HD_INSIGHT] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.HDInsightProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.HD_INSIGHT  # type: ignore


class HDInsightProperties(_Model):
    """HDInsight compute properties.

    :ivar ssh_port: Port open for ssh connections on the master node of the cluster.
    :vartype ssh_port: int
    :ivar address: Public IP address of the master node of the cluster.
    :vartype address: str
    :ivar administrator_account: Admin credentials for master node of the cluster.
    :vartype administrator_account:
     ~azure.mgmt.machinelearningservices.models.VirtualMachineSshCredentials
    """

    ssh_port: Optional[int] = rest_field(name="sshPort", visibility=["read", "create", "update", "delete", "query"])
    """Port open for ssh connections on the master node of the cluster."""
    address: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Public IP address of the master node of the cluster."""
    administrator_account: Optional["_models.VirtualMachineSshCredentials"] = rest_field(
        name="administratorAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Admin credentials for master node of the cluster."""

    @overload
    def __init__(
        self,
        *,
        ssh_port: Optional[int] = None,
        address: Optional[str] = None,
        administrator_account: Optional["_models.VirtualMachineSshCredentials"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IdAssetReference(AssetReferenceBase, discriminator="Id"):
    """Reference to an asset via its ARM resource ID.

    :ivar asset_id: [Required] ARM resource ID of the asset. Required.
    :vartype asset_id: str
    :ivar reference_type: [Required] Specifies the type of asset reference. Required.
    :vartype reference_type: str or ~azure.mgmt.machinelearningservices.models.ID
    """

    asset_id: str = rest_field(name="assetId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] ARM resource ID of the asset. Required."""
    reference_type: Literal[ReferenceType.ID] = rest_discriminator(name="referenceType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of asset reference. Required."""

    @overload
    def __init__(
        self,
        *,
        asset_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.reference_type = ReferenceType.ID  # type: ignore


class IdentityForCmk(_Model):
    """Identity object used for encryption.

    :ivar user_assigned_identity: UserAssignedIdentity to be used to fetch the encryption key from
     keyVault.
    :vartype user_assigned_identity: str
    """

    user_assigned_identity: Optional[str] = rest_field(
        name="userAssignedIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """UserAssignedIdentity to be used to fetch the encryption key from keyVault."""

    @overload
    def __init__(
        self,
        *,
        user_assigned_identity: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IdleShutdownSetting(_Model):
    """Stops compute instance after user defined period of inactivity.

    :ivar idle_time_before_shutdown: Time is defined in ISO8601 format. Minimum is 15 min, maximum
     is 3 days.
    :vartype idle_time_before_shutdown: str
    """

    idle_time_before_shutdown: Optional[str] = rest_field(
        name="idleTimeBeforeShutdown", visibility=["read", "create", "update", "delete", "query"]
    )
    """Time is defined in ISO8601 format. Minimum is 15 min, maximum is 3 days."""

    @overload
    def __init__(
        self,
        *,
        idle_time_before_shutdown: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Image(_Model):
    """Image.

    :ivar type: Type of the image. Known values are: "docker" and "azureml".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.ImageType
    :ivar reference: Image reference URL if type is docker. Environment name if type is azureml.
    :vartype reference: str
    :ivar version: Version of image being used. If latest then skip this field.
    :vartype version: str
    """

    type: Optional[Union[str, "_models.ImageType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of the image. Known values are: \"docker\" and \"azureml\"."""
    reference: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Image reference URL if type is docker. Environment name if type is azureml."""
    version: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Version of image being used. If latest then skip this field."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.ImageType"]] = None,
        reference: Optional[str] = None,
        version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageClassification(AutoMLVertical, discriminator="ImageClassification"):
    """Image Classification. Multi-class image classification is used when an image is classified with
    only a single label
    from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog'
    or a 'duck'.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar model_settings: Settings used for training the model.
    :vartype model_settings:
     ~azure.mgmt.machinelearningservices.models.ImageModelSettingsClassification
    :ivar search_space: Search space for sampling different combinations of models and their
     hyperparameters.
    :vartype search_space:
     list[~azure.mgmt.machinelearningservices.models.ImageModelDistributionSettingsClassification]
    :ivar limit_settings: [Required] Limit settings for the AutoML job. Required.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.ImageLimitSettings
    :ivar sweep_settings: Model sweeping and hyperparameter sweeping related settings.
    :vartype sweep_settings: ~azure.mgmt.machinelearningservices.models.ImageSweepSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar primary_metric: Primary metrics for classification tasks. Known values are:
     "AUCWeighted", "Accuracy", "NormMacroRecall", "AveragePrecisionScoreWeighted", and
     "PrecisionScoreWeighted".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ClassificationPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Image Classification.
     Multi-class image classification is used when an image is classified with only a single label
     from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog'
     or a 'duck'.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.IMAGE_CLASSIFICATION
    """

    model_settings: Optional["_models.ImageModelSettingsClassification"] = rest_field(
        name="modelSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings used for training the model."""
    search_space: Optional[list["_models.ImageModelDistributionSettingsClassification"]] = rest_field(
        name="searchSpace", visibility=["read", "create", "update", "delete", "query"]
    )
    """Search space for sampling different combinations of models and their hyperparameters."""
    limit_settings: "_models.ImageLimitSettings" = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Limit settings for the AutoML job. Required."""
    sweep_settings: Optional["_models.ImageSweepSettings"] = rest_field(
        name="sweepSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Model sweeping and hyperparameter sweeping related settings."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for classification tasks. Known values are: \"AUCWeighted\", \"Accuracy\",
     \"NormMacroRecall\", \"AveragePrecisionScoreWeighted\", and \"PrecisionScoreWeighted\"."""
    task_type: Literal[TaskType.IMAGE_CLASSIFICATION] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Image Classification. Multi-class image
     classification is used when an image is classified with only a single label
     from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog'
     or a 'duck'."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        limit_settings: "_models.ImageLimitSettings",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        model_settings: Optional["_models.ImageModelSettingsClassification"] = None,
        search_space: Optional[list["_models.ImageModelDistributionSettingsClassification"]] = None,
        sweep_settings: Optional["_models.ImageSweepSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.IMAGE_CLASSIFICATION  # type: ignore


class ImageClassificationMultilabel(AutoMLVertical, discriminator="ImageClassificationMultilabel"):
    """Image Classification Multilabel. Multi-label image classification is used when an image could
    have one or more labels
    from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar model_settings: Settings used for training the model.
    :vartype model_settings:
     ~azure.mgmt.machinelearningservices.models.ImageModelSettingsClassification
    :ivar search_space: Search space for sampling different combinations of models and their
     hyperparameters.
    :vartype search_space:
     list[~azure.mgmt.machinelearningservices.models.ImageModelDistributionSettingsClassification]
    :ivar limit_settings: [Required] Limit settings for the AutoML job. Required.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.ImageLimitSettings
    :ivar sweep_settings: Model sweeping and hyperparameter sweeping related settings.
    :vartype sweep_settings: ~azure.mgmt.machinelearningservices.models.ImageSweepSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar primary_metric: Primary metrics for classification multilabel tasks. Known values are:
     "AUCWeighted", "Accuracy", "NormMacroRecall", "AveragePrecisionScoreWeighted",
     "PrecisionScoreWeighted", and "IOU".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ClassificationMultilabelPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Image Classification Multilabel.
     Multi-label image classification is used when an image could have one or more labels
     from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
    :vartype task_type: str or
     ~azure.mgmt.machinelearningservices.models.IMAGE_CLASSIFICATION_MULTILABEL
    """

    model_settings: Optional["_models.ImageModelSettingsClassification"] = rest_field(
        name="modelSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings used for training the model."""
    search_space: Optional[list["_models.ImageModelDistributionSettingsClassification"]] = rest_field(
        name="searchSpace", visibility=["read", "create", "update", "delete", "query"]
    )
    """Search space for sampling different combinations of models and their hyperparameters."""
    limit_settings: "_models.ImageLimitSettings" = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Limit settings for the AutoML job. Required."""
    sweep_settings: Optional["_models.ImageSweepSettings"] = rest_field(
        name="sweepSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Model sweeping and hyperparameter sweeping related settings."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    primary_metric: Optional[Union[str, "_models.ClassificationMultilabelPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for classification multilabel tasks. Known values are: \"AUCWeighted\",
     \"Accuracy\", \"NormMacroRecall\", \"AveragePrecisionScoreWeighted\",
     \"PrecisionScoreWeighted\", and \"IOU\"."""
    task_type: Literal[TaskType.IMAGE_CLASSIFICATION_MULTILABEL] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Image Classification Multilabel. Multi-label
     image classification is used when an image could have one or more labels
     from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        limit_settings: "_models.ImageLimitSettings",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        model_settings: Optional["_models.ImageModelSettingsClassification"] = None,
        search_space: Optional[list["_models.ImageModelDistributionSettingsClassification"]] = None,
        sweep_settings: Optional["_models.ImageSweepSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        primary_metric: Optional[Union[str, "_models.ClassificationMultilabelPrimaryMetrics"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.IMAGE_CLASSIFICATION_MULTILABEL  # type: ignore


class ImageDetails(_Model):
    """ImageDetails.

    :ivar exists: Indicates if image exists.
    :vartype exists: bool
    :ivar image: Container image details.
    :vartype image: ~azure.mgmt.machinelearningservices.models.ImageInfo
    :ivar vulnerability_findings: Vulnerability findings details.
    :vartype vulnerability_findings:
     ~azure.mgmt.machinelearningservices.models.VulnerabilityFindings
    """

    exists: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates if image exists."""
    image: Optional["_models.ImageInfo"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Container image details."""
    vulnerability_findings: Optional["_models.VulnerabilityFindings"] = rest_field(
        name="vulnerabilityFindings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Vulnerability findings details."""

    @overload
    def __init__(
        self,
        *,
        exists: Optional[bool] = None,
        image: Optional["_models.ImageInfo"] = None,
        vulnerability_findings: Optional["_models.VulnerabilityFindings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageInfo(_Model):
    """ImageInfo.

    :ivar digest: Image digest.
    :vartype digest: str
    :ivar hostname: Container registry host name.
    :vartype hostname: str
    :ivar repository: Repository name.
    :vartype repository: str
    :ivar tag: Image tag.
    :vartype tag: str
    """

    digest: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Image digest."""
    hostname: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Container registry host name."""
    repository: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Repository name."""
    tag: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Image tag."""

    @overload
    def __init__(
        self,
        *,
        digest: Optional[str] = None,
        hostname: Optional[str] = None,
        repository: Optional[str] = None,
        tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageInstanceSegmentation(AutoMLVertical, discriminator="ImageInstanceSegmentation"):
    """Image Instance Segmentation. Instance segmentation is used to identify objects in an image at
    the pixel level,
    drawing a polygon around each object in the image.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar model_settings: Settings used for training the model.
    :vartype model_settings:
     ~azure.mgmt.machinelearningservices.models.ImageModelSettingsObjectDetection
    :ivar search_space: Search space for sampling different combinations of models and their
     hyperparameters.
    :vartype search_space:
     list[~azure.mgmt.machinelearningservices.models.ImageModelDistributionSettingsObjectDetection]
    :ivar limit_settings: [Required] Limit settings for the AutoML job. Required.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.ImageLimitSettings
    :ivar sweep_settings: Model sweeping and hyperparameter sweeping related settings.
    :vartype sweep_settings: ~azure.mgmt.machinelearningservices.models.ImageSweepSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar primary_metric: Primary metrics for InstanceSegmentation tasks. "MeanAveragePrecision"
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.InstanceSegmentationPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Image Instance Segmentation.
     Instance segmentation is used to identify objects in an image at the pixel level,
     drawing a polygon around each object in the image.
    :vartype task_type: str or
     ~azure.mgmt.machinelearningservices.models.IMAGE_INSTANCE_SEGMENTATION
    """

    model_settings: Optional["_models.ImageModelSettingsObjectDetection"] = rest_field(
        name="modelSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings used for training the model."""
    search_space: Optional[list["_models.ImageModelDistributionSettingsObjectDetection"]] = rest_field(
        name="searchSpace", visibility=["read", "create", "update", "delete", "query"]
    )
    """Search space for sampling different combinations of models and their hyperparameters."""
    limit_settings: "_models.ImageLimitSettings" = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Limit settings for the AutoML job. Required."""
    sweep_settings: Optional["_models.ImageSweepSettings"] = rest_field(
        name="sweepSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Model sweeping and hyperparameter sweeping related settings."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    primary_metric: Optional[Union[str, "_models.InstanceSegmentationPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for InstanceSegmentation tasks. \"MeanAveragePrecision\""""
    task_type: Literal[TaskType.IMAGE_INSTANCE_SEGMENTATION] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Image Instance Segmentation. Instance
     segmentation is used to identify objects in an image at the pixel level,
     drawing a polygon around each object in the image."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        limit_settings: "_models.ImageLimitSettings",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        model_settings: Optional["_models.ImageModelSettingsObjectDetection"] = None,
        search_space: Optional[list["_models.ImageModelDistributionSettingsObjectDetection"]] = None,
        sweep_settings: Optional["_models.ImageSweepSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        primary_metric: Optional[Union[str, "_models.InstanceSegmentationPrimaryMetrics"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.IMAGE_INSTANCE_SEGMENTATION  # type: ignore


class ImageLimitSettings(_Model):
    """Limit settings for the AutoML job.

    :ivar max_concurrent_trials: Maximum number of concurrent AutoML iterations.
    :vartype max_concurrent_trials: int
    :ivar max_trials: Maximum number of AutoML iterations.
    :vartype max_trials: int
    :ivar timeout: AutoML job timeout.
    :vartype timeout: ~datetime.timedelta
    """

    max_concurrent_trials: Optional[int] = rest_field(
        name="maxConcurrentTrials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum number of concurrent AutoML iterations."""
    max_trials: Optional[int] = rest_field(name="maxTrials", visibility=["read", "create", "update", "delete", "query"])
    """Maximum number of AutoML iterations."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """AutoML job timeout."""

    @overload
    def __init__(
        self,
        *,
        max_concurrent_trials: Optional[int] = None,
        max_trials: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageMetadata(_Model):
    """Returns metadata about the operating system image for this compute instance.

    :ivar current_image_version: Specifies the current operating system image version this compute
     instance is running on.
    :vartype current_image_version: str
    :ivar latest_image_version: Specifies the latest available operating system image version.
    :vartype latest_image_version: str
    :ivar is_latest_os_image_version: Specifies whether this compute instance is running on the
     latest operating system image.
    :vartype is_latest_os_image_version: bool
    :ivar os_patching_status: Metadata about the os patching.
    :vartype os_patching_status: ~azure.mgmt.machinelearningservices.models.OsPatchingStatus
    """

    current_image_version: Optional[str] = rest_field(
        name="currentImageVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the current operating system image version this compute instance is running on."""
    latest_image_version: Optional[str] = rest_field(
        name="latestImageVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the latest available operating system image version."""
    is_latest_os_image_version: Optional[bool] = rest_field(
        name="isLatestOsImageVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies whether this compute instance is running on the latest operating system image."""
    os_patching_status: Optional["_models.OsPatchingStatus"] = rest_field(name="osPatchingStatus", visibility=["read"])
    """Metadata about the os patching."""

    @overload
    def __init__(
        self,
        *,
        current_image_version: Optional[str] = None,
        latest_image_version: Optional[str] = None,
        is_latest_os_image_version: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageModelDistributionSettings(_Model):
    """Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:

    .. code-block::

       ModelName = "choice('seresnext', 'resnest50')";
       LearningRate = "uniform(0.001, 0.01)";
       LayersToFreeze = "choice(0, 2)";
       ```</example>
       All distributions can be specified as distribution_name(min, max) or choice(val1, val2, ...,
    valn)
       where distribution name can be: uniform, quniform, loguniform, etc
       For more details on how to compose distribution expressions please check the documentation:
       https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
       For more information on the available settings please visit the official documentation:
       https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.

    :ivar ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
    :vartype ams_gradient: str
    :ivar augmentations: Settings for using Augmentations.
    :vartype augmentations: str
    :ivar beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta1: str
    :ivar beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta2: str
    :ivar distributed: Whether to use distributer training.
    :vartype distributed: str
    :ivar early_stopping: Enable early stopping logic during training.
    :vartype early_stopping: str
    :ivar early_stopping_delay: Minimum number of epochs or validation evaluations to wait before
     primary metric improvement
     is tracked for early stopping. Must be a positive integer.
    :vartype early_stopping_delay: str
    :ivar early_stopping_patience: Minimum number of epochs or validation evaluations with no
     primary metric improvement before
     the run is stopped. Must be a positive integer.
    :vartype early_stopping_patience: str
    :ivar enable_onnx_normalization: Enable normalization when exporting ONNX model.
    :vartype enable_onnx_normalization: str
    :ivar evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must
     be a positive integer.
    :vartype evaluation_frequency: str
    :ivar gradient_accumulation_step: Gradient accumulation means running a configured number of
     "GradAccumulationStep" steps without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer.
    :vartype gradient_accumulation_step: str
    :ivar layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype layers_to_freeze: str
    :ivar learning_rate: Initial learning rate. Must be a float in the range [0, 1].
    :vartype learning_rate: str
    :ivar learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or
     'step'.
    :vartype learning_rate_scheduler: str
    :ivar model_name: Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype model_name: str
    :ivar momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
    :vartype momentum: str
    :ivar nesterov: Enable nesterov when optimizer is 'sgd'.
    :vartype nesterov: str
    :ivar number_of_epochs: Number of training epochs. Must be a positive integer.
    :vartype number_of_epochs: str
    :ivar number_of_workers: Number of data loader workers. Must be a non-negative integer.
    :vartype number_of_workers: str
    :ivar optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
    :vartype optimizer: str
    :ivar random_seed: Random seed to be used when using deterministic training.
    :vartype random_seed: str
    :ivar step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in
     the range [0, 1].
    :vartype step_lr_gamma: str
    :ivar step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a
     positive integer.
    :vartype step_lr_step_size: str
    :ivar training_batch_size: Training batch size. Must be a positive integer.
    :vartype training_batch_size: str
    :ivar validation_batch_size: Validation batch size. Must be a positive integer.
    :vartype validation_batch_size: str
    :ivar warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is
     'warmup_cosine'. Must be a float in the range [0, 1].
    :vartype warmup_cosine_lr_cycles: str
    :ivar warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is
     'warmup_cosine'. Must be a positive integer.
    :vartype warmup_cosine_lr_warmup_epochs: str
    :ivar weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be
     a float in the range[0, 1].
    :vartype weight_decay: str
    """

    ams_gradient: Optional[str] = rest_field(
        name="amsGradient", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable AMSGrad when optimizer is 'adam' or 'adamw'."""
    augmentations: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Settings for using Augmentations."""
    beta1: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1]."""
    beta2: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1]."""
    distributed: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to use distributer training."""
    early_stopping: Optional[str] = rest_field(
        name="earlyStopping", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable early stopping logic during training."""
    early_stopping_delay: Optional[str] = rest_field(
        name="earlyStoppingDelay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Minimum number of epochs or validation evaluations to wait before primary metric improvement
     is tracked for early stopping. Must be a positive integer."""
    early_stopping_patience: Optional[str] = rest_field(
        name="earlyStoppingPatience", visibility=["read", "create", "update", "delete", "query"]
    )
    """Minimum number of epochs or validation evaluations with no primary metric improvement before
     the run is stopped. Must be a positive integer."""
    enable_onnx_normalization: Optional[str] = rest_field(
        name="enableOnnxNormalization", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable normalization when exporting ONNX model."""
    evaluation_frequency: Optional[str] = rest_field(
        name="evaluationFrequency", visibility=["read", "create", "update", "delete", "query"]
    )
    """Frequency to evaluate validation dataset to get metric scores. Must be a positive integer."""
    gradient_accumulation_step: Optional[str] = rest_field(
        name="gradientAccumulationStep", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gradient accumulation means running a configured number of \"GradAccumulationStep\" steps
     without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer."""
    layers_to_freeze: Optional[str] = rest_field(
        name="layersToFreeze", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_."""
    learning_rate: Optional[str] = rest_field(
        name="learningRate", visibility=["read", "create", "update", "delete", "query"]
    )
    """Initial learning rate. Must be a float in the range [0, 1]."""
    learning_rate_scheduler: Optional[str] = rest_field(
        name="learningRateScheduler", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'."""
    model_name: Optional[str] = rest_field(name="modelName", visibility=["read", "create", "update", "delete", "query"])
    """Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_."""
    momentum: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1]."""
    nesterov: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Enable nesterov when optimizer is 'sgd'."""
    number_of_epochs: Optional[str] = rest_field(
        name="numberOfEpochs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of training epochs. Must be a positive integer."""
    number_of_workers: Optional[str] = rest_field(
        name="numberOfWorkers", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of data loader workers. Must be a non-negative integer."""
    optimizer: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'."""
    random_seed: Optional[str] = rest_field(
        name="randomSeed", visibility=["read", "create", "update", "delete", "query"]
    )
    """Random seed to be used when using deterministic training."""
    step_lr_gamma: Optional[str] = rest_field(
        name="stepLRGamma", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1]."""
    step_lr_step_size: Optional[str] = rest_field(
        name="stepLRStepSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of step size when learning rate scheduler is 'step'. Must be a positive integer."""
    training_batch_size: Optional[str] = rest_field(
        name="trainingBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Training batch size. Must be a positive integer."""
    validation_batch_size: Optional[str] = rest_field(
        name="validationBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation batch size. Must be a positive integer."""
    warmup_cosine_lr_cycles: Optional[str] = rest_field(
        name="warmupCosineLRCycles", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the
     range [0, 1]."""
    warmup_cosine_lr_warmup_epochs: Optional[str] = rest_field(
        name="warmupCosineLRWarmupEpochs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive
     integer."""
    weight_decay: Optional[str] = rest_field(
        name="weightDecay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the
     range[0, 1]."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        ams_gradient: Optional[str] = None,
        augmentations: Optional[str] = None,
        beta1: Optional[str] = None,
        beta2: Optional[str] = None,
        distributed: Optional[str] = None,
        early_stopping: Optional[str] = None,
        early_stopping_delay: Optional[str] = None,
        early_stopping_patience: Optional[str] = None,
        enable_onnx_normalization: Optional[str] = None,
        evaluation_frequency: Optional[str] = None,
        gradient_accumulation_step: Optional[str] = None,
        layers_to_freeze: Optional[str] = None,
        learning_rate: Optional[str] = None,
        learning_rate_scheduler: Optional[str] = None,
        model_name: Optional[str] = None,
        momentum: Optional[str] = None,
        nesterov: Optional[str] = None,
        number_of_epochs: Optional[str] = None,
        number_of_workers: Optional[str] = None,
        optimizer: Optional[str] = None,
        random_seed: Optional[str] = None,
        step_lr_gamma: Optional[str] = None,
        step_lr_step_size: Optional[str] = None,
        training_batch_size: Optional[str] = None,
        validation_batch_size: Optional[str] = None,
        warmup_cosine_lr_cycles: Optional[str] = None,
        warmup_cosine_lr_warmup_epochs: Optional[str] = None,
        weight_decay: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageModelDistributionSettingsClassification(ImageModelDistributionSettings):  # pylint: disable=name-too-long
    """Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:

    .. code-block::

       ModelName = "choice('seresnext', 'resnest50')";
       LearningRate = "uniform(0.001, 0.01)";
       LayersToFreeze = "choice(0, 2)";
       ```</example>
       For more details on how to compose distribution expressions please check the documentation:
       https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
       For more information on the available settings please visit the official documentation:
       https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.

    :ivar ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
    :vartype ams_gradient: str
    :ivar augmentations: Settings for using Augmentations.
    :vartype augmentations: str
    :ivar beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta1: str
    :ivar beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta2: str
    :ivar distributed: Whether to use distributer training.
    :vartype distributed: str
    :ivar early_stopping: Enable early stopping logic during training.
    :vartype early_stopping: str
    :ivar early_stopping_delay: Minimum number of epochs or validation evaluations to wait before
     primary metric improvement
     is tracked for early stopping. Must be a positive integer.
    :vartype early_stopping_delay: str
    :ivar early_stopping_patience: Minimum number of epochs or validation evaluations with no
     primary metric improvement before
     the run is stopped. Must be a positive integer.
    :vartype early_stopping_patience: str
    :ivar enable_onnx_normalization: Enable normalization when exporting ONNX model.
    :vartype enable_onnx_normalization: str
    :ivar evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must
     be a positive integer.
    :vartype evaluation_frequency: str
    :ivar gradient_accumulation_step: Gradient accumulation means running a configured number of
     "GradAccumulationStep" steps without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer.
    :vartype gradient_accumulation_step: str
    :ivar layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype layers_to_freeze: str
    :ivar learning_rate: Initial learning rate. Must be a float in the range [0, 1].
    :vartype learning_rate: str
    :ivar learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or
     'step'.
    :vartype learning_rate_scheduler: str
    :ivar model_name: Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype model_name: str
    :ivar momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
    :vartype momentum: str
    :ivar nesterov: Enable nesterov when optimizer is 'sgd'.
    :vartype nesterov: str
    :ivar number_of_epochs: Number of training epochs. Must be a positive integer.
    :vartype number_of_epochs: str
    :ivar number_of_workers: Number of data loader workers. Must be a non-negative integer.
    :vartype number_of_workers: str
    :ivar optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
    :vartype optimizer: str
    :ivar random_seed: Random seed to be used when using deterministic training.
    :vartype random_seed: str
    :ivar step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in
     the range [0, 1].
    :vartype step_lr_gamma: str
    :ivar step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a
     positive integer.
    :vartype step_lr_step_size: str
    :ivar training_batch_size: Training batch size. Must be a positive integer.
    :vartype training_batch_size: str
    :ivar validation_batch_size: Validation batch size. Must be a positive integer.
    :vartype validation_batch_size: str
    :ivar warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is
     'warmup_cosine'. Must be a float in the range [0, 1].
    :vartype warmup_cosine_lr_cycles: str
    :ivar warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is
     'warmup_cosine'. Must be a positive integer.
    :vartype warmup_cosine_lr_warmup_epochs: str
    :ivar weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be
     a float in the range[0, 1].
    :vartype weight_decay: str
    :ivar training_crop_size: Image crop size that is input to the neural network for the training
     dataset. Must be a positive integer.
    :vartype training_crop_size: str
    :ivar validation_crop_size: Image crop size that is input to the neural network for the
     validation dataset. Must be a positive integer.
    :vartype validation_crop_size: str
    :ivar validation_resize_size: Image size to which to resize before cropping for validation
     dataset. Must be a positive integer.
    :vartype validation_resize_size: str
    :ivar weighted_loss: Weighted loss. The accepted values are 0 for no weighted loss.
     1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be
     0 or 1 or 2.
    :vartype weighted_loss: str
    """

    training_crop_size: Optional[str] = rest_field(
        name="trainingCropSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image crop size that is input to the neural network for the training dataset. Must be a
     positive integer."""
    validation_crop_size: Optional[str] = rest_field(
        name="validationCropSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image crop size that is input to the neural network for the validation dataset. Must be a
     positive integer."""
    validation_resize_size: Optional[str] = rest_field(
        name="validationResizeSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image size to which to resize before cropping for validation dataset. Must be a positive
     integer."""
    weighted_loss: Optional[str] = rest_field(
        name="weightedLoss", visibility=["read", "create", "update", "delete", "query"]
    )
    """Weighted loss. The accepted values are 0 for no weighted loss.
     1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be
     0 or 1 or 2."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        ams_gradient: Optional[str] = None,
        augmentations: Optional[str] = None,
        beta1: Optional[str] = None,
        beta2: Optional[str] = None,
        distributed: Optional[str] = None,
        early_stopping: Optional[str] = None,
        early_stopping_delay: Optional[str] = None,
        early_stopping_patience: Optional[str] = None,
        enable_onnx_normalization: Optional[str] = None,
        evaluation_frequency: Optional[str] = None,
        gradient_accumulation_step: Optional[str] = None,
        layers_to_freeze: Optional[str] = None,
        learning_rate: Optional[str] = None,
        learning_rate_scheduler: Optional[str] = None,
        model_name: Optional[str] = None,
        momentum: Optional[str] = None,
        nesterov: Optional[str] = None,
        number_of_epochs: Optional[str] = None,
        number_of_workers: Optional[str] = None,
        optimizer: Optional[str] = None,
        random_seed: Optional[str] = None,
        step_lr_gamma: Optional[str] = None,
        step_lr_step_size: Optional[str] = None,
        training_batch_size: Optional[str] = None,
        validation_batch_size: Optional[str] = None,
        warmup_cosine_lr_cycles: Optional[str] = None,
        warmup_cosine_lr_warmup_epochs: Optional[str] = None,
        weight_decay: Optional[str] = None,
        training_crop_size: Optional[str] = None,
        validation_crop_size: Optional[str] = None,
        validation_resize_size: Optional[str] = None,
        weighted_loss: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageModelDistributionSettingsObjectDetection(ImageModelDistributionSettings):  # pylint: disable=name-too-long
    """Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:

    .. code-block::

       ModelName = "choice('seresnext', 'resnest50')";
       LearningRate = "uniform(0.001, 0.01)";
       LayersToFreeze = "choice(0, 2)";
       ```</example>
       For more details on how to compose distribution expressions please check the documentation:
       https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
       For more information on the available settings please visit the official documentation:
       https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.

    :ivar ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
    :vartype ams_gradient: str
    :ivar augmentations: Settings for using Augmentations.
    :vartype augmentations: str
    :ivar beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta1: str
    :ivar beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta2: str
    :ivar distributed: Whether to use distributer training.
    :vartype distributed: str
    :ivar early_stopping: Enable early stopping logic during training.
    :vartype early_stopping: str
    :ivar early_stopping_delay: Minimum number of epochs or validation evaluations to wait before
     primary metric improvement
     is tracked for early stopping. Must be a positive integer.
    :vartype early_stopping_delay: str
    :ivar early_stopping_patience: Minimum number of epochs or validation evaluations with no
     primary metric improvement before
     the run is stopped. Must be a positive integer.
    :vartype early_stopping_patience: str
    :ivar enable_onnx_normalization: Enable normalization when exporting ONNX model.
    :vartype enable_onnx_normalization: str
    :ivar evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must
     be a positive integer.
    :vartype evaluation_frequency: str
    :ivar gradient_accumulation_step: Gradient accumulation means running a configured number of
     "GradAccumulationStep" steps without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer.
    :vartype gradient_accumulation_step: str
    :ivar layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype layers_to_freeze: str
    :ivar learning_rate: Initial learning rate. Must be a float in the range [0, 1].
    :vartype learning_rate: str
    :ivar learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or
     'step'.
    :vartype learning_rate_scheduler: str
    :ivar model_name: Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype model_name: str
    :ivar momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
    :vartype momentum: str
    :ivar nesterov: Enable nesterov when optimizer is 'sgd'.
    :vartype nesterov: str
    :ivar number_of_epochs: Number of training epochs. Must be a positive integer.
    :vartype number_of_epochs: str
    :ivar number_of_workers: Number of data loader workers. Must be a non-negative integer.
    :vartype number_of_workers: str
    :ivar optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
    :vartype optimizer: str
    :ivar random_seed: Random seed to be used when using deterministic training.
    :vartype random_seed: str
    :ivar step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in
     the range [0, 1].
    :vartype step_lr_gamma: str
    :ivar step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a
     positive integer.
    :vartype step_lr_step_size: str
    :ivar training_batch_size: Training batch size. Must be a positive integer.
    :vartype training_batch_size: str
    :ivar validation_batch_size: Validation batch size. Must be a positive integer.
    :vartype validation_batch_size: str
    :ivar warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is
     'warmup_cosine'. Must be a float in the range [0, 1].
    :vartype warmup_cosine_lr_cycles: str
    :ivar warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is
     'warmup_cosine'. Must be a positive integer.
    :vartype warmup_cosine_lr_warmup_epochs: str
    :ivar weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be
     a float in the range[0, 1].
    :vartype weight_decay: str
    :ivar box_detections_per_image: Maximum number of detections per image, for all classes. Must
     be a positive integer.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype box_detections_per_image: str
    :ivar box_score_threshold: During inference, only return proposals with a classification score
     greater than
     BoxScoreThreshold. Must be a float in the range[0, 1].
    :vartype box_score_threshold: str
    :ivar image_size: Image size for train and validation. Must be a positive integer.
     Note: The training run may get into CUDA OOM if the size is too big.
     Note: This settings is only supported for the 'yolov5' algorithm.
    :vartype image_size: str
    :ivar max_size: Maximum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype max_size: str
    :ivar min_size: Minimum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype min_size: str
    :ivar model_size: Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
     Note: training run may get into CUDA OOM if the model size is too big.
     Note: This settings is only supported for the 'yolov5' algorithm.
    :vartype model_size: str
    :ivar multi_scale: Enable multi-scale image by varying image size by +/- 50%.
     Note: training run may get into CUDA OOM if no sufficient GPU memory.
     Note: This settings is only supported for the 'yolov5' algorithm.
    :vartype multi_scale: str
    :ivar nms_iou_threshold: IOU threshold used during inference in NMS post processing. Must be
     float in the range [0, 1].
    :vartype nms_iou_threshold: str
    :ivar tile_grid_size: The grid size to use for tiling each image. Note: TileGridSize must not
     be
     None to enable small object detection logic. A string containing two integers in mxn format.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype tile_grid_size: str
    :ivar tile_overlap_ratio: Overlap ratio between adjacent tiles in each dimension. Must be float
     in the range [0, 1).
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype tile_overlap_ratio: str
    :ivar tile_predictions_nms_threshold: The IOU threshold to use to perform NMS while merging
     predictions from tiles and image.
     Used in validation/ inference. Must be float in the range [0, 1].
     Note: This settings is not supported for the 'yolov5' algorithm.
     NMS: Non-maximum suppression.
    :vartype tile_predictions_nms_threshold: str
    :ivar validation_iou_threshold: IOU threshold to use when computing validation metric. Must be
     float in the range [0, 1].
    :vartype validation_iou_threshold: str
    :ivar validation_metric_type: Metric computation method to use for validation metrics. Must be
     'none', 'coco', 'voc', or 'coco_voc'.
    :vartype validation_metric_type: str
    """

    box_detections_per_image: Optional[str] = rest_field(
        name="boxDetectionsPerImage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum number of detections per image, for all classes. Must be a positive integer.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    box_score_threshold: Optional[str] = rest_field(
        name="boxScoreThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """During inference, only return proposals with a classification score greater than
     BoxScoreThreshold. Must be a float in the range[0, 1]."""
    image_size: Optional[str] = rest_field(name="imageSize", visibility=["read", "create", "update", "delete", "query"])
    """Image size for train and validation. Must be a positive integer.
     Note: The training run may get into CUDA OOM if the size is too big.
     Note: This settings is only supported for the 'yolov5' algorithm."""
    max_size: Optional[str] = rest_field(name="maxSize", visibility=["read", "create", "update", "delete", "query"])
    """Maximum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    min_size: Optional[str] = rest_field(name="minSize", visibility=["read", "create", "update", "delete", "query"])
    """Minimum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    model_size: Optional[str] = rest_field(name="modelSize", visibility=["read", "create", "update", "delete", "query"])
    """Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
     Note: training run may get into CUDA OOM if the model size is too big.
     Note: This settings is only supported for the 'yolov5' algorithm."""
    multi_scale: Optional[str] = rest_field(
        name="multiScale", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable multi-scale image by varying image size by +/- 50%.
     Note: training run may get into CUDA OOM if no sufficient GPU memory.
     Note: This settings is only supported for the 'yolov5' algorithm."""
    nms_iou_threshold: Optional[str] = rest_field(
        name="nmsIouThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1]."""
    tile_grid_size: Optional[str] = rest_field(
        name="tileGridSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The grid size to use for tiling each image. Note: TileGridSize must not be
     None to enable small object detection logic. A string containing two integers in mxn format.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    tile_overlap_ratio: Optional[str] = rest_field(
        name="tileOverlapRatio", visibility=["read", "create", "update", "delete", "query"]
    )
    """Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
     Note: This settings is not supported for the 'yolov5' algorithm."""
    tile_predictions_nms_threshold: Optional[str] = rest_field(
        name="tilePredictionsNmsThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """The IOU threshold to use to perform NMS while merging predictions from tiles and image.
     Used in validation/ inference. Must be float in the range [0, 1].
     Note: This settings is not supported for the 'yolov5' algorithm.
     NMS: Non-maximum suppression."""
    validation_iou_threshold: Optional[str] = rest_field(
        name="validationIouThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """IOU threshold to use when computing validation metric. Must be float in the range [0, 1]."""
    validation_metric_type: Optional[str] = rest_field(
        name="validationMetricType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or
     'coco_voc'."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        ams_gradient: Optional[str] = None,
        augmentations: Optional[str] = None,
        beta1: Optional[str] = None,
        beta2: Optional[str] = None,
        distributed: Optional[str] = None,
        early_stopping: Optional[str] = None,
        early_stopping_delay: Optional[str] = None,
        early_stopping_patience: Optional[str] = None,
        enable_onnx_normalization: Optional[str] = None,
        evaluation_frequency: Optional[str] = None,
        gradient_accumulation_step: Optional[str] = None,
        layers_to_freeze: Optional[str] = None,
        learning_rate: Optional[str] = None,
        learning_rate_scheduler: Optional[str] = None,
        model_name: Optional[str] = None,
        momentum: Optional[str] = None,
        nesterov: Optional[str] = None,
        number_of_epochs: Optional[str] = None,
        number_of_workers: Optional[str] = None,
        optimizer: Optional[str] = None,
        random_seed: Optional[str] = None,
        step_lr_gamma: Optional[str] = None,
        step_lr_step_size: Optional[str] = None,
        training_batch_size: Optional[str] = None,
        validation_batch_size: Optional[str] = None,
        warmup_cosine_lr_cycles: Optional[str] = None,
        warmup_cosine_lr_warmup_epochs: Optional[str] = None,
        weight_decay: Optional[str] = None,
        box_detections_per_image: Optional[str] = None,
        box_score_threshold: Optional[str] = None,
        image_size: Optional[str] = None,
        max_size: Optional[str] = None,
        min_size: Optional[str] = None,
        model_size: Optional[str] = None,
        multi_scale: Optional[str] = None,
        nms_iou_threshold: Optional[str] = None,
        tile_grid_size: Optional[str] = None,
        tile_overlap_ratio: Optional[str] = None,
        tile_predictions_nms_threshold: Optional[str] = None,
        validation_iou_threshold: Optional[str] = None,
        validation_metric_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageModelSettings(_Model):
    """Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
    <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.

    :ivar advanced_settings: Settings for advanced scenarios.
    :vartype advanced_settings: str
    :ivar ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
    :vartype ams_gradient: bool
    :ivar augmentations: Settings for using Augmentations.
    :vartype augmentations: str
    :ivar beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta1: float
    :ivar beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta2: float
    :ivar checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
    :vartype checkpoint_frequency: int
    :ivar checkpoint_model: The pretrained checkpoint model for incremental training.
    :vartype checkpoint_model: ~azure.mgmt.machinelearningservices.models.MLFlowModelJobInput
    :ivar checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for
     incremental training.
    :vartype checkpoint_run_id: str
    :ivar distributed: Whether to use distributed training.
    :vartype distributed: bool
    :ivar early_stopping: Enable early stopping logic during training.
    :vartype early_stopping: bool
    :ivar early_stopping_delay: Minimum number of epochs or validation evaluations to wait before
     primary metric improvement
     is tracked for early stopping. Must be a positive integer.
    :vartype early_stopping_delay: int
    :ivar early_stopping_patience: Minimum number of epochs or validation evaluations with no
     primary metric improvement before
     the run is stopped. Must be a positive integer.
    :vartype early_stopping_patience: int
    :ivar enable_onnx_normalization: Enable normalization when exporting ONNX model.
    :vartype enable_onnx_normalization: bool
    :ivar evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must
     be a positive integer.
    :vartype evaluation_frequency: int
    :ivar gradient_accumulation_step: Gradient accumulation means running a configured number of
     "GradAccumulationStep" steps without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer.
    :vartype gradient_accumulation_step: int
    :ivar layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype layers_to_freeze: int
    :ivar learning_rate: Initial learning rate. Must be a float in the range [0, 1].
    :vartype learning_rate: float
    :ivar learning_rate_scheduler: Learning rate scheduler enum. Known values are: "None",
     "WarmupCosine", and "Step".
    :vartype learning_rate_scheduler: str or
     ~azure.mgmt.machinelearningservices.models.LearningRateScheduler
    :ivar model_name: Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype model_name: str
    :ivar momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
    :vartype momentum: float
    :ivar nesterov: Enable nesterov when optimizer is 'sgd'.
    :vartype nesterov: bool
    :ivar number_of_epochs: Number of training epochs. Must be a positive integer.
    :vartype number_of_epochs: int
    :ivar number_of_workers: Number of data loader workers. Must be a non-negative integer.
    :vartype number_of_workers: int
    :ivar optimizer: Stochastic optimizer for image models. Known values are: "None", "Sgd",
     "Adam", and "Adamw".
    :vartype optimizer: str or ~azure.mgmt.machinelearningservices.models.StochasticOptimizer
    :ivar random_seed: Random seed to be used when using deterministic training.
    :vartype random_seed: int
    :ivar step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in
     the range [0, 1].
    :vartype step_lr_gamma: float
    :ivar step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a
     positive integer.
    :vartype step_lr_step_size: int
    :ivar training_batch_size: Training batch size. Must be a positive integer.
    :vartype training_batch_size: int
    :ivar validation_batch_size: Validation batch size. Must be a positive integer.
    :vartype validation_batch_size: int
    :ivar warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is
     'warmup_cosine'. Must be a float in the range [0, 1].
    :vartype warmup_cosine_lr_cycles: float
    :ivar warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is
     'warmup_cosine'. Must be a positive integer.
    :vartype warmup_cosine_lr_warmup_epochs: int
    :ivar weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be
     a float in the range[0, 1].
    :vartype weight_decay: float
    """

    advanced_settings: Optional[str] = rest_field(
        name="advancedSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for advanced scenarios."""
    ams_gradient: Optional[bool] = rest_field(
        name="amsGradient", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable AMSGrad when optimizer is 'adam' or 'adamw'."""
    augmentations: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Settings for using Augmentations."""
    beta1: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1]."""
    beta2: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1]."""
    checkpoint_frequency: Optional[int] = rest_field(
        name="checkpointFrequency", visibility=["read", "create", "update", "delete", "query"]
    )
    """Frequency to store model checkpoints. Must be a positive integer."""
    checkpoint_model: Optional["_models.MLFlowModelJobInput"] = rest_field(
        name="checkpointModel", visibility=["read", "create", "update", "delete", "query"]
    )
    """The pretrained checkpoint model for incremental training."""
    checkpoint_run_id: Optional[str] = rest_field(
        name="checkpointRunId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The id of a previous run that has a pretrained checkpoint for incremental training."""
    distributed: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Whether to use distributed training."""
    early_stopping: Optional[bool] = rest_field(
        name="earlyStopping", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable early stopping logic during training."""
    early_stopping_delay: Optional[int] = rest_field(
        name="earlyStoppingDelay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Minimum number of epochs or validation evaluations to wait before primary metric improvement
     is tracked for early stopping. Must be a positive integer."""
    early_stopping_patience: Optional[int] = rest_field(
        name="earlyStoppingPatience", visibility=["read", "create", "update", "delete", "query"]
    )
    """Minimum number of epochs or validation evaluations with no primary metric improvement before
     the run is stopped. Must be a positive integer."""
    enable_onnx_normalization: Optional[bool] = rest_field(
        name="enableOnnxNormalization", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable normalization when exporting ONNX model."""
    evaluation_frequency: Optional[int] = rest_field(
        name="evaluationFrequency", visibility=["read", "create", "update", "delete", "query"]
    )
    """Frequency to evaluate validation dataset to get metric scores. Must be a positive integer."""
    gradient_accumulation_step: Optional[int] = rest_field(
        name="gradientAccumulationStep", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gradient accumulation means running a configured number of \"GradAccumulationStep\" steps
     without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer."""
    layers_to_freeze: Optional[int] = rest_field(
        name="layersToFreeze", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_."""
    learning_rate: Optional[float] = rest_field(
        name="learningRate", visibility=["read", "create", "update", "delete", "query"]
    )
    """Initial learning rate. Must be a float in the range [0, 1]."""
    learning_rate_scheduler: Optional[Union[str, "_models.LearningRateScheduler"]] = rest_field(
        name="learningRateScheduler", visibility=["read", "create", "update", "delete", "query"]
    )
    """Learning rate scheduler enum. Known values are: \"None\", \"WarmupCosine\", and \"Step\"."""
    model_name: Optional[str] = rest_field(name="modelName", visibility=["read", "create", "update", "delete", "query"])
    """Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_."""
    momentum: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1]."""
    nesterov: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Enable nesterov when optimizer is 'sgd'."""
    number_of_epochs: Optional[int] = rest_field(
        name="numberOfEpochs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of training epochs. Must be a positive integer."""
    number_of_workers: Optional[int] = rest_field(
        name="numberOfWorkers", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of data loader workers. Must be a non-negative integer."""
    optimizer: Optional[Union[str, "_models.StochasticOptimizer"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Stochastic optimizer for image models. Known values are: \"None\", \"Sgd\", \"Adam\", and
     \"Adamw\"."""
    random_seed: Optional[int] = rest_field(
        name="randomSeed", visibility=["read", "create", "update", "delete", "query"]
    )
    """Random seed to be used when using deterministic training."""
    step_lr_gamma: Optional[float] = rest_field(
        name="stepLRGamma", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1]."""
    step_lr_step_size: Optional[int] = rest_field(
        name="stepLRStepSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of step size when learning rate scheduler is 'step'. Must be a positive integer."""
    training_batch_size: Optional[int] = rest_field(
        name="trainingBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Training batch size. Must be a positive integer."""
    validation_batch_size: Optional[int] = rest_field(
        name="validationBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation batch size. Must be a positive integer."""
    warmup_cosine_lr_cycles: Optional[float] = rest_field(
        name="warmupCosineLRCycles", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the
     range [0, 1]."""
    warmup_cosine_lr_warmup_epochs: Optional[int] = rest_field(
        name="warmupCosineLRWarmupEpochs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive
     integer."""
    weight_decay: Optional[float] = rest_field(
        name="weightDecay", visibility=["read", "create", "update", "delete", "query"]
    )
    """Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the
     range[0, 1]."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        advanced_settings: Optional[str] = None,
        ams_gradient: Optional[bool] = None,
        augmentations: Optional[str] = None,
        beta1: Optional[float] = None,
        beta2: Optional[float] = None,
        checkpoint_frequency: Optional[int] = None,
        checkpoint_model: Optional["_models.MLFlowModelJobInput"] = None,
        checkpoint_run_id: Optional[str] = None,
        distributed: Optional[bool] = None,
        early_stopping: Optional[bool] = None,
        early_stopping_delay: Optional[int] = None,
        early_stopping_patience: Optional[int] = None,
        enable_onnx_normalization: Optional[bool] = None,
        evaluation_frequency: Optional[int] = None,
        gradient_accumulation_step: Optional[int] = None,
        layers_to_freeze: Optional[int] = None,
        learning_rate: Optional[float] = None,
        learning_rate_scheduler: Optional[Union[str, "_models.LearningRateScheduler"]] = None,
        model_name: Optional[str] = None,
        momentum: Optional[float] = None,
        nesterov: Optional[bool] = None,
        number_of_epochs: Optional[int] = None,
        number_of_workers: Optional[int] = None,
        optimizer: Optional[Union[str, "_models.StochasticOptimizer"]] = None,
        random_seed: Optional[int] = None,
        step_lr_gamma: Optional[float] = None,
        step_lr_step_size: Optional[int] = None,
        training_batch_size: Optional[int] = None,
        validation_batch_size: Optional[int] = None,
        warmup_cosine_lr_cycles: Optional[float] = None,
        warmup_cosine_lr_warmup_epochs: Optional[int] = None,
        weight_decay: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageModelSettingsClassification(ImageModelSettings):
    """Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
    <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.

    :ivar advanced_settings: Settings for advanced scenarios.
    :vartype advanced_settings: str
    :ivar ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
    :vartype ams_gradient: bool
    :ivar augmentations: Settings for using Augmentations.
    :vartype augmentations: str
    :ivar beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta1: float
    :ivar beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta2: float
    :ivar checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
    :vartype checkpoint_frequency: int
    :ivar checkpoint_model: The pretrained checkpoint model for incremental training.
    :vartype checkpoint_model: ~azure.mgmt.machinelearningservices.models.MLFlowModelJobInput
    :ivar checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for
     incremental training.
    :vartype checkpoint_run_id: str
    :ivar distributed: Whether to use distributed training.
    :vartype distributed: bool
    :ivar early_stopping: Enable early stopping logic during training.
    :vartype early_stopping: bool
    :ivar early_stopping_delay: Minimum number of epochs or validation evaluations to wait before
     primary metric improvement
     is tracked for early stopping. Must be a positive integer.
    :vartype early_stopping_delay: int
    :ivar early_stopping_patience: Minimum number of epochs or validation evaluations with no
     primary metric improvement before
     the run is stopped. Must be a positive integer.
    :vartype early_stopping_patience: int
    :ivar enable_onnx_normalization: Enable normalization when exporting ONNX model.
    :vartype enable_onnx_normalization: bool
    :ivar evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must
     be a positive integer.
    :vartype evaluation_frequency: int
    :ivar gradient_accumulation_step: Gradient accumulation means running a configured number of
     "GradAccumulationStep" steps without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer.
    :vartype gradient_accumulation_step: int
    :ivar layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype layers_to_freeze: int
    :ivar learning_rate: Initial learning rate. Must be a float in the range [0, 1].
    :vartype learning_rate: float
    :ivar learning_rate_scheduler: Learning rate scheduler enum. Known values are: "None",
     "WarmupCosine", and "Step".
    :vartype learning_rate_scheduler: str or
     ~azure.mgmt.machinelearningservices.models.LearningRateScheduler
    :ivar model_name: Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype model_name: str
    :ivar momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
    :vartype momentum: float
    :ivar nesterov: Enable nesterov when optimizer is 'sgd'.
    :vartype nesterov: bool
    :ivar number_of_epochs: Number of training epochs. Must be a positive integer.
    :vartype number_of_epochs: int
    :ivar number_of_workers: Number of data loader workers. Must be a non-negative integer.
    :vartype number_of_workers: int
    :ivar optimizer: Stochastic optimizer for image models. Known values are: "None", "Sgd",
     "Adam", and "Adamw".
    :vartype optimizer: str or ~azure.mgmt.machinelearningservices.models.StochasticOptimizer
    :ivar random_seed: Random seed to be used when using deterministic training.
    :vartype random_seed: int
    :ivar step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in
     the range [0, 1].
    :vartype step_lr_gamma: float
    :ivar step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a
     positive integer.
    :vartype step_lr_step_size: int
    :ivar training_batch_size: Training batch size. Must be a positive integer.
    :vartype training_batch_size: int
    :ivar validation_batch_size: Validation batch size. Must be a positive integer.
    :vartype validation_batch_size: int
    :ivar warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is
     'warmup_cosine'. Must be a float in the range [0, 1].
    :vartype warmup_cosine_lr_cycles: float
    :ivar warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is
     'warmup_cosine'. Must be a positive integer.
    :vartype warmup_cosine_lr_warmup_epochs: int
    :ivar weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be
     a float in the range[0, 1].
    :vartype weight_decay: float
    :ivar training_crop_size: Image crop size that is input to the neural network for the training
     dataset. Must be a positive integer.
    :vartype training_crop_size: int
    :ivar validation_crop_size: Image crop size that is input to the neural network for the
     validation dataset. Must be a positive integer.
    :vartype validation_crop_size: int
    :ivar validation_resize_size: Image size to which to resize before cropping for validation
     dataset. Must be a positive integer.
    :vartype validation_resize_size: int
    :ivar weighted_loss: Weighted loss. The accepted values are 0 for no weighted loss.
     1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be
     0 or 1 or 2.
    :vartype weighted_loss: int
    """

    training_crop_size: Optional[int] = rest_field(
        name="trainingCropSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image crop size that is input to the neural network for the training dataset. Must be a
     positive integer."""
    validation_crop_size: Optional[int] = rest_field(
        name="validationCropSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image crop size that is input to the neural network for the validation dataset. Must be a
     positive integer."""
    validation_resize_size: Optional[int] = rest_field(
        name="validationResizeSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image size to which to resize before cropping for validation dataset. Must be a positive
     integer."""
    weighted_loss: Optional[int] = rest_field(
        name="weightedLoss", visibility=["read", "create", "update", "delete", "query"]
    )
    """Weighted loss. The accepted values are 0 for no weighted loss.
     1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be
     0 or 1 or 2."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        advanced_settings: Optional[str] = None,
        ams_gradient: Optional[bool] = None,
        augmentations: Optional[str] = None,
        beta1: Optional[float] = None,
        beta2: Optional[float] = None,
        checkpoint_frequency: Optional[int] = None,
        checkpoint_model: Optional["_models.MLFlowModelJobInput"] = None,
        checkpoint_run_id: Optional[str] = None,
        distributed: Optional[bool] = None,
        early_stopping: Optional[bool] = None,
        early_stopping_delay: Optional[int] = None,
        early_stopping_patience: Optional[int] = None,
        enable_onnx_normalization: Optional[bool] = None,
        evaluation_frequency: Optional[int] = None,
        gradient_accumulation_step: Optional[int] = None,
        layers_to_freeze: Optional[int] = None,
        learning_rate: Optional[float] = None,
        learning_rate_scheduler: Optional[Union[str, "_models.LearningRateScheduler"]] = None,
        model_name: Optional[str] = None,
        momentum: Optional[float] = None,
        nesterov: Optional[bool] = None,
        number_of_epochs: Optional[int] = None,
        number_of_workers: Optional[int] = None,
        optimizer: Optional[Union[str, "_models.StochasticOptimizer"]] = None,
        random_seed: Optional[int] = None,
        step_lr_gamma: Optional[float] = None,
        step_lr_step_size: Optional[int] = None,
        training_batch_size: Optional[int] = None,
        validation_batch_size: Optional[int] = None,
        warmup_cosine_lr_cycles: Optional[float] = None,
        warmup_cosine_lr_warmup_epochs: Optional[int] = None,
        weight_decay: Optional[float] = None,
        training_crop_size: Optional[int] = None,
        validation_crop_size: Optional[int] = None,
        validation_resize_size: Optional[int] = None,
        weighted_loss: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageModelSettingsObjectDetection(ImageModelSettings):
    """Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
    <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.

    :ivar advanced_settings: Settings for advanced scenarios.
    :vartype advanced_settings: str
    :ivar ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
    :vartype ams_gradient: bool
    :ivar augmentations: Settings for using Augmentations.
    :vartype augmentations: str
    :ivar beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta1: float
    :ivar beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range
     [0, 1].
    :vartype beta2: float
    :ivar checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
    :vartype checkpoint_frequency: int
    :ivar checkpoint_model: The pretrained checkpoint model for incremental training.
    :vartype checkpoint_model: ~azure.mgmt.machinelearningservices.models.MLFlowModelJobInput
    :ivar checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for
     incremental training.
    :vartype checkpoint_run_id: str
    :ivar distributed: Whether to use distributed training.
    :vartype distributed: bool
    :ivar early_stopping: Enable early stopping logic during training.
    :vartype early_stopping: bool
    :ivar early_stopping_delay: Minimum number of epochs or validation evaluations to wait before
     primary metric improvement
     is tracked for early stopping. Must be a positive integer.
    :vartype early_stopping_delay: int
    :ivar early_stopping_patience: Minimum number of epochs or validation evaluations with no
     primary metric improvement before
     the run is stopped. Must be a positive integer.
    :vartype early_stopping_patience: int
    :ivar enable_onnx_normalization: Enable normalization when exporting ONNX model.
    :vartype enable_onnx_normalization: bool
    :ivar evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must
     be a positive integer.
    :vartype evaluation_frequency: int
    :ivar gradient_accumulation_step: Gradient accumulation means running a configured number of
     "GradAccumulationStep" steps without
     updating the model weights while accumulating the gradients of those steps, and then using
     the accumulated gradients to compute the weight updates. Must be a positive integer.
    :vartype gradient_accumulation_step: int
    :ivar layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
     For instance, passing 2 as value for 'seresnext' means
     freezing layer0 and layer1. For a full list of models supported and details on layer freeze,
     please
     see: `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype layers_to_freeze: int
    :ivar learning_rate: Initial learning rate. Must be a float in the range [0, 1].
    :vartype learning_rate: float
    :ivar learning_rate_scheduler: Learning rate scheduler enum. Known values are: "None",
     "WarmupCosine", and "Step".
    :vartype learning_rate_scheduler: str or
     ~azure.mgmt.machinelearningservices.models.LearningRateScheduler
    :ivar model_name: Name of the model to use for training.
     For more information on the available models please visit the official documentation:
     `https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models
     <https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models>`_.
    :vartype model_name: str
    :ivar momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
    :vartype momentum: float
    :ivar nesterov: Enable nesterov when optimizer is 'sgd'.
    :vartype nesterov: bool
    :ivar number_of_epochs: Number of training epochs. Must be a positive integer.
    :vartype number_of_epochs: int
    :ivar number_of_workers: Number of data loader workers. Must be a non-negative integer.
    :vartype number_of_workers: int
    :ivar optimizer: Stochastic optimizer for image models. Known values are: "None", "Sgd",
     "Adam", and "Adamw".
    :vartype optimizer: str or ~azure.mgmt.machinelearningservices.models.StochasticOptimizer
    :ivar random_seed: Random seed to be used when using deterministic training.
    :vartype random_seed: int
    :ivar step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in
     the range [0, 1].
    :vartype step_lr_gamma: float
    :ivar step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a
     positive integer.
    :vartype step_lr_step_size: int
    :ivar training_batch_size: Training batch size. Must be a positive integer.
    :vartype training_batch_size: int
    :ivar validation_batch_size: Validation batch size. Must be a positive integer.
    :vartype validation_batch_size: int
    :ivar warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is
     'warmup_cosine'. Must be a float in the range [0, 1].
    :vartype warmup_cosine_lr_cycles: float
    :ivar warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is
     'warmup_cosine'. Must be a positive integer.
    :vartype warmup_cosine_lr_warmup_epochs: int
    :ivar weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be
     a float in the range[0, 1].
    :vartype weight_decay: float
    :ivar box_detections_per_image: Maximum number of detections per image, for all classes. Must
     be a positive integer.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype box_detections_per_image: int
    :ivar box_score_threshold: During inference, only return proposals with a classification score
     greater than
     BoxScoreThreshold. Must be a float in the range[0, 1].
    :vartype box_score_threshold: float
    :ivar image_size: Image size for train and validation. Must be a positive integer.
     Note: The training run may get into CUDA OOM if the size is too big.
     Note: This settings is only supported for the 'yolov5' algorithm.
    :vartype image_size: int
    :ivar max_size: Maximum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype max_size: int
    :ivar min_size: Minimum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype min_size: int
    :ivar model_size: Image model size. Known values are: "None", "Small", "Medium", "Large", and
     "ExtraLarge".
    :vartype model_size: str or ~azure.mgmt.machinelearningservices.models.ModelSize
    :ivar multi_scale: Enable multi-scale image by varying image size by +/- 50%.
     Note: training run may get into CUDA OOM if no sufficient GPU memory.
     Note: This settings is only supported for the 'yolov5' algorithm.
    :vartype multi_scale: bool
    :ivar nms_iou_threshold: IOU threshold used during inference in NMS post processing. Must be a
     float in the range [0, 1].
    :vartype nms_iou_threshold: float
    :ivar tile_grid_size: The grid size to use for tiling each image. Note: TileGridSize must not
     be
     None to enable small object detection logic. A string containing two integers in mxn format.
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype tile_grid_size: str
    :ivar tile_overlap_ratio: Overlap ratio between adjacent tiles in each dimension. Must be float
     in the range [0, 1).
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype tile_overlap_ratio: float
    :ivar tile_predictions_nms_threshold: The IOU threshold to use to perform NMS while merging
     predictions from tiles and image.
     Used in validation/ inference. Must be float in the range [0, 1].
     Note: This settings is not supported for the 'yolov5' algorithm.
    :vartype tile_predictions_nms_threshold: float
    :ivar validation_iou_threshold: IOU threshold to use when computing validation metric. Must be
     float in the range [0, 1].
    :vartype validation_iou_threshold: float
    :ivar validation_metric_type: Metric computation method to use for validation metrics in image
     tasks. Known values are: "None", "Coco", "Voc", and "CocoVoc".
    :vartype validation_metric_type: str or
     ~azure.mgmt.machinelearningservices.models.ValidationMetricType
    """

    box_detections_per_image: Optional[int] = rest_field(
        name="boxDetectionsPerImage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum number of detections per image, for all classes. Must be a positive integer.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    box_score_threshold: Optional[float] = rest_field(
        name="boxScoreThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """During inference, only return proposals with a classification score greater than
     BoxScoreThreshold. Must be a float in the range[0, 1]."""
    image_size: Optional[int] = rest_field(name="imageSize", visibility=["read", "create", "update", "delete", "query"])
    """Image size for train and validation. Must be a positive integer.
     Note: The training run may get into CUDA OOM if the size is too big.
     Note: This settings is only supported for the 'yolov5' algorithm."""
    max_size: Optional[int] = rest_field(name="maxSize", visibility=["read", "create", "update", "delete", "query"])
    """Maximum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    min_size: Optional[int] = rest_field(name="minSize", visibility=["read", "create", "update", "delete", "query"])
    """Minimum size of the image to be rescaled before feeding it to the backbone.
     Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    model_size: Optional[Union[str, "_models.ModelSize"]] = rest_field(
        name="modelSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Image model size. Known values are: \"None\", \"Small\", \"Medium\", \"Large\", and
     \"ExtraLarge\"."""
    multi_scale: Optional[bool] = rest_field(
        name="multiScale", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable multi-scale image by varying image size by +/- 50%.
     Note: training run may get into CUDA OOM if no sufficient GPU memory.
     Note: This settings is only supported for the 'yolov5' algorithm."""
    nms_iou_threshold: Optional[float] = rest_field(
        name="nmsIouThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """IOU threshold used during inference in NMS post processing. Must be a float in the range [0,
     1]."""
    tile_grid_size: Optional[str] = rest_field(
        name="tileGridSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The grid size to use for tiling each image. Note: TileGridSize must not be
     None to enable small object detection logic. A string containing two integers in mxn format.
     Note: This settings is not supported for the 'yolov5' algorithm."""
    tile_overlap_ratio: Optional[float] = rest_field(
        name="tileOverlapRatio", visibility=["read", "create", "update", "delete", "query"]
    )
    """Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
     Note: This settings is not supported for the 'yolov5' algorithm."""
    tile_predictions_nms_threshold: Optional[float] = rest_field(
        name="tilePredictionsNmsThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """The IOU threshold to use to perform NMS while merging predictions from tiles and image.
     Used in validation/ inference. Must be float in the range [0, 1].
     Note: This settings is not supported for the 'yolov5' algorithm."""
    validation_iou_threshold: Optional[float] = rest_field(
        name="validationIouThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """IOU threshold to use when computing validation metric. Must be float in the range [0, 1]."""
    validation_metric_type: Optional[Union[str, "_models.ValidationMetricType"]] = rest_field(
        name="validationMetricType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Metric computation method to use for validation metrics in image tasks. Known values are:
     \"None\", \"Coco\", \"Voc\", and \"CocoVoc\"."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        advanced_settings: Optional[str] = None,
        ams_gradient: Optional[bool] = None,
        augmentations: Optional[str] = None,
        beta1: Optional[float] = None,
        beta2: Optional[float] = None,
        checkpoint_frequency: Optional[int] = None,
        checkpoint_model: Optional["_models.MLFlowModelJobInput"] = None,
        checkpoint_run_id: Optional[str] = None,
        distributed: Optional[bool] = None,
        early_stopping: Optional[bool] = None,
        early_stopping_delay: Optional[int] = None,
        early_stopping_patience: Optional[int] = None,
        enable_onnx_normalization: Optional[bool] = None,
        evaluation_frequency: Optional[int] = None,
        gradient_accumulation_step: Optional[int] = None,
        layers_to_freeze: Optional[int] = None,
        learning_rate: Optional[float] = None,
        learning_rate_scheduler: Optional[Union[str, "_models.LearningRateScheduler"]] = None,
        model_name: Optional[str] = None,
        momentum: Optional[float] = None,
        nesterov: Optional[bool] = None,
        number_of_epochs: Optional[int] = None,
        number_of_workers: Optional[int] = None,
        optimizer: Optional[Union[str, "_models.StochasticOptimizer"]] = None,
        random_seed: Optional[int] = None,
        step_lr_gamma: Optional[float] = None,
        step_lr_step_size: Optional[int] = None,
        training_batch_size: Optional[int] = None,
        validation_batch_size: Optional[int] = None,
        warmup_cosine_lr_cycles: Optional[float] = None,
        warmup_cosine_lr_warmup_epochs: Optional[int] = None,
        weight_decay: Optional[float] = None,
        box_detections_per_image: Optional[int] = None,
        box_score_threshold: Optional[float] = None,
        image_size: Optional[int] = None,
        max_size: Optional[int] = None,
        min_size: Optional[int] = None,
        model_size: Optional[Union[str, "_models.ModelSize"]] = None,
        multi_scale: Optional[bool] = None,
        nms_iou_threshold: Optional[float] = None,
        tile_grid_size: Optional[str] = None,
        tile_overlap_ratio: Optional[float] = None,
        tile_predictions_nms_threshold: Optional[float] = None,
        validation_iou_threshold: Optional[float] = None,
        validation_metric_type: Optional[Union[str, "_models.ValidationMetricType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ImageObjectDetection(AutoMLVertical, discriminator="ImageObjectDetection"):
    """Image Object Detection. Object detection is used to identify objects in an image and locate
    each object with a
    bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar model_settings: Settings used for training the model.
    :vartype model_settings:
     ~azure.mgmt.machinelearningservices.models.ImageModelSettingsObjectDetection
    :ivar search_space: Search space for sampling different combinations of models and their
     hyperparameters.
    :vartype search_space:
     list[~azure.mgmt.machinelearningservices.models.ImageModelDistributionSettingsObjectDetection]
    :ivar limit_settings: [Required] Limit settings for the AutoML job. Required.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.ImageLimitSettings
    :ivar sweep_settings: Model sweeping and hyperparameter sweeping related settings.
    :vartype sweep_settings: ~azure.mgmt.machinelearningservices.models.ImageSweepSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar primary_metric: Primary metrics for Image ObjectDetection task. "MeanAveragePrecision"
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ObjectDetectionPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Image Object Detection. Object
     detection is used to identify objects in an image and locate each object with a
     bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.IMAGE_OBJECT_DETECTION
    """

    model_settings: Optional["_models.ImageModelSettingsObjectDetection"] = rest_field(
        name="modelSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings used for training the model."""
    search_space: Optional[list["_models.ImageModelDistributionSettingsObjectDetection"]] = rest_field(
        name="searchSpace", visibility=["read", "create", "update", "delete", "query"]
    )
    """Search space for sampling different combinations of models and their hyperparameters."""
    limit_settings: "_models.ImageLimitSettings" = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Limit settings for the AutoML job. Required."""
    sweep_settings: Optional["_models.ImageSweepSettings"] = rest_field(
        name="sweepSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Model sweeping and hyperparameter sweeping related settings."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    primary_metric: Optional[Union[str, "_models.ObjectDetectionPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for Image ObjectDetection task. \"MeanAveragePrecision\""""
    task_type: Literal[TaskType.IMAGE_OBJECT_DETECTION] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Image Object Detection. Object detection is used
     to identify objects in an image and locate each object with a
     bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        limit_settings: "_models.ImageLimitSettings",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        model_settings: Optional["_models.ImageModelSettingsObjectDetection"] = None,
        search_space: Optional[list["_models.ImageModelDistributionSettingsObjectDetection"]] = None,
        sweep_settings: Optional["_models.ImageSweepSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        primary_metric: Optional[Union[str, "_models.ObjectDetectionPrimaryMetrics"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.IMAGE_OBJECT_DETECTION  # type: ignore


class ImageSweepSettings(_Model):
    """Model sweeping and hyperparameter sweeping related settings.

    :ivar early_termination: Type of early termination policy.
    :vartype early_termination: ~azure.mgmt.machinelearningservices.models.EarlyTerminationPolicy
    :ivar sampling_algorithm: [Required] Type of the hyperparameter sampling algorithms. Required.
     Known values are: "Grid", "Random", and "Bayesian".
    :vartype sampling_algorithm: str or
     ~azure.mgmt.machinelearningservices.models.SamplingAlgorithmType
    """

    early_termination: Optional["_models.EarlyTerminationPolicy"] = rest_field(
        name="earlyTermination", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of early termination policy."""
    sampling_algorithm: Union[str, "_models.SamplingAlgorithmType"] = rest_field(
        name="samplingAlgorithm", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Type of the hyperparameter sampling algorithms. Required. Known values are:
     \"Grid\", \"Random\", and \"Bayesian\"."""

    @overload
    def __init__(
        self,
        *,
        sampling_algorithm: Union[str, "_models.SamplingAlgorithmType"],
        early_termination: Optional["_models.EarlyTerminationPolicy"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexColumn(_Model):
    """DTO object representing index column.

    :ivar column_name: Specifies the column name.
    :vartype column_name: str
    :ivar data_type: Specifies the data type. Known values are: "String", "Integer", "Long",
     "Float", "Double", "Binary", "Datetime", and "Boolean".
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.FeatureDataType
    """

    column_name: Optional[str] = rest_field(
        name="columnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the column name."""
    data_type: Optional[Union[str, "_models.FeatureDataType"]] = rest_field(
        name="dataType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the data type. Known values are: \"String\", \"Integer\", \"Long\", \"Float\",
     \"Double\", \"Binary\", \"Datetime\", and \"Boolean\"."""

    @overload
    def __init__(
        self,
        *,
        column_name: Optional[str] = None,
        data_type: Optional[Union[str, "_models.FeatureDataType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferenceContainerProperties(_Model):
    """InferenceContainerProperties.

    :ivar liveness_route: The route to check the liveness of the inference server container.
    :vartype liveness_route: ~azure.mgmt.machinelearningservices.models.Route
    :ivar readiness_route: The route to check the readiness of the inference server container.
    :vartype readiness_route: ~azure.mgmt.machinelearningservices.models.Route
    :ivar scoring_route: The port to send the scoring requests to, within the inference server
     container.
    :vartype scoring_route: ~azure.mgmt.machinelearningservices.models.Route
    :ivar startup_route: The route to check the startup of the application in the container.
    :vartype startup_route: ~azure.mgmt.machinelearningservices.models.Route
    """

    liveness_route: Optional["_models.Route"] = rest_field(
        name="livenessRoute", visibility=["read", "create", "update", "delete", "query"]
    )
    """The route to check the liveness of the inference server container."""
    readiness_route: Optional["_models.Route"] = rest_field(
        name="readinessRoute", visibility=["read", "create", "update", "delete", "query"]
    )
    """The route to check the readiness of the inference server container."""
    scoring_route: Optional["_models.Route"] = rest_field(
        name="scoringRoute", visibility=["read", "create", "update", "delete", "query"]
    )
    """The port to send the scoring requests to, within the inference server container."""
    startup_route: Optional["_models.Route"] = rest_field(
        name="startupRoute", visibility=["read", "create", "update", "delete", "query"]
    )
    """The route to check the startup of the application in the container."""

    @overload
    def __init__(
        self,
        *,
        liveness_route: Optional["_models.Route"] = None,
        readiness_route: Optional["_models.Route"] = None,
        scoring_route: Optional["_models.Route"] = None,
        startup_route: Optional["_models.Route"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferenceEndpoint(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.InferenceEndpointProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.InferenceEndpointProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.InferenceEndpointProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PropertiesBase(_Model):
    """Base definition for pool resources.

    :ivar description: Description of the resource.
    :vartype description: str
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: list[~azure.mgmt.machinelearningservices.models.StringStringKeyValuePair]
    """

    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the resource."""
    properties: Optional[list["_models.StringStringKeyValuePair"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Property dictionary. Properties can be added, but not removed or altered."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[list["_models.StringStringKeyValuePair"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferenceEndpointProperties(PropertiesBase):
    """InferenceEndpoint configuration.

    :ivar description: Description of the resource.
    :vartype description: str
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: list[~azure.mgmt.machinelearningservices.models.StringStringKeyValuePair]
    :ivar auth_mode: [Required] Authentication mode for the endpoint. Required. "AAD"
    :vartype auth_mode: str or ~azure.mgmt.machinelearningservices.models.AuthMode
    :ivar endpoint_uri: Endpoint URI for the inference endpoint.
    :vartype endpoint_uri: str
    :ivar group_name: [Required] Group within the same pool with which this endpoint needs to be
     associated with. Required.
    :vartype group_name: str
    :ivar provisioning_state: Provisioning state for the endpoint. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.PoolProvisioningState
    :ivar request_configuration: RequestConfiguration for endpoint.
    :vartype request_configuration: ~azure.mgmt.machinelearningservices.models.RequestConfiguration
    """

    auth_mode: Union[str, "_models.AuthMode"] = rest_field(
        name="authMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Authentication mode for the endpoint. Required. \"AAD\""""
    endpoint_uri: Optional[str] = rest_field(name="endpointUri", visibility=["read"])
    """Endpoint URI for the inference endpoint."""
    group_name: str = rest_field(name="groupName", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Group within the same pool with which this endpoint needs to be associated with.
     Required."""
    provisioning_state: Optional[Union[str, "_models.PoolProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint. Known values are: \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""
    request_configuration: Optional["_models.RequestConfiguration"] = rest_field(
        name="requestConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """RequestConfiguration for endpoint."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.AuthMode"],
        group_name: str,
        description: Optional[str] = None,
        properties: Optional[list["_models.StringStringKeyValuePair"]] = None,
        request_configuration: Optional["_models.RequestConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferenceGroup(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.InferenceGroupProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.InferenceGroupProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.InferenceGroupProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferenceGroupProperties(PropertiesBase):
    """Inference group configuration.

    :ivar description: Description of the resource.
    :vartype description: str
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: list[~azure.mgmt.machinelearningservices.models.StringStringKeyValuePair]
    :ivar environment_configuration: Gets or sets environment configuration for the inference
     group. Used if PoolType=ScaleUnit.
    :vartype environment_configuration:
     ~azure.mgmt.machinelearningservices.models.GroupEnvironmentConfiguration
    :ivar model_configuration: Gets or sets model configuration for the inference group. Used if
     PoolType=ScaleUnit.
    :vartype model_configuration:
     ~azure.mgmt.machinelearningservices.models.GroupModelConfiguration
    :ivar node_sku_type: Gets or sets compute instance type.
    :vartype node_sku_type: str
    :ivar provisioning_state: Provisioning state for the inference group. Known values are:
     "Creating", "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.PoolProvisioningState
    :ivar scale_unit_size: Gets or sets Scale Unit size.
    :vartype scale_unit_size: int
    """

    environment_configuration: Optional["_models.GroupEnvironmentConfiguration"] = rest_field(
        name="environmentConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets environment configuration for the inference group. Used if PoolType=ScaleUnit."""
    model_configuration: Optional["_models.GroupModelConfiguration"] = rest_field(
        name="modelConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets model configuration for the inference group. Used if PoolType=ScaleUnit."""
    node_sku_type: Optional[str] = rest_field(
        name="nodeSkuType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets compute instance type."""
    provisioning_state: Optional[Union[str, "_models.PoolProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the inference group. Known values are: \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""
    scale_unit_size: Optional[int] = rest_field(
        name="scaleUnitSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets Scale Unit size."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[list["_models.StringStringKeyValuePair"]] = None,
        environment_configuration: Optional["_models.GroupEnvironmentConfiguration"] = None,
        model_configuration: Optional["_models.GroupModelConfiguration"] = None,
        node_sku_type: Optional[str] = None,
        scale_unit_size: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferencePool(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.InferencePoolProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.InferencePoolProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.InferencePoolProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InferencePoolProperties(PropertiesBase):
    """Inference pool configuration.

    :ivar description: Description of the resource.
    :vartype description: str
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: list[~azure.mgmt.machinelearningservices.models.StringStringKeyValuePair]
    :ivar provisioning_state: Provisioning state for the pool. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.PoolProvisioningState
    :ivar scale_unit_configuration: Gets or sets ScaleUnitConfiguration for the inference pool.
     Used if PoolType=ScaleUnit.
    :vartype scale_unit_configuration:
     ~azure.mgmt.machinelearningservices.models.ScaleUnitConfiguration
    """

    provisioning_state: Optional[Union[str, "_models.PoolProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the pool. Known values are: \"Creating\", \"Deleting\", \"Succeeded\",
     \"Failed\", \"Updating\", and \"Canceled\"."""
    scale_unit_configuration: Optional["_models.ScaleUnitConfiguration"] = rest_field(
        name="scaleUnitConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets ScaleUnitConfiguration for the inference pool. Used if PoolType=ScaleUnit."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[list["_models.StringStringKeyValuePair"]] = None,
        scale_unit_configuration: Optional["_models.ScaleUnitConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstanceTypeSchema(_Model):
    """Instance type schema.

    :ivar node_selector: Node Selector.
    :vartype node_selector: dict[str, str]
    :ivar resources: Resource requests/limits for this instance type.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.InstanceTypeSchemaResources
    """

    node_selector: Optional[dict[str, str]] = rest_field(
        name="nodeSelector", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node Selector."""
    resources: Optional["_models.InstanceTypeSchemaResources"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource requests/limits for this instance type."""

    @overload
    def __init__(
        self,
        *,
        node_selector: Optional[dict[str, str]] = None,
        resources: Optional["_models.InstanceTypeSchemaResources"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstanceTypeSchemaResources(_Model):
    """Resource requests/limits for this instance type.

    :ivar requests: Resource requests for this instance type.
    :vartype requests: dict[str, str]
    :ivar limits: Resource limits for this instance type.
    :vartype limits: dict[str, str]
    """

    requests: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource requests for this instance type."""
    limits: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource limits for this instance type."""

    @overload
    def __init__(
        self,
        *,
        requests: Optional[dict[str, str]] = None,
        limits: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IPRule(_Model):
    """Contains an IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or
    '124.56.78.0/24' (all addresses that start with 124.56.78). Value could be 'Allow' or  'Deny'.

    :ivar value: An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address)
     or '124.56.78.0/24' (all addresses that start with 124.56.78). Value could be 'Allow' or
     'Deny'.
    :vartype value: str
    """

    value: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or
     '124.56.78.0/24' (all addresses that start with 124.56.78). Value could be 'Allow' or  'Deny'."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobBase(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.JobBaseProperties
    """

    properties: "_models.JobBaseProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.JobBaseProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobResourceConfiguration(ResourceConfiguration):
    """JobResourceConfiguration.

    :ivar instance_count: Optional number of instances or nodes used by the compute target.
    :vartype instance_count: int
    :ivar instance_type: Optional type of VM used as supported by the compute target.
    :vartype instance_type: str
    :ivar properties: Additional properties bag.
    :vartype properties: dict[str, any]
    :ivar docker_args: Extra arguments to pass to the Docker run command. This would override any
     parameters that have already been set by the system, or in this section. This parameter is only
     supported for Azure ML compute types.
    :vartype docker_args: str
    :ivar docker_args_list: Extra arguments to pass to the Docker run command, as a collection.
     This would override any parameters that have already been set by the system, or in this
     section. This parameter is only supported for Azure ML compute types.
    :vartype docker_args_list: list[str]
    :ivar shm_size: Size of the docker container's shared memory block. This should be in the
     format of (number)(unit) where number as to be greater than 0 and the unit can be one of
     b(bytes), k(kilobytes), m(megabytes), or g(gigabytes).
    :vartype shm_size: str
    """

    docker_args: Optional[str] = rest_field(name="dockerArgs", visibility=["read", "create"])
    """Extra arguments to pass to the Docker run command. This would override any parameters that have
     already been set by the system, or in this section. This parameter is only supported for Azure
     ML compute types."""
    docker_args_list: Optional[list[str]] = rest_field(name="dockerArgsList", visibility=["read", "create"])
    """Extra arguments to pass to the Docker run command, as a collection. This would override any
     parameters that have already been set by the system, or in this section. This parameter is only
     supported for Azure ML compute types."""
    shm_size: Optional[str] = rest_field(name="shmSize", visibility=["read", "create"])
    """Size of the docker container's shared memory block. This should be in the format of
     (number)(unit) where number as to be greater than 0 and the unit can be one of b(bytes),
     k(kilobytes), m(megabytes), or g(gigabytes)."""

    @overload
    def __init__(
        self,
        *,
        instance_count: Optional[int] = None,
        instance_type: Optional[str] = None,
        properties: Optional[dict[str, Any]] = None,
        docker_args: Optional[str] = None,
        docker_args_list: Optional[list[str]] = None,
        shm_size: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobResources(_Model):
    """JobResources.

    :ivar instance_types: List of instance types to choose from.
    :vartype instance_types: list[str]
    """

    instance_types: Optional[list[str]] = rest_field(name="instanceTypes", visibility=["read", "create"])
    """List of instance types to choose from."""

    @overload
    def __init__(
        self,
        *,
        instance_types: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobScheduleAction(ScheduleActionBase, discriminator="CreateJob"):
    """JobScheduleAction.

    :ivar job_definition: [Required] Defines Schedule action definition details. Required.
    :vartype job_definition: ~azure.mgmt.machinelearningservices.models.JobBaseProperties
    :ivar action_type: [Required] Specifies the action type of the schedule. Required.
    :vartype action_type: str or ~azure.mgmt.machinelearningservices.models.CREATE_JOB
    """

    job_definition: "_models.JobBaseProperties" = rest_field(
        name="jobDefinition", visibility=["read", "create", "update"]
    )
    """[Required] Defines Schedule action definition details. Required."""
    action_type: Literal[ScheduleActionType.CREATE_JOB] = rest_discriminator(name="actionType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the action type of the schedule. Required."""

    @overload
    def __init__(
        self,
        *,
        job_definition: "_models.JobBaseProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.action_type = ScheduleActionType.CREATE_JOB  # type: ignore


class JobService(_Model):
    """Job endpoint definition.

    :ivar endpoint: Url for endpoint.
    :vartype endpoint: str
    :ivar error_message: Any error in the service.
    :vartype error_message: str
    :ivar job_service_type: Endpoint type.
    :vartype job_service_type: str
    :ivar nodes: Nodes that user would like to start the service on.
     If Nodes is not set or set to null, the service will only be started on leader node.
    :vartype nodes: ~azure.mgmt.machinelearningservices.models.Nodes
    :ivar port: Port for endpoint.
    :vartype port: int
    :ivar properties: Additional properties to set on the endpoint.
    :vartype properties: dict[str, str]
    :ivar status: Status of endpoint.
    :vartype status: str
    """

    endpoint: Optional[str] = rest_field(visibility=["read", "create"])
    """Url for endpoint."""
    error_message: Optional[str] = rest_field(name="errorMessage", visibility=["read"])
    """Any error in the service."""
    job_service_type: Optional[str] = rest_field(name="jobServiceType", visibility=["read", "create"])
    """Endpoint type."""
    nodes: Optional["_models.Nodes"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Nodes that user would like to start the service on.
     If Nodes is not set or set to null, the service will only be started on leader node."""
    port: Optional[int] = rest_field(visibility=["read", "create"])
    """Port for endpoint."""
    properties: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Additional properties to set on the endpoint."""
    status: Optional[str] = rest_field(visibility=["read"])
    """Status of endpoint."""

    @overload
    def __init__(
        self,
        *,
        endpoint: Optional[str] = None,
        job_service_type: Optional[str] = None,
        nodes: Optional["_models.Nodes"] = None,
        port: Optional[int] = None,
        properties: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JupyterKernelConfig(_Model):
    """Jupyter kernel configuration.

    :ivar argv: Argument to the the runtime.
    :vartype argv: list[str]
    :ivar display_name: Display name of the kernel.
    :vartype display_name: str
    :ivar language: Language of the kernel [Example value: python].
    :vartype language: str
    """

    argv: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Argument to the the runtime."""
    display_name: Optional[str] = rest_field(
        name="displayName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Display name of the kernel."""
    language: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Language of the kernel [Example value: python]."""

    @overload
    def __init__(
        self,
        *,
        argv: Optional[list[str]] = None,
        display_name: Optional[str] = None,
        language: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KeyVaultProperties(_Model):
    """Customer Key vault properties.

    :ivar identity_client_id: Currently, we support only SystemAssigned MSI.
     We need this when we support UserAssignedIdentities.
    :vartype identity_client_id: str
    :ivar key_identifier: KeyVault key identifier to encrypt the data. Required.
    :vartype key_identifier: str
    :ivar key_vault_arm_id: KeyVault Arm Id that contains the data encryption key. Required.
    :vartype key_vault_arm_id: str
    """

    identity_client_id: Optional[str] = rest_field(
        name="identityClientId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Currently, we support only SystemAssigned MSI.
     We need this when we support UserAssignedIdentities."""
    key_identifier: str = rest_field(name="keyIdentifier", visibility=["read", "create", "update", "delete", "query"])
    """KeyVault key identifier to encrypt the data. Required."""
    key_vault_arm_id: str = rest_field(name="keyVaultArmId", visibility=["read", "create", "update", "delete", "query"])
    """KeyVault Arm Id that contains the data encryption key. Required."""

    @overload
    def __init__(
        self,
        *,
        key_identifier: str,
        key_vault_arm_id: str,
        identity_client_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Kubernetes(Compute, discriminator="Kubernetes"):
    """A Machine Learning compute based on Kubernetes Compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties: Properties of Kubernetes.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.KubernetesProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.KUBERNETES
    """

    properties: Optional["_models.KubernetesProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of Kubernetes."""
    compute_type: Literal[ComputeType.KUBERNETES] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.KubernetesProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.KUBERNETES  # type: ignore


class OnlineDeploymentProperties(EndpointDeploymentPropertiesBase):
    """OnlineDeploymentProperties.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    KubernetesOnlineDeployment, ManagedOnlineDeployment

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.mgmt.machinelearningservices.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar app_insights_enabled: If true, enables Application Insights logging.
    :vartype app_insights_enabled: bool
    :ivar data_collector: The mdc configuration, we disable mdc when it's null.
    :vartype data_collector: ~azure.mgmt.machinelearningservices.models.DataCollector
    :ivar egress_public_network_access: Enum to determine whether PublicNetworkAccess is Enabled or
     Disabled for egress of a deployment. Known values are: "Enabled" and "Disabled".
    :vartype egress_public_network_access: str or
     ~azure.mgmt.machinelearningservices.models.EgressPublicNetworkAccessType
    :ivar endpoint_compute_type: [Required] The compute type of the endpoint. Required. Known
     values are: "Managed", "Kubernetes", and "AzureMLCompute".
    :vartype endpoint_compute_type: str or
     ~azure.mgmt.machinelearningservices.models.EndpointComputeType
    :ivar instance_type: Compute instance type. Default: Standard_F4s_v2.
    :vartype instance_type: str
    :ivar liveness_probe: Liveness probe monitors the health of the container regularly.
    :vartype liveness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar model: The URI path to the model.
    :vartype model: str
    :ivar model_mount_path: The path to mount the model in custom container.
    :vartype model_mount_path: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Known values are:
     "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentProvisioningState
    :ivar readiness_probe: Readiness probe validates if the container is ready to serve traffic.
     The properties and defaults are the same as liveness probe.
    :vartype readiness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar request_settings: Request settings for the deployment.
    :vartype request_settings: ~azure.mgmt.machinelearningservices.models.OnlineRequestSettings
    :ivar scale_settings: Scale settings for the deployment.
     If it is null or not provided,
     it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
     and to DefaultScaleSettings for ManagedOnlineDeployment.
    :vartype scale_settings: ~azure.mgmt.machinelearningservices.models.OnlineScaleSettings
    :ivar startup_probe: Startup probe verify whether an application within a container has started
     successfully.
    :vartype startup_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    """

    __mapping__: dict[str, _Model] = {}
    app_insights_enabled: Optional[bool] = rest_field(
        name="appInsightsEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, enables Application Insights logging."""
    data_collector: Optional["_models.DataCollector"] = rest_field(
        name="dataCollector", visibility=["read", "create", "update", "delete", "query"]
    )
    """The mdc configuration, we disable mdc when it's null."""
    egress_public_network_access: Optional[Union[str, "_models.EgressPublicNetworkAccessType"]] = rest_field(
        name="egressPublicNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum to determine whether PublicNetworkAccess is Enabled or Disabled for egress of a
     deployment. Known values are: \"Enabled\" and \"Disabled\"."""
    endpoint_compute_type: str = rest_discriminator(
        name="endpointComputeType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The compute type of the endpoint. Required. Known values are: \"Managed\",
     \"Kubernetes\", and \"AzureMLCompute\"."""
    instance_type: Optional[str] = rest_field(name="instanceType", visibility=["read", "create"])
    """Compute instance type. Default: Standard_F4s_v2."""
    liveness_probe: Optional["_models.ProbeSettings"] = rest_field(
        name="livenessProbe", visibility=["read", "create", "update", "delete", "query"]
    )
    """Liveness probe monitors the health of the container regularly."""
    model: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The URI path to the model."""
    model_mount_path: Optional[str] = rest_field(
        name="modelMountPath", visibility=["read", "create", "update", "delete", "query"]
    )
    """The path to mount the model in custom container."""
    provisioning_state: Optional[Union[str, "_models.DeploymentProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint deployment. Known values are: \"Creating\", \"Deleting\",
     \"Scaling\", \"Updating\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    readiness_probe: Optional["_models.ProbeSettings"] = rest_field(
        name="readinessProbe", visibility=["read", "create", "update", "delete", "query"]
    )
    """Readiness probe validates if the container is ready to serve traffic. The properties and
     defaults are the same as liveness probe."""
    request_settings: Optional["_models.OnlineRequestSettings"] = rest_field(
        name="requestSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Request settings for the deployment."""
    scale_settings: Optional["_models.OnlineScaleSettings"] = rest_field(
        name="scaleSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Scale settings for the deployment.
     If it is null or not provided,
     it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
     and to DefaultScaleSettings for ManagedOnlineDeployment."""
    startup_probe: Optional["_models.ProbeSettings"] = rest_field(
        name="startupProbe", visibility=["read", "create", "update", "delete", "query"]
    )
    """Startup probe verify whether an application within a container has started successfully."""

    @overload
    def __init__(
        self,
        *,
        endpoint_compute_type: str,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        properties: Optional[dict[str, str]] = None,
        app_insights_enabled: Optional[bool] = None,
        data_collector: Optional["_models.DataCollector"] = None,
        egress_public_network_access: Optional[Union[str, "_models.EgressPublicNetworkAccessType"]] = None,
        instance_type: Optional[str] = None,
        liveness_probe: Optional["_models.ProbeSettings"] = None,
        model: Optional[str] = None,
        model_mount_path: Optional[str] = None,
        readiness_probe: Optional["_models.ProbeSettings"] = None,
        request_settings: Optional["_models.OnlineRequestSettings"] = None,
        scale_settings: Optional["_models.OnlineScaleSettings"] = None,
        startup_probe: Optional["_models.ProbeSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KubernetesOnlineDeployment(OnlineDeploymentProperties, discriminator="Kubernetes"):
    """Properties specific to a KubernetesOnlineDeployment.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.mgmt.machinelearningservices.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar app_insights_enabled: If true, enables Application Insights logging.
    :vartype app_insights_enabled: bool
    :ivar data_collector: The mdc configuration, we disable mdc when it's null.
    :vartype data_collector: ~azure.mgmt.machinelearningservices.models.DataCollector
    :ivar egress_public_network_access: Enum to determine whether PublicNetworkAccess is Enabled or
     Disabled for egress of a deployment. Known values are: "Enabled" and "Disabled".
    :vartype egress_public_network_access: str or
     ~azure.mgmt.machinelearningservices.models.EgressPublicNetworkAccessType
    :ivar instance_type: Compute instance type. Default: Standard_F4s_v2.
    :vartype instance_type: str
    :ivar liveness_probe: Liveness probe monitors the health of the container regularly.
    :vartype liveness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar model: The URI path to the model.
    :vartype model: str
    :ivar model_mount_path: The path to mount the model in custom container.
    :vartype model_mount_path: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Known values are:
     "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentProvisioningState
    :ivar readiness_probe: Readiness probe validates if the container is ready to serve traffic.
     The properties and defaults are the same as liveness probe.
    :vartype readiness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar request_settings: Request settings for the deployment.
    :vartype request_settings: ~azure.mgmt.machinelearningservices.models.OnlineRequestSettings
    :ivar scale_settings: Scale settings for the deployment.
     If it is null or not provided,
     it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
     and to DefaultScaleSettings for ManagedOnlineDeployment.
    :vartype scale_settings: ~azure.mgmt.machinelearningservices.models.OnlineScaleSettings
    :ivar startup_probe: Startup probe verify whether an application within a container has started
     successfully.
    :vartype startup_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar container_resource_requirements: The resource requirements for the container (cpu and
     memory).
    :vartype container_resource_requirements:
     ~azure.mgmt.machinelearningservices.models.ContainerResourceRequirements
    :ivar endpoint_compute_type: [Required] The compute type of the endpoint. Required.
    :vartype endpoint_compute_type: str or ~azure.mgmt.machinelearningservices.models.KUBERNETES
    """

    container_resource_requirements: Optional["_models.ContainerResourceRequirements"] = rest_field(
        name="containerResourceRequirements", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource requirements for the container (cpu and memory)."""
    endpoint_compute_type: Literal[EndpointComputeType.KUBERNETES] = rest_discriminator(name="endpointComputeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] The compute type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        properties: Optional[dict[str, str]] = None,
        app_insights_enabled: Optional[bool] = None,
        data_collector: Optional["_models.DataCollector"] = None,
        egress_public_network_access: Optional[Union[str, "_models.EgressPublicNetworkAccessType"]] = None,
        instance_type: Optional[str] = None,
        liveness_probe: Optional["_models.ProbeSettings"] = None,
        model: Optional[str] = None,
        model_mount_path: Optional[str] = None,
        readiness_probe: Optional["_models.ProbeSettings"] = None,
        request_settings: Optional["_models.OnlineRequestSettings"] = None,
        scale_settings: Optional["_models.OnlineScaleSettings"] = None,
        startup_probe: Optional["_models.ProbeSettings"] = None,
        container_resource_requirements: Optional["_models.ContainerResourceRequirements"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_compute_type = EndpointComputeType.KUBERNETES  # type: ignore


class KubernetesProperties(_Model):
    """Kubernetes properties.

    :ivar relay_connection_string: Relay connection string.
    :vartype relay_connection_string: str
    :ivar service_bus_connection_string: ServiceBus connection string.
    :vartype service_bus_connection_string: str
    :ivar extension_principal_id: Extension principal-id.
    :vartype extension_principal_id: str
    :ivar extension_instance_release_train: Extension instance release train.
    :vartype extension_instance_release_train: str
    :ivar vc_name: VC name.
    :vartype vc_name: str
    :ivar namespace: Compute namespace.
    :vartype namespace: str
    :ivar default_instance_type: Default instance type.
    :vartype default_instance_type: str
    :ivar instance_types: Instance Type Schema.
    :vartype instance_types: dict[str,
     ~azure.mgmt.machinelearningservices.models.InstanceTypeSchema]
    """

    relay_connection_string: Optional[str] = rest_field(
        name="relayConnectionString", visibility=["read", "create", "update", "delete", "query"]
    )
    """Relay connection string."""
    service_bus_connection_string: Optional[str] = rest_field(
        name="serviceBusConnectionString", visibility=["read", "create", "update", "delete", "query"]
    )
    """ServiceBus connection string."""
    extension_principal_id: Optional[str] = rest_field(
        name="extensionPrincipalId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Extension principal-id."""
    extension_instance_release_train: Optional[str] = rest_field(
        name="extensionInstanceReleaseTrain", visibility=["read", "create", "update", "delete", "query"]
    )
    """Extension instance release train."""
    vc_name: Optional[str] = rest_field(name="vcName", visibility=["read", "create", "update", "delete", "query"])
    """VC name."""
    namespace: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Compute namespace."""
    default_instance_type: Optional[str] = rest_field(
        name="defaultInstanceType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Default instance type."""
    instance_types: Optional[dict[str, "_models.InstanceTypeSchema"]] = rest_field(
        name="instanceTypes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Instance Type Schema."""

    @overload
    def __init__(
        self,
        *,
        relay_connection_string: Optional[str] = None,
        service_bus_connection_string: Optional[str] = None,
        extension_principal_id: Optional[str] = None,
        extension_instance_release_train: Optional[str] = None,
        vc_name: Optional[str] = None,
        namespace: Optional[str] = None,
        default_instance_type: Optional[str] = None,
        instance_types: Optional[dict[str, "_models.InstanceTypeSchema"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LabelGeneration(DataGenerationVertical, discriminator="LabelGeneration"):
    """LabelGeneration.

    :ivar data_generation_task_type: [Required] DataGeneration Task type. Required. Known values
     are: "Conversation", "Math", "Nli", "NluQa", and "Summarization".
    :vartype data_generation_task_type: str or
     ~azure.mgmt.machinelearningservices.models.DataGenerationTaskType
    :ivar prompt_settings: Prompt Settings.
    :vartype prompt_settings: ~azure.mgmt.machinelearningservices.models.PromptSettings
    :ivar teacher_model_endpoint: [Required] Teacher Model Endpoint Details. Required.
    :vartype teacher_model_endpoint:
     ~azure.mgmt.machinelearningservices.models.TeacherModelEndpoint
    :ivar teacher_model_settings:
    :vartype teacher_model_settings:
     ~azure.mgmt.machinelearningservices.models.TeacherModelSettings
    :ivar training_data: Training data for fine tuning.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar validation_data: Validation data for fine tuning.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.JobInput
    :ivar data_generation_type: [Required] Enum to determine the type of Data Generation. Required.
     Label Generation by Teacher Model Inferencing
    :vartype data_generation_type: str or
     ~azure.mgmt.machinelearningservices.models.LABEL_GENERATION
    """

    training_data: Optional["_models.JobInput"] = rest_field(
        name="trainingData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Training data for fine tuning."""
    validation_data: Optional["_models.JobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data for fine tuning."""
    data_generation_type: Literal[DataGenerationType.LABEL_GENERATION] = rest_discriminator(name="dataGenerationType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Enum to determine the type of Data Generation. Required. Label Generation by Teacher
     Model Inferencing"""

    @overload
    def __init__(
        self,
        *,
        data_generation_task_type: Union[str, "_models.DataGenerationTaskType"],
        teacher_model_endpoint: "_models.TeacherModelEndpoint",
        prompt_settings: Optional["_models.PromptSettings"] = None,
        teacher_model_settings: Optional["_models.TeacherModelSettings"] = None,
        training_data: Optional["_models.JobInput"] = None,
        validation_data: Optional["_models.JobInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_generation_type = DataGenerationType.LABEL_GENERATION  # type: ignore


class OneLakeArtifact(_Model):
    """OneLake artifact (data source) configuration.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    LakeHouseArtifact

    :ivar artifact_name: [Required] OneLake artifact name. Required.
    :vartype artifact_name: str
    :ivar artifact_type: [Required] OneLake artifact type. Required. "LakeHouse"
    :vartype artifact_type: str or ~azure.mgmt.machinelearningservices.models.OneLakeArtifactType
    """

    __mapping__: dict[str, _Model] = {}
    artifact_name: str = rest_field(name="artifactName", visibility=["read", "create"])
    """[Required] OneLake artifact name. Required."""
    artifact_type: str = rest_discriminator(
        name="artifactType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] OneLake artifact type. Required. \"LakeHouse\""""

    @overload
    def __init__(
        self,
        *,
        artifact_name: str,
        artifact_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LakeHouseArtifact(OneLakeArtifact, discriminator="LakeHouse"):
    """LakeHouseArtifact.

    :ivar artifact_name: [Required] OneLake artifact name. Required.
    :vartype artifact_name: str
    :ivar artifact_type: [Required] OneLake artifact type. Required.
    :vartype artifact_type: str or ~azure.mgmt.machinelearningservices.models.LAKE_HOUSE
    """

    artifact_type: Literal[OneLakeArtifactType.LAKE_HOUSE] = rest_discriminator(name="artifactType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] OneLake artifact type. Required."""

    @overload
    def __init__(
        self,
        *,
        artifact_name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.artifact_type = OneLakeArtifactType.LAKE_HOUSE  # type: ignore


class ListNotebookKeysResult(_Model):
    """ListNotebookKeysResult.

    :ivar primary_access_key: The primary access key of the Notebook.
    :vartype primary_access_key: str
    :ivar secondary_access_key: The secondary access key of the Notebook.
    :vartype secondary_access_key: str
    """

    primary_access_key: Optional[str] = rest_field(name="primaryAccessKey", visibility=["read"])
    """The primary access key of the Notebook."""
    secondary_access_key: Optional[str] = rest_field(name="secondaryAccessKey", visibility=["read"])
    """The secondary access key of the Notebook."""


class ListStorageAccountKeysResult(_Model):
    """ListStorageAccountKeysResult.

    :ivar user_storage_key: The access key of the storage.
    :vartype user_storage_key: str
    """

    user_storage_key: Optional[str] = rest_field(name="userStorageKey", visibility=["read"])
    """The access key of the storage."""


class ListWorkspaceKeysResult(_Model):
    """ListWorkspaceKeysResult.

    :ivar app_insights_instrumentation_key: The access key of the workspace app insights.
    :vartype app_insights_instrumentation_key: str
    :ivar container_registry_credentials:
    :vartype container_registry_credentials:
     ~azure.mgmt.machinelearningservices.models.RegistryListCredentialsResult
    :ivar notebook_access_keys:
    :vartype notebook_access_keys:
     ~azure.mgmt.machinelearningservices.models.ListNotebookKeysResult
    :ivar user_storage_arm_id: The arm Id key of the workspace storage.
    :vartype user_storage_arm_id: str
    :ivar user_storage_key: The access key of the workspace storage.
    :vartype user_storage_key: str
    """

    app_insights_instrumentation_key: Optional[str] = rest_field(
        name="appInsightsInstrumentationKey", visibility=["read"]
    )
    """The access key of the workspace app insights."""
    container_registry_credentials: Optional["_models.RegistryListCredentialsResult"] = rest_field(
        name="containerRegistryCredentials", visibility=["read", "create", "update", "delete", "query"]
    )
    notebook_access_keys: Optional["_models.ListNotebookKeysResult"] = rest_field(
        name="notebookAccessKeys", visibility=["read", "create", "update", "delete", "query"]
    )
    user_storage_arm_id: Optional[str] = rest_field(name="userStorageArmId", visibility=["read"])
    """The arm Id key of the workspace storage."""
    user_storage_key: Optional[str] = rest_field(name="userStorageKey", visibility=["read"])
    """The access key of the workspace storage."""

    @overload
    def __init__(
        self,
        *,
        container_registry_credentials: Optional["_models.RegistryListCredentialsResult"] = None,
        notebook_access_keys: Optional["_models.ListNotebookKeysResult"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LiteralJobInput(JobInput, discriminator="literal"):
    """Literal input type.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar value: [Required] Literal value for the input. Required.
    :vartype value: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.LITERAL
    """

    value: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Literal value for the input. Required."""
    job_input_type: Literal[JobInputType.LITERAL] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        value: str,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.LITERAL  # type: ignore


class ManagedComputeIdentity(MonitorComputeIdentityBase, discriminator="ManagedIdentity"):
    """Managed compute identity definition.

    :ivar identity: The identity which will be leveraged by the monitoring jobs.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar compute_identity_type: [Required] Specifies the type of identity to use within the
     monitoring jobs. Required. Authenticates through a user-provided managed identity.
    :vartype compute_identity_type: str or
     ~azure.mgmt.machinelearningservices.models.MANAGED_IDENTITY
    """

    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity which will be leveraged by the monitoring jobs."""
    compute_identity_type: Literal[MonitorComputeIdentityType.MANAGED_IDENTITY] = rest_discriminator(name="computeIdentityType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of identity to use within the monitoring jobs. Required.
     Authenticates through a user-provided managed identity."""

    @overload
    def __init__(
        self,
        *,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_identity_type = MonitorComputeIdentityType.MANAGED_IDENTITY  # type: ignore


class ManagedIdentity(IdentityConfiguration, discriminator="Managed"):
    """Managed identity configuration.

    :ivar client_id: Specifies a user-assigned identity by client ID. For system-assigned, do not
     set this field.
    :vartype client_id: str
    :ivar object_id: Specifies a user-assigned identity by object ID. For system-assigned, do not
     set this field.
    :vartype object_id: str
    :ivar resource_id: Specifies a user-assigned identity by ARM resource ID. For system-assigned,
     do not set this field.
    :vartype resource_id: str
    :ivar identity_type: [Required] Specifies the type of identity framework. Required.
    :vartype identity_type: str or ~azure.mgmt.machinelearningservices.models.MANAGED
    """

    client_id: Optional[str] = rest_field(name="clientId", visibility=["read", "create"])
    """Specifies a user-assigned identity by client ID. For system-assigned, do not set this field."""
    object_id: Optional[str] = rest_field(name="objectId", visibility=["read", "create"])
    """Specifies a user-assigned identity by object ID. For system-assigned, do not set this field."""
    resource_id: Optional[str] = rest_field(name="resourceId", visibility=["read", "create"])
    """Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this
     field."""
    identity_type: Literal[IdentityConfigurationType.MANAGED] = rest_discriminator(name="identityType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of identity framework. Required."""

    @overload
    def __init__(
        self,
        *,
        client_id: Optional[str] = None,
        object_id: Optional[str] = None,
        resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.identity_type = IdentityConfigurationType.MANAGED  # type: ignore


class ManagedIdentityAuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="ManagedIdentity"
):  # pylint: disable=name-too-long
    """ManagedIdentityAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials:
     ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionManagedIdentity
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.MANAGED_IDENTITY
    """

    credentials: Optional["_models.WorkspaceConnectionManagedIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.MANAGED_IDENTITY] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionManagedIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.MANAGED_IDENTITY  # type: ignore


class ManagedIdentityCredential(DataReferenceCredential, discriminator="ManagedIdentity"):
    """Credential for user managed identity.

    :ivar managed_identity_type: ManagedIdentityCredential identity type.
    :vartype managed_identity_type: str
    :ivar user_managed_identity_client_id: ClientId for the UAMI. For ManagedIdentityType =
     SystemManaged, this field is null.
    :vartype user_managed_identity_client_id: str
    :ivar user_managed_identity_principal_id: PrincipalId for the UAMI. For ManagedIdentityType =
     SystemManaged, this field is null.
    :vartype user_managed_identity_principal_id: str
    :ivar user_managed_identity_resource_id: Full arm scope for the Id. For ManagedIdentityType =
     SystemManaged, this field is null.
    :vartype user_managed_identity_resource_id: str
    :ivar user_managed_identity_tenant_id: TenantId for the UAMI. For ManagedIdentityType =
     SystemManaged, this field is null.
    :vartype user_managed_identity_tenant_id: str
    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credential_type: str or ~azure.mgmt.machinelearningservices.models.MANAGED_IDENTITY
    """

    managed_identity_type: Optional[str] = rest_field(
        name="managedIdentityType", visibility=["read", "create", "update", "delete", "query"]
    )
    """ManagedIdentityCredential identity type."""
    user_managed_identity_client_id: Optional[str] = rest_field(
        name="userManagedIdentityClientId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ClientId for the UAMI. For ManagedIdentityType = SystemManaged, this field is null."""
    user_managed_identity_principal_id: Optional[str] = rest_field(
        name="userManagedIdentityPrincipalId", visibility=["read", "create", "update", "delete", "query"]
    )
    """PrincipalId for the UAMI. For ManagedIdentityType = SystemManaged, this field is null."""
    user_managed_identity_resource_id: Optional[str] = rest_field(
        name="userManagedIdentityResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Full arm scope for the Id. For ManagedIdentityType = SystemManaged, this field is null."""
    user_managed_identity_tenant_id: Optional[str] = rest_field(
        name="userManagedIdentityTenantId", visibility=["read", "create", "update", "delete", "query"]
    )
    """TenantId for the UAMI. For ManagedIdentityType = SystemManaged, this field is null."""
    credential_type: Literal[DataReferenceCredentialType.MANAGED_IDENTITY] = rest_discriminator(name="credentialType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        managed_identity_type: Optional[str] = None,
        user_managed_identity_client_id: Optional[str] = None,
        user_managed_identity_principal_id: Optional[str] = None,
        user_managed_identity_resource_id: Optional[str] = None,
        user_managed_identity_tenant_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credential_type = DataReferenceCredentialType.MANAGED_IDENTITY  # type: ignore


class ManagedNetworkProvisionOptions(_Model):
    """Managed Network Provisioning options for managed network of a machine learning workspace.

    :ivar include_spark:
    :vartype include_spark: bool
    """

    include_spark: Optional[bool] = rest_field(
        name="includeSpark", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        include_spark: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNetworkProvisionStatus(_Model):
    """Status of the Provisioning for the managed network of a machine learning workspace.

    :ivar spark_ready:
    :vartype spark_ready: bool
    :ivar status: Status for the managed network of a machine learning workspace. Known values are:
     "Inactive" and "Active".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.ManagedNetworkStatus
    """

    spark_ready: Optional[bool] = rest_field(
        name="sparkReady", visibility=["read", "create", "update", "delete", "query"]
    )
    status: Optional[Union[str, "_models.ManagedNetworkStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Status for the managed network of a machine learning workspace. Known values are: \"Inactive\"
     and \"Active\"."""

    @overload
    def __init__(
        self,
        *,
        spark_ready: Optional[bool] = None,
        status: Optional[Union[str, "_models.ManagedNetworkStatus"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNetworkSettings(_Model):
    """Managed Network settings for a machine learning workspace.

    :ivar enable_network_monitor: A flag to indicate if monitoring needs to be enabled for the
     managed network.
    :vartype enable_network_monitor: bool
    :ivar isolation_mode: Isolation mode for the managed network of a machine learning workspace.
     Known values are: "Disabled", "AllowInternetOutbound", and "AllowOnlyApprovedOutbound".
    :vartype isolation_mode: str or ~azure.mgmt.machinelearningservices.models.IsolationMode
    :ivar network_id:
    :vartype network_id: str
    :ivar outbound_rules: Dictionary of <OutboundRule>.
    :vartype outbound_rules: dict[str, ~azure.mgmt.machinelearningservices.models.OutboundRule]
    :ivar status: Status of the Provisioning for the managed network of a machine learning
     workspace.
    :vartype status: ~azure.mgmt.machinelearningservices.models.ManagedNetworkProvisionStatus
    :ivar firewall_sku: Firewall Sku used for FQDN Rules. Known values are: "Standard" and "Basic".
    :vartype firewall_sku: str or ~azure.mgmt.machinelearningservices.models.FirewallSku
    :ivar managed_network_kind: The Kind of the managed network. Users can switch from V1 to V2 for
     granular access controls, but cannot switch back to V1 once V2 is enabled. Known values are:
     "V1" and "V2".
    :vartype managed_network_kind: str or
     ~azure.mgmt.machinelearningservices.models.ManagedNetworkKind
    :ivar firewall_public_ip_address: Public IP address assigned to the Azure Firewall.
    :vartype firewall_public_ip_address: str
    """

    enable_network_monitor: Optional[bool] = rest_field(
        name="enableNetworkMonitor", visibility=["read", "create", "update", "delete", "query"]
    )
    """A flag to indicate if monitoring needs to be enabled for the managed network."""
    isolation_mode: Optional[Union[str, "_models.IsolationMode"]] = rest_field(
        name="isolationMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Isolation mode for the managed network of a machine learning workspace. Known values are:
     \"Disabled\", \"AllowInternetOutbound\", and \"AllowOnlyApprovedOutbound\"."""
    network_id: Optional[str] = rest_field(name="networkId", visibility=["read"])
    outbound_rules: Optional[dict[str, "_models.OutboundRule"]] = rest_field(
        name="outboundRules", visibility=["read", "create", "update", "delete", "query"]
    )
    """Dictionary of <OutboundRule>."""
    status: Optional["_models.ManagedNetworkProvisionStatus"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Status of the Provisioning for the managed network of a machine learning workspace."""
    firewall_sku: Optional[Union[str, "_models.FirewallSku"]] = rest_field(
        name="firewallSku", visibility=["read", "create", "update", "delete", "query"]
    )
    """Firewall Sku used for FQDN Rules. Known values are: \"Standard\" and \"Basic\"."""
    managed_network_kind: Optional[Union[str, "_models.ManagedNetworkKind"]] = rest_field(
        name="managedNetworkKind", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Kind of the managed network. Users can switch from V1 to V2 for granular access controls,
     but cannot switch back to V1 once V2 is enabled. Known values are: \"V1\" and \"V2\"."""
    firewall_public_ip_address: Optional[str] = rest_field(name="firewallPublicIpAddress", visibility=["read"])
    """Public IP address assigned to the Azure Firewall."""

    @overload
    def __init__(
        self,
        *,
        enable_network_monitor: Optional[bool] = None,
        isolation_mode: Optional[Union[str, "_models.IsolationMode"]] = None,
        outbound_rules: Optional[dict[str, "_models.OutboundRule"]] = None,
        status: Optional["_models.ManagedNetworkProvisionStatus"] = None,
        firewall_sku: Optional[Union[str, "_models.FirewallSku"]] = None,
        managed_network_kind: Optional[Union[str, "_models.ManagedNetworkKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNetworkSettingsBasicResource(Resource):
    """ManagedNetworkSettingsBasicResource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Managed Network settings for a machine learning workspace.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ManagedNetworkSettings
    """

    properties: Optional["_models.ManagedNetworkSettings"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed Network settings for a machine learning workspace."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ManagedNetworkSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNetworkSettingsEx(ManagedNetworkSettings):
    """ManagedNetworkSettingsEx.

    :ivar enable_network_monitor: A flag to indicate if monitoring needs to be enabled for the
     managed network.
    :vartype enable_network_monitor: bool
    :ivar isolation_mode: Isolation mode for the managed network of a machine learning workspace.
     Known values are: "Disabled", "AllowInternetOutbound", and "AllowOnlyApprovedOutbound".
    :vartype isolation_mode: str or ~azure.mgmt.machinelearningservices.models.IsolationMode
    :ivar network_id:
    :vartype network_id: str
    :ivar outbound_rules: Dictionary of <OutboundRule>.
    :vartype outbound_rules: dict[str, ~azure.mgmt.machinelearningservices.models.OutboundRule]
    :ivar status: Status of the Provisioning for the managed network of a machine learning
     workspace.
    :vartype status: ~azure.mgmt.machinelearningservices.models.ManagedNetworkProvisionStatus
    :ivar firewall_sku: Firewall Sku used for FQDN Rules. Known values are: "Standard" and "Basic".
    :vartype firewall_sku: str or ~azure.mgmt.machinelearningservices.models.FirewallSku
    :ivar managed_network_kind: The Kind of the managed network. Users can switch from V1 to V2 for
     granular access controls, but cannot switch back to V1 once V2 is enabled. Known values are:
     "V1" and "V2".
    :vartype managed_network_kind: str or
     ~azure.mgmt.machinelearningservices.models.ManagedNetworkKind
    :ivar firewall_public_ip_address: Public IP address assigned to the Azure Firewall.
    :vartype firewall_public_ip_address: str
    :ivar changeable_isolation_modes:
    :vartype changeable_isolation_modes: list[str or
     ~azure.mgmt.machinelearningservices.models.IsolationMode]
    """

    changeable_isolation_modes: Optional[list[Union[str, "_models.IsolationMode"]]] = rest_field(
        name="changeableIsolationModes", visibility=["read"]
    )

    @overload
    def __init__(
        self,
        *,
        enable_network_monitor: Optional[bool] = None,
        isolation_mode: Optional[Union[str, "_models.IsolationMode"]] = None,
        outbound_rules: Optional[dict[str, "_models.OutboundRule"]] = None,
        status: Optional["_models.ManagedNetworkProvisionStatus"] = None,
        firewall_sku: Optional[Union[str, "_models.FirewallSku"]] = None,
        managed_network_kind: Optional[Union[str, "_models.ManagedNetworkKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNetworkSettingsProperties(_Model):
    """The properties of the managed network settings of a machine learning workspace.

    :ivar managed_network: Managed Network settings for a machine learning workspace.
    :vartype managed_network: ~azure.mgmt.machinelearningservices.models.ManagedNetworkSettingsEx
    :ivar provisioning_state: The current deployment state of the managed network resource. The
     provisioningState is to indicate states for resource provisioning. Known values are:
     "Deferred", "Updating", "Succeeded", "Failed", "Deleting", and "Deleted".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ManagedNetworkProvisioningState
    """

    managed_network: Optional["_models.ManagedNetworkSettingsEx"] = rest_field(
        name="managedNetwork", visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed Network settings for a machine learning workspace."""
    provisioning_state: Optional[Union[str, "_models.ManagedNetworkProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current deployment state of the managed network resource. The provisioningState is to
     indicate states for resource provisioning. Known values are: \"Deferred\", \"Updating\",
     \"Succeeded\", \"Failed\", \"Deleting\", and \"Deleted\"."""

    @overload
    def __init__(
        self,
        *,
        managed_network: Optional["_models.ManagedNetworkSettingsEx"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedNetworkSettingsPropertiesBasicResource(ProxyResource):  # pylint: disable=name-too-long
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: The properties of the managed network settings of a machine learning
     workspace.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.ManagedNetworkSettingsProperties
    """

    properties: Optional["_models.ManagedNetworkSettingsProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the managed network settings of a machine learning workspace."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ManagedNetworkSettingsProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedOnlineDeployment(OnlineDeploymentProperties, discriminator="Managed"):
    """Properties specific to a ManagedOnlineDeployment.

    :ivar code_configuration: Code configuration for the endpoint deployment.
    :vartype code_configuration: ~azure.mgmt.machinelearningservices.models.CodeConfiguration
    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    :ivar environment_id: ARM resource ID or AssetId of the environment specification for the
     endpoint deployment.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables configuration for the deployment.
    :vartype environment_variables: dict[str, str]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar app_insights_enabled: If true, enables Application Insights logging.
    :vartype app_insights_enabled: bool
    :ivar data_collector: The mdc configuration, we disable mdc when it's null.
    :vartype data_collector: ~azure.mgmt.machinelearningservices.models.DataCollector
    :ivar egress_public_network_access: Enum to determine whether PublicNetworkAccess is Enabled or
     Disabled for egress of a deployment. Known values are: "Enabled" and "Disabled".
    :vartype egress_public_network_access: str or
     ~azure.mgmt.machinelearningservices.models.EgressPublicNetworkAccessType
    :ivar instance_type: Compute instance type. Default: Standard_F4s_v2.
    :vartype instance_type: str
    :ivar liveness_probe: Liveness probe monitors the health of the container regularly.
    :vartype liveness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar model: The URI path to the model.
    :vartype model: str
    :ivar model_mount_path: The path to mount the model in custom container.
    :vartype model_mount_path: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Known values are:
     "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentProvisioningState
    :ivar readiness_probe: Readiness probe validates if the container is ready to serve traffic.
     The properties and defaults are the same as liveness probe.
    :vartype readiness_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar request_settings: Request settings for the deployment.
    :vartype request_settings: ~azure.mgmt.machinelearningservices.models.OnlineRequestSettings
    :ivar scale_settings: Scale settings for the deployment.
     If it is null or not provided,
     it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
     and to DefaultScaleSettings for ManagedOnlineDeployment.
    :vartype scale_settings: ~azure.mgmt.machinelearningservices.models.OnlineScaleSettings
    :ivar startup_probe: Startup probe verify whether an application within a container has started
     successfully.
    :vartype startup_probe: ~azure.mgmt.machinelearningservices.models.ProbeSettings
    :ivar endpoint_compute_type: [Required] The compute type of the endpoint. Required.
    :vartype endpoint_compute_type: str or ~azure.mgmt.machinelearningservices.models.MANAGED
    """

    endpoint_compute_type: Literal[EndpointComputeType.MANAGED] = rest_discriminator(name="endpointComputeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] The compute type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        code_configuration: Optional["_models.CodeConfiguration"] = None,
        description: Optional[str] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        properties: Optional[dict[str, str]] = None,
        app_insights_enabled: Optional[bool] = None,
        data_collector: Optional["_models.DataCollector"] = None,
        egress_public_network_access: Optional[Union[str, "_models.EgressPublicNetworkAccessType"]] = None,
        instance_type: Optional[str] = None,
        liveness_probe: Optional["_models.ProbeSettings"] = None,
        model: Optional[str] = None,
        model_mount_path: Optional[str] = None,
        readiness_probe: Optional["_models.ProbeSettings"] = None,
        request_settings: Optional["_models.OnlineRequestSettings"] = None,
        scale_settings: Optional["_models.OnlineScaleSettings"] = None,
        startup_probe: Optional["_models.ProbeSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_compute_type = EndpointComputeType.MANAGED  # type: ignore


class ManagedOnlineEndpointDeploymentResourceProperties(
    EndpointDeploymentResourceProperties, discriminator="managedOnlineEndpoint"
):  # pylint: disable=name-too-long
    """ManagedOnlineEndpointDeploymentResourceProperties.

    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar endpoint_compute_type: Enum to determine endpoint compute type. Known values are:
     "Managed", "Kubernetes", and "AzureMLCompute".
    :vartype endpoint_compute_type: str or
     ~azure.mgmt.machinelearningservices.models.EndpointComputeType
    :ivar model:
    :vartype model: str
    :ivar type: Kind of the deployment. Required. Default value is "managedOnlineEndpoint".
    :vartype type: str
    """

    endpoint_compute_type: Optional[Union[str, "_models.EndpointComputeType"]] = rest_field(
        name="endpointComputeType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum to determine endpoint compute type. Known values are: \"Managed\", \"Kubernetes\", and
     \"AzureMLCompute\"."""
    model: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    type: Literal["managedOnlineEndpoint"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Kind of the deployment. Required. Default value is \"managedOnlineEndpoint\"."""

    @overload
    def __init__(
        self,
        *,
        failure_reason: Optional[str] = None,
        endpoint_compute_type: Optional[Union[str, "_models.EndpointComputeType"]] = None,
        model: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = "managedOnlineEndpoint"  # type: ignore


class ManagedOnlineEndpointResourceProperties(EndpointResourceProperties, discriminator="managedOnlineEndpoint"):
    """ManagedOnlineEndpointResourceProperties.

    :ivar associated_resource_id: Byo resource id for creating the built-in model service
     endpoints.
    :vartype associated_resource_id: str
    :ivar deployments: Deployments info.
    :vartype deployments:
     list[~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourcePropertiesBasicResource]
    :ivar endpoint_uri: Uri of the endpoint.
    :vartype endpoint_uri: str
    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar location: Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace.
    :vartype location: str
    :ivar name: Name of the endpoint.
    :vartype name: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar should_create_ai_services_endpoint: Whether the proxy (non-byo) endpoint is a regular
     endpoint or a OneKeyV2 AI services account endpoint.
    :vartype should_create_ai_services_endpoint: bool
    :ivar auth_mode: Enum to determine endpoint authentication mode. Known values are: "AMLToken",
     "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.mgmt.machinelearningservices.models.EndpointAuthMode
    :ivar compute:
    :vartype compute: str
    :ivar description:
    :vartype description: str
    :ivar mirror_traffic:
    :vartype mirror_traffic: dict[str, int]
    :ivar scoring_uri:
    :vartype scoring_uri: str
    :ivar traffic:
    :vartype traffic: dict[str, int]
    :ivar endpoint_type: Type of the endpoint. Required.
    :vartype endpoint_type: str or
     ~azure.mgmt.machinelearningservices.models.MANAGED_ONLINE_ENDPOINT
    """

    auth_mode: Optional[Union[str, "_models.EndpointAuthMode"]] = rest_field(
        name="authMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum to determine endpoint authentication mode. Known values are: \"AMLToken\", \"Key\", and
     \"AADToken\"."""
    compute: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    mirror_traffic: Optional[dict[str, int]] = rest_field(
        name="mirrorTraffic", visibility=["read", "create", "update", "delete", "query"]
    )
    scoring_uri: Optional[str] = rest_field(
        name="scoringUri", visibility=["read", "create", "update", "delete", "query"]
    )
    traffic: Optional[dict[str, int]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    endpoint_type: Literal[EndpointType.MANAGED_ONLINE_ENDPOINT] = rest_discriminator(name="endpointType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        associated_resource_id: Optional[str] = None,
        deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = None,
        endpoint_uri: Optional[str] = None,
        failure_reason: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        should_create_ai_services_endpoint: Optional[bool] = None,
        auth_mode: Optional[Union[str, "_models.EndpointAuthMode"]] = None,
        compute: Optional[str] = None,
        description: Optional[str] = None,
        mirror_traffic: Optional[dict[str, int]] = None,
        scoring_uri: Optional[str] = None,
        traffic: Optional[dict[str, int]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_type = EndpointType.MANAGED_ONLINE_ENDPOINT  # type: ignore


class ManagedResourceGroupAssignedIdentities(_Model):
    """Details for managed resource group assigned identities.

    :ivar principal_id: Identity principal Id.
    :vartype principal_id: str
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """Identity principal Id."""


class ManagedResourceGroupSettings(_Model):
    """Managed resource group settings.

    :ivar assigned_identities: List of assigned identities for the managed resource group.
    :vartype assigned_identities:
     list[~azure.mgmt.machinelearningservices.models.ManagedResourceGroupAssignedIdentities]
    """

    assigned_identities: Optional[list["_models.ManagedResourceGroupAssignedIdentities"]] = rest_field(
        name="assignedIdentities", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of assigned identities for the managed resource group."""

    @overload
    def __init__(
        self,
        *,
        assigned_identities: Optional[list["_models.ManagedResourceGroupAssignedIdentities"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ManagedServiceIdentity(_Model):
    """Managed service identity (system assigned and/or user assigned identities).

    :ivar principal_id: The service principal ID of the system assigned identity. This property
     will only be provided for a system assigned identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of the system assigned identity. This property will only be
     provided for a system assigned identity.
    :vartype tenant_id: str
    :ivar type: The type of managed identity assigned to this resource. Required. Known values are:
     "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentityType
    :ivar user_assigned_identities: The identities assigned to this resource by the user.
    :vartype user_assigned_identities: dict[str,
     ~azure.mgmt.machinelearningservices.models.UserAssignedIdentity]
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The service principal ID of the system assigned identity. This property will only be provided
     for a system assigned identity."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read"])
    """The tenant ID of the system assigned identity. This property will only be provided for a system
     assigned identity."""
    type: Union[str, "_models.ManagedServiceIdentityType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of managed identity assigned to this resource. Required. Known values are: \"None\",
     \"SystemAssigned\", \"UserAssigned\", and \"SystemAssigned,UserAssigned\"."""
    user_assigned_identities: Optional[dict[str, "_models.UserAssignedIdentity"]] = rest_field(
        name="userAssignedIdentities", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identities assigned to this resource by the user."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ManagedServiceIdentityType"],
        user_assigned_identities: Optional[dict[str, "_models.UserAssignedIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketplacePlan(_Model):
    """MarketplacePlan.

    :ivar offer_id: The identifying name of the Offer of the Marketplace Plan.
    :vartype offer_id: str
    :ivar plan_id: The identifying name of the Plan of the Marketplace Plan.
    :vartype plan_id: str
    :ivar publisher_id: The identifying name of the Publisher of the Marketplace Plan.
    :vartype publisher_id: str
    """

    offer_id: Optional[str] = rest_field(name="offerId", visibility=["read"])
    """The identifying name of the Offer of the Marketplace Plan."""
    plan_id: Optional[str] = rest_field(name="planId", visibility=["read"])
    """The identifying name of the Plan of the Marketplace Plan."""
    publisher_id: Optional[str] = rest_field(name="publisherId", visibility=["read"])
    """The identifying name of the Publisher of the Marketplace Plan."""


class MarketplaceSubscription(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.MarketplaceSubscriptionProperties
    """

    properties: "_models.MarketplaceSubscriptionProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.MarketplaceSubscriptionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketplaceSubscriptionProperties(_Model):
    """MarketplaceSubscriptionProperties.

    :ivar marketplace_plan: Marketplace Plan associated with the Marketplace Subscription.
    :vartype marketplace_plan: ~azure.mgmt.machinelearningservices.models.MarketplacePlan
    :ivar marketplace_subscription_status: Current status of the Marketplace Subscription. Known
     values are: "Subscribed", "Suspended", and "Unsubscribed".
    :vartype marketplace_subscription_status: str or
     ~azure.mgmt.machinelearningservices.models.MarketplaceSubscriptionStatus
    :ivar model_id: [Required] Target Marketplace Model ID to create a Marketplace Subscription
     for. Required.
    :vartype model_id: str
    :ivar provisioning_state: Provisioning State of the Marketplace Subscription. Known values are:
     "Creating", "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.MarketplaceSubscriptionProvisioningState
    """

    marketplace_plan: Optional["_models.MarketplacePlan"] = rest_field(name="marketplacePlan", visibility=["read"])
    """Marketplace Plan associated with the Marketplace Subscription."""
    marketplace_subscription_status: Optional[Union[str, "_models.MarketplaceSubscriptionStatus"]] = rest_field(
        name="marketplaceSubscriptionStatus", visibility=["read"]
    )
    """Current status of the Marketplace Subscription. Known values are: \"Subscribed\",
     \"Suspended\", and \"Unsubscribed\"."""
    model_id: str = rest_field(name="modelId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Target Marketplace Model ID to create a Marketplace Subscription for. Required."""
    provisioning_state: Optional[Union[str, "_models.MarketplaceSubscriptionProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning State of the Marketplace Subscription. Known values are: \"Creating\",
     \"Deleting\", \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""

    @overload
    def __init__(
        self,
        *,
        model_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MaterializationComputeResource(_Model):
    """DTO object representing compute resource.

    :ivar instance_type: Specifies the instance type.
    :vartype instance_type: str
    """

    instance_type: Optional[str] = rest_field(
        name="instanceType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the instance type."""

    @overload
    def __init__(
        self,
        *,
        instance_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MaterializationSettings(_Model):
    """MaterializationSettings.

    :ivar notification: Specifies the notification details.
    :vartype notification: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar resource: Specifies the compute resource settings.
    :vartype resource: ~azure.mgmt.machinelearningservices.models.MaterializationComputeResource
    :ivar schedule: Specifies the schedule details.
    :vartype schedule: ~azure.mgmt.machinelearningservices.models.RecurrenceTrigger
    :ivar spark_configuration: Specifies the spark compute settings.
    :vartype spark_configuration: dict[str, str]
    :ivar store_type: Specifies the stores to which materialization should happen. Known values
     are: "None", "Online", "Offline", and "OnlineAndOffline".
    :vartype store_type: str or ~azure.mgmt.machinelearningservices.models.MaterializationStoreType
    """

    notification: Optional["_models.NotificationSetting"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the notification details."""
    resource: Optional["_models.MaterializationComputeResource"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the compute resource settings."""
    schedule: Optional["_models.RecurrenceTrigger"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the schedule details."""
    spark_configuration: Optional[dict[str, str]] = rest_field(
        name="sparkConfiguration", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the spark compute settings."""
    store_type: Optional[Union[str, "_models.MaterializationStoreType"]] = rest_field(
        name="storeType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the stores to which materialization should happen. Known values are: \"None\",
     \"Online\", \"Offline\", and \"OnlineAndOffline\"."""

    @overload
    def __init__(
        self,
        *,
        notification: Optional["_models.NotificationSetting"] = None,
        resource: Optional["_models.MaterializationComputeResource"] = None,
        schedule: Optional["_models.RecurrenceTrigger"] = None,
        spark_configuration: Optional[dict[str, str]] = None,
        store_type: Optional[Union[str, "_models.MaterializationStoreType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MedianStoppingPolicy(EarlyTerminationPolicy, discriminator="MedianStopping"):
    """Defines an early termination policy based on running averages of the primary metric of all
    runs.

    :ivar delay_evaluation: Number of intervals by which to delay the first evaluation.
    :vartype delay_evaluation: int
    :ivar evaluation_interval: Interval (number of runs) between policy evaluations.
    :vartype evaluation_interval: int
    :ivar policy_type: [Required] Name of policy configuration. Required.
    :vartype policy_type: str or ~azure.mgmt.machinelearningservices.models.MEDIAN_STOPPING
    """

    policy_type: Literal[EarlyTerminationPolicyType.MEDIAN_STOPPING] = rest_discriminator(name="policyType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Name of policy configuration. Required."""

    @overload
    def __init__(
        self,
        *,
        delay_evaluation: Optional[int] = None,
        evaluation_interval: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.policy_type = EarlyTerminationPolicyType.MEDIAN_STOPPING  # type: ignore


class MLFlowModelJobInput(JobInput, discriminator="mlflow_model"):
    """MLFlowModelJobInput.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar mode: Enum to determine the input data delivery mode. Known values are: "ReadOnlyMount",
     "ReadWriteMount", "Download", "Direct", "EvalMount", and "EvalDownload".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.InputDeliveryMode
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.MLFLOW_MODEL
    """

    mode: Optional[Union[str, "_models.InputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Enum to determine the input data delivery mode. Known values are: \"ReadOnlyMount\",
     \"ReadWriteMount\", \"Download\", \"Direct\", \"EvalMount\", and \"EvalDownload\"."""
    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input Asset URI. Required."""
    job_input_type: Literal[JobInputType.MLFLOW_MODEL] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        uri: str,
        description: Optional[str] = None,
        mode: Optional[Union[str, "_models.InputDeliveryMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.MLFLOW_MODEL  # type: ignore


class MLFlowModelJobOutput(JobOutput, discriminator="mlflow_model"):
    """MLFlowModelJobOutput.

    :ivar description: Description for the output.
    :vartype description: str
    :ivar asset_name: Output Asset Name.
    :vartype asset_name: str
    :ivar mode: Output data delivery mode enums. Known values are: "ReadWriteMount", "Upload", and
     "Direct".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.OutputDeliveryMode
    :ivar uri: Output Asset URI.
    :vartype uri: str
    :ivar job_output_type: [Required] Specifies the type of job. Required.
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.MLFLOW_MODEL
    """

    asset_name: Optional[str] = rest_field(name="assetName", visibility=["read", "create", "update", "delete", "query"])
    """Output Asset Name."""
    mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Output data delivery mode enums. Known values are: \"ReadWriteMount\", \"Upload\", and
     \"Direct\"."""
    uri: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Output Asset URI."""
    job_output_type: Literal[JobOutputType.MLFLOW_MODEL] = rest_discriminator(name="jobOutputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = None,
        uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_output_type = JobOutputType.MLFLOW_MODEL  # type: ignore


class MLTableData(DataVersionBaseProperties, discriminator="mltable"):
    """MLTable data definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_uri: [Required] Uri of the data. Example:
     `https://go.microsoft.com/fwlink/?linkid=2202330
     <https://go.microsoft.com/fwlink/?linkid=2202330>`_. Required.
    :vartype data_uri: str
    :ivar referenced_uris: Uris referenced in the MLTable definition (required for lineage).
    :vartype referenced_uris: list[str]
    :ivar data_type: [Required] Specifies the type of data. Required.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.MLTABLE
    """

    referenced_uris: Optional[list[str]] = rest_field(name="referencedUris", visibility=["read", "create"])
    """Uris referenced in the MLTable definition (required for lineage)."""
    data_type: Literal[DataType.MLTABLE] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of data. Required."""

    @overload
    def __init__(
        self,
        *,
        data_uri: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        referenced_uris: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = DataType.MLTABLE  # type: ignore


class MLTableJobInput(JobInput, discriminator="mltable"):
    """MLTableJobInput.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar mode: Enum to determine the input data delivery mode. Known values are: "ReadOnlyMount",
     "ReadWriteMount", "Download", "Direct", "EvalMount", and "EvalDownload".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.InputDeliveryMode
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.MLTABLE
    """

    mode: Optional[Union[str, "_models.InputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Enum to determine the input data delivery mode. Known values are: \"ReadOnlyMount\",
     \"ReadWriteMount\", \"Download\", \"Direct\", \"EvalMount\", and \"EvalDownload\"."""
    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input Asset URI. Required."""
    job_input_type: Literal[JobInputType.MLTABLE] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        uri: str,
        description: Optional[str] = None,
        mode: Optional[Union[str, "_models.InputDeliveryMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.MLTABLE  # type: ignore


class MLTableJobOutput(JobOutput, discriminator="mltable"):
    """MLTableJobOutput.

    :ivar description: Description for the output.
    :vartype description: str
    :ivar asset_name: Output Asset Name.
    :vartype asset_name: str
    :ivar mode: Output data delivery mode enums. Known values are: "ReadWriteMount", "Upload", and
     "Direct".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.OutputDeliveryMode
    :ivar uri: Output Asset URI.
    :vartype uri: str
    :ivar job_output_type: [Required] Specifies the type of job. Required.
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.MLTABLE
    """

    asset_name: Optional[str] = rest_field(name="assetName", visibility=["read", "create", "update", "delete", "query"])
    """Output Asset Name."""
    mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Output data delivery mode enums. Known values are: \"ReadWriteMount\", \"Upload\", and
     \"Direct\"."""
    uri: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Output Asset URI."""
    job_output_type: Literal[JobOutputType.MLTABLE] = rest_discriminator(name="jobOutputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = None,
        uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_output_type = JobOutputType.MLTABLE  # type: ignore


class ModelContainer(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ModelContainerProperties
    """

    properties: "_models.ModelContainerProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.ModelContainerProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelContainerProperties(AssetContainer):
    """ModelContainerProperties.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar latest_version: The latest version inside this container.
    :vartype latest_version: str
    :ivar next_version: The next auto incremental version.
    :vartype next_version: str
    :ivar provisioning_state: Provisioning state for the model container. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    """

    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the model container. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelSettings(_Model):
    """ModelSettings.

    :ivar model_id: The unique model identifier that this ServerlessEndpoint should provision.
    :vartype model_id: str
    """

    model_id: Optional[str] = rest_field(name="modelId", visibility=["read", "create", "update", "delete", "query"])
    """The unique model identifier that this ServerlessEndpoint should provision."""

    @overload
    def __init__(
        self,
        *,
        model_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelVersion(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ModelVersionProperties
    """

    properties: "_models.ModelVersionProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.ModelVersionProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelVersionProperties(AssetBase):
    """Model asset version details.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar flavors: Mapping of model flavors to their properties.
    :vartype flavors: dict[str, ~azure.mgmt.machinelearningservices.models.FlavorData]
    :ivar job_name: Name of the training job which produced this model.
    :vartype job_name: str
    :ivar model_type: The storage format for this entity. Used for NCD.
    :vartype model_type: str
    :ivar model_uri: The URI path to the model contents.
    :vartype model_uri: str
    :ivar provisioning_state: Provisioning state for the model version. Known values are:
     "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.AssetProvisioningState
    :ivar stage: Stage in the model lifecycle assigned to this model.
    :vartype stage: str
    :ivar datasets: Array of dataset references.
    :vartype datasets: list[~azure.mgmt.machinelearningservices.models.DatasetReference]
    """

    flavors: Optional[dict[str, "_models.FlavorData"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Mapping of model flavors to their properties."""
    job_name: Optional[str] = rest_field(name="jobName", visibility=["read", "create", "update", "delete", "query"])
    """Name of the training job which produced this model."""
    model_type: Optional[str] = rest_field(name="modelType", visibility=["read", "create", "update", "delete", "query"])
    """The storage format for this entity. Used for NCD."""
    model_uri: Optional[str] = rest_field(name="modelUri", visibility=["read", "create", "update", "delete", "query"])
    """The URI path to the model contents."""
    provisioning_state: Optional[Union[str, "_models.AssetProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the model version. Known values are: \"Succeeded\", \"Failed\",
     \"Canceled\", \"Creating\", \"Updating\", and \"Deleting\"."""
    stage: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Stage in the model lifecycle assigned to this model."""
    datasets: Optional[list["_models.DatasetReference"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Array of dataset references."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        flavors: Optional[dict[str, "_models.FlavorData"]] = None,
        job_name: Optional[str] = None,
        model_type: Optional[str] = None,
        model_uri: Optional[str] = None,
        stage: Optional[str] = None,
        datasets: Optional[list["_models.DatasetReference"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitorComputeConfigurationBase(_Model):
    """Monitor compute configuration base definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    MonitorServerlessSparkCompute

    :ivar compute_type: [Required] Specifies the type of signal to monitor. Required.
     "ServerlessSpark"
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.MonitorComputeType
    """

    __mapping__: dict[str, _Model] = {}
    compute_type: str = rest_discriminator(name="computeType", visibility=["read", "create"])
    """[Required] Specifies the type of signal to monitor. Required. \"ServerlessSpark\""""

    @overload
    def __init__(
        self,
        *,
        compute_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitorDefinition(_Model):
    """MonitorDefinition.

    :ivar alert_notification_settings: The monitor's notification settings.
    :vartype alert_notification_settings:
     ~azure.mgmt.machinelearningservices.models.MonitorNotificationSettings
    :ivar compute_configuration: [Required] The ARM resource ID of the compute resource to run the
     monitoring job on. Required.
    :vartype compute_configuration:
     ~azure.mgmt.machinelearningservices.models.MonitorComputeConfigurationBase
    :ivar monitoring_target: The entities targeted by the monitor.
    :vartype monitoring_target: ~azure.mgmt.machinelearningservices.models.MonitoringTarget
    :ivar signals: [Required] The signals to monitor. Required.
    :vartype signals: dict[str, ~azure.mgmt.machinelearningservices.models.MonitoringSignalBase]
    """

    alert_notification_settings: Optional["_models.MonitorNotificationSettings"] = rest_field(
        name="alertNotificationSettings", visibility=["read", "create"]
    )
    """The monitor's notification settings."""
    compute_configuration: "_models.MonitorComputeConfigurationBase" = rest_field(
        name="computeConfiguration", visibility=["read", "create"]
    )
    """[Required] The ARM resource ID of the compute resource to run the monitoring job on. Required."""
    monitoring_target: Optional["_models.MonitoringTarget"] = rest_field(
        name="monitoringTarget", visibility=["read", "create"]
    )
    """The entities targeted by the monitor."""
    signals: dict[str, "_models.MonitoringSignalBase"] = rest_field(visibility=["read", "create"])
    """[Required] The signals to monitor. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_configuration: "_models.MonitorComputeConfigurationBase",
        signals: dict[str, "_models.MonitoringSignalBase"],
        alert_notification_settings: Optional["_models.MonitorNotificationSettings"] = None,
        monitoring_target: Optional["_models.MonitoringTarget"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitorEmailNotificationSettings(_Model):
    """MonitorEmailNotificationSettings.

    :ivar emails: The email recipient list which has a limitation of 499 characters in total.
    :vartype emails: list[str]
    """

    emails: Optional[list[str]] = rest_field(visibility=["read", "create"])
    """The email recipient list which has a limitation of 499 characters in total."""

    @overload
    def __init__(
        self,
        *,
        emails: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitoringTarget(_Model):
    """Monitoring target definition.

    :ivar deployment_id: Reference to the deployment asset targeted by this monitor.
    :vartype deployment_id: str
    :ivar model_id: Reference to the model asset targeted by this monitor.
    :vartype model_id: str
    :ivar task_type: [Required] The machine learning task type of the monitored model. Required.
     Known values are: "Classification" and "Regression".
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.ModelTaskType
    """

    deployment_id: Optional[str] = rest_field(name="deploymentId", visibility=["read", "create"])
    """Reference to the deployment asset targeted by this monitor."""
    model_id: Optional[str] = rest_field(name="modelId", visibility=["read", "create"])
    """Reference to the model asset targeted by this monitor."""
    task_type: Union[str, "_models.ModelTaskType"] = rest_field(name="taskType", visibility=["read", "create"])
    """[Required] The machine learning task type of the monitored model. Required. Known values are:
     \"Classification\" and \"Regression\"."""

    @overload
    def __init__(
        self,
        *,
        task_type: Union[str, "_models.ModelTaskType"],
        deployment_id: Optional[str] = None,
        model_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitoringThreshold(_Model):
    """MonitoringThreshold.

    :ivar value: The threshold value. If null, the set default is dependent on the metric type.
    :vartype value: float
    """

    value: Optional[float] = rest_field(visibility=["read", "create"])
    """The threshold value. If null, the set default is dependent on the metric type."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitorNotificationSettings(_Model):
    """MonitorNotificationSettings.

    :ivar email_notification_settings: The AML notification email settings.
    :vartype email_notification_settings:
     ~azure.mgmt.machinelearningservices.models.MonitorEmailNotificationSettings
    """

    email_notification_settings: Optional["_models.MonitorEmailNotificationSettings"] = rest_field(
        name="emailNotificationSettings", visibility=["read", "create"]
    )
    """The AML notification email settings."""

    @overload
    def __init__(
        self,
        *,
        email_notification_settings: Optional["_models.MonitorEmailNotificationSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonitorServerlessSparkCompute(MonitorComputeConfigurationBase, discriminator="ServerlessSpark"):
    """Monitor serverless spark compute definition.

    :ivar compute_identity: [Required] The identity scheme leveraged to by the spark jobs running
     on serverless Spark. Required.
    :vartype compute_identity:
     ~azure.mgmt.machinelearningservices.models.MonitorComputeIdentityBase
    :ivar instance_type: [Required] The instance type running the Spark job. Required.
    :vartype instance_type: str
    :ivar runtime_version: [Required] The Spark runtime version. Required.
    :vartype runtime_version: str
    :ivar compute_type: [Required] Specifies the type of signal to monitor. Required. Serverless
     Spark compute.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.SERVERLESS_SPARK
    """

    compute_identity: "_models.MonitorComputeIdentityBase" = rest_field(
        name="computeIdentity", visibility=["read", "create"]
    )
    """[Required] The identity scheme leveraged to by the spark jobs running on serverless Spark.
     Required."""
    instance_type: str = rest_field(name="instanceType", visibility=["read", "create"])
    """[Required] The instance type running the Spark job. Required."""
    runtime_version: str = rest_field(name="runtimeVersion", visibility=["read", "create"])
    """[Required] The Spark runtime version. Required."""
    compute_type: Literal[MonitorComputeType.SERVERLESS_SPARK] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. Serverless Spark compute."""

    @overload
    def __init__(
        self,
        *,
        compute_identity: "_models.MonitorComputeIdentityBase",
        instance_type: str,
        runtime_version: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = MonitorComputeType.SERVERLESS_SPARK  # type: ignore


class Mpi(DistributionConfiguration, discriminator="Mpi"):
    """MPI distribution configuration.

    :ivar process_count_per_instance: Number of processes per MPI node.
    :vartype process_count_per_instance: int
    :ivar distribution_type: [Required] Specifies the type of distribution framework. Required.
    :vartype distribution_type: str or ~azure.mgmt.machinelearningservices.models.MPI
    """

    process_count_per_instance: Optional[int] = rest_field(
        name="processCountPerInstance", visibility=["read", "create"]
    )
    """Number of processes per MPI node."""
    distribution_type: Literal[DistributionType.MPI] = rest_discriminator(name="distributionType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of distribution framework. Required."""

    @overload
    def __init__(
        self,
        *,
        process_count_per_instance: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.distribution_type = DistributionType.MPI  # type: ignore


class NetworkAcls(_Model):
    """NetworkAcls.

    :ivar default_action: The default action when no rule from ipRules and from virtualNetworkRules
     match. This is only used after the bypass property has been evaluated. Known values are: "Deny"
     and "Allow".
    :vartype default_action: str or ~azure.mgmt.machinelearningservices.models.DefaultActionType
    :ivar ip_rules: Rules governing the accessibility of a resource from a specific ip address or
     ip range.
    :vartype ip_rules: list[~azure.mgmt.machinelearningservices.models.IPRule]
    """

    default_action: Optional[Union[str, "_models.DefaultActionType"]] = rest_field(
        name="defaultAction", visibility=["read", "create", "update", "delete", "query"]
    )
    """The default action when no rule from ipRules and from virtualNetworkRules match. This is only
     used after the bypass property has been evaluated. Known values are: \"Deny\" and \"Allow\"."""
    ip_rules: Optional[list["_models.IPRule"]] = rest_field(
        name="ipRules", visibility=["read", "create", "update", "delete", "query"]
    )
    """Rules governing the accessibility of a resource from a specific ip address or ip range."""

    @overload
    def __init__(
        self,
        *,
        default_action: Optional[Union[str, "_models.DefaultActionType"]] = None,
        ip_rules: Optional[list["_models.IPRule"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NlpVerticalFeaturizationSettings(FeaturizationSettings):
    """NlpVerticalFeaturizationSettings.

    :ivar dataset_language: Dataset language, useful for the text data.
    :vartype dataset_language: str
    """

    @overload
    def __init__(
        self,
        *,
        dataset_language: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NlpVerticalLimitSettings(_Model):
    """Job execution constraints.

    :ivar max_concurrent_trials: Maximum Concurrent AutoML iterations.
    :vartype max_concurrent_trials: int
    :ivar max_trials: Number of AutoML iterations.
    :vartype max_trials: int
    :ivar timeout: AutoML job timeout.
    :vartype timeout: ~datetime.timedelta
    """

    max_concurrent_trials: Optional[int] = rest_field(
        name="maxConcurrentTrials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum Concurrent AutoML iterations."""
    max_trials: Optional[int] = rest_field(name="maxTrials", visibility=["read", "create", "update", "delete", "query"])
    """Number of AutoML iterations."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """AutoML job timeout."""

    @overload
    def __init__(
        self,
        *,
        max_concurrent_trials: Optional[int] = None,
        max_trials: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NodeStateCounts(_Model):
    """Counts of various compute node states on the amlCompute.

    :ivar idle_node_count: Idle node count.
    :vartype idle_node_count: int
    :ivar running_node_count: Running node count.
    :vartype running_node_count: int
    :ivar preparing_node_count: Preparing node count.
    :vartype preparing_node_count: int
    :ivar unusable_node_count: Unusable node count.
    :vartype unusable_node_count: int
    :ivar leaving_node_count: Leaving node count.
    :vartype leaving_node_count: int
    :ivar preempted_node_count: Preempted node count.
    :vartype preempted_node_count: int
    """

    idle_node_count: Optional[int] = rest_field(name="idleNodeCount", visibility=["read"])
    """Idle node count."""
    running_node_count: Optional[int] = rest_field(name="runningNodeCount", visibility=["read"])
    """Running node count."""
    preparing_node_count: Optional[int] = rest_field(name="preparingNodeCount", visibility=["read"])
    """Preparing node count."""
    unusable_node_count: Optional[int] = rest_field(name="unusableNodeCount", visibility=["read"])
    """Unusable node count."""
    leaving_node_count: Optional[int] = rest_field(name="leavingNodeCount", visibility=["read"])
    """Leaving node count."""
    preempted_node_count: Optional[int] = rest_field(name="preemptedNodeCount", visibility=["read"])
    """Preempted node count."""


class NoneAuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="None"
):  # pylint: disable=name-too-long
    """NoneAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.NONE
    """

    auth_type: Literal[ConnectionAuthType.NONE] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.NONE  # type: ignore


class NoneDatastoreCredentials(DatastoreCredentials, discriminator="None"):
    """Empty/none datastore credentials.

    :ivar credentials_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credentials_type: str or ~azure.mgmt.machinelearningservices.models.NONE
    """

    credentials_type: Literal[CredentialsType.NONE] = rest_discriminator(name="credentialsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credentials_type = CredentialsType.NONE  # type: ignore


class NotebookAccessTokenResult(_Model):
    """NotebookAccessTokenResult.

    :ivar access_token:
    :vartype access_token: str
    :ivar expires_in:
    :vartype expires_in: int
    :ivar host_name:
    :vartype host_name: str
    :ivar notebook_resource_id:
    :vartype notebook_resource_id: str
    :ivar public_dns:
    :vartype public_dns: str
    :ivar refresh_token:
    :vartype refresh_token: str
    :ivar scope:
    :vartype scope: str
    :ivar token_type:
    :vartype token_type: str
    """

    access_token: Optional[str] = rest_field(name="accessToken", visibility=["read"])
    expires_in: Optional[int] = rest_field(name="expiresIn", visibility=["read"])
    host_name: Optional[str] = rest_field(name="hostName", visibility=["read"])
    notebook_resource_id: Optional[str] = rest_field(name="notebookResourceId", visibility=["read"])
    public_dns: Optional[str] = rest_field(name="publicDns", visibility=["read"])
    refresh_token: Optional[str] = rest_field(name="refreshToken", visibility=["read"])
    scope: Optional[str] = rest_field(visibility=["read"])
    token_type: Optional[str] = rest_field(name="tokenType", visibility=["read"])


class NotebookPreparationError(_Model):
    """NotebookPreparationError.

    :ivar error_message:
    :vartype error_message: str
    :ivar status_code:
    :vartype status_code: int
    """

    error_message: Optional[str] = rest_field(
        name="errorMessage", visibility=["read", "create", "update", "delete", "query"]
    )
    status_code: Optional[int] = rest_field(
        name="statusCode", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        error_message: Optional[str] = None,
        status_code: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NotebookResourceInfo(_Model):
    """NotebookResourceInfo.

    :ivar fqdn:
    :vartype fqdn: str
    :ivar is_private_link_enabled:
    :vartype is_private_link_enabled: bool
    :ivar notebook_preparation_error: The error that occurs when preparing notebook.
    :vartype notebook_preparation_error:
     ~azure.mgmt.machinelearningservices.models.NotebookPreparationError
    :ivar resource_id: the data plane resourceId that used to initialize notebook component.
    :vartype resource_id: str
    """

    fqdn: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    is_private_link_enabled: Optional[bool] = rest_field(
        name="isPrivateLinkEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    notebook_preparation_error: Optional["_models.NotebookPreparationError"] = rest_field(
        name="notebookPreparationError", visibility=["read", "create", "update", "delete", "query"]
    )
    """The error that occurs when preparing notebook."""
    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """the data plane resourceId that used to initialize notebook component."""

    @overload
    def __init__(
        self,
        *,
        fqdn: Optional[str] = None,
        is_private_link_enabled: Optional[bool] = None,
        notebook_preparation_error: Optional["_models.NotebookPreparationError"] = None,
        resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NotificationSetting(_Model):
    """Configuration for notification.

    :ivar email_on: Send email notification to user on specified notification type.
    :vartype email_on: list[str or
     ~azure.mgmt.machinelearningservices.models.EmailNotificationEnableType]
    :ivar emails: This is the email recipient list which has a limitation of 499 characters in
     total concat with comma separator.
    :vartype emails: list[str]
    :ivar webhooks: Send webhook callback to a service. Key is a user-provided name for the
     webhook.
    :vartype webhooks: dict[str, ~azure.mgmt.machinelearningservices.models.Webhook]
    """

    email_on: Optional[list[Union[str, "_models.EmailNotificationEnableType"]]] = rest_field(
        name="emailOn", visibility=["read", "create"]
    )
    """Send email notification to user on specified notification type."""
    emails: Optional[list[str]] = rest_field(visibility=["read", "create"])
    """This is the email recipient list which has a limitation of 499 characters in total concat with
     comma separator."""
    webhooks: Optional[dict[str, "_models.Webhook"]] = rest_field(visibility=["read", "create", "update"])
    """Send webhook callback to a service. Key is a user-provided name for the webhook."""

    @overload
    def __init__(
        self,
        *,
        email_on: Optional[list[Union[str, "_models.EmailNotificationEnableType"]]] = None,
        emails: Optional[list[str]] = None,
        webhooks: Optional[dict[str, "_models.Webhook"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NumericalDataDriftMetricThreshold(DataDriftMetricThresholdBase, discriminator="Numerical"):
    """NumericalDataDriftMetricThreshold.

    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    :ivar metric: [Required] The numerical data drift metric to calculate. Required. Known values
     are: "JensenShannonDistance", "PopulationStabilityIndex", "NormalizedWassersteinDistance", and
     "TwoSampleKolmogorovSmirnovTest".
    :vartype metric: str or ~azure.mgmt.machinelearningservices.models.NumericalDataDriftMetric
    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Used for
     features of numerical data type.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.NUMERICAL
    """

    metric: Union[str, "_models.NumericalDataDriftMetric"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The numerical data drift metric to calculate. Required. Known values are:
     \"JensenShannonDistance\", \"PopulationStabilityIndex\", \"NormalizedWassersteinDistance\", and
     \"TwoSampleKolmogorovSmirnovTest\"."""
    data_type: Literal[MonitoringFeatureDataType.NUMERICAL] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the data type of the metric threshold. Required. Used for features of
     numerical data type."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.NumericalDataDriftMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = MonitoringFeatureDataType.NUMERICAL  # type: ignore


class NumericalDataQualityMetricThreshold(DataQualityMetricThresholdBase, discriminator="Numerical"):
    """NumericalDataQualityMetricThreshold.

    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    :ivar metric: [Required] The numerical data quality metric to calculate. Required. Known values
     are: "NullValueRate", "DataTypeErrorRate", and "OutOfBoundsRate".
    :vartype metric: str or ~azure.mgmt.machinelearningservices.models.NumericalDataQualityMetric
    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Used for
     features of numerical data type.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.NUMERICAL
    """

    metric: Union[str, "_models.NumericalDataQualityMetric"] = rest_field(visibility=["read", "create"])
    """[Required] The numerical data quality metric to calculate. Required. Known values are:
     \"NullValueRate\", \"DataTypeErrorRate\", and \"OutOfBoundsRate\"."""
    data_type: Literal[MonitoringFeatureDataType.NUMERICAL] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the data type of the metric threshold. Required. Used for features of
     numerical data type."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.NumericalDataQualityMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = MonitoringFeatureDataType.NUMERICAL  # type: ignore


class NumericalPredictionDriftMetricThreshold(PredictionDriftMetricThresholdBase, discriminator="Numerical"):
    """NumericalPredictionDriftMetricThreshold.

    :ivar threshold: The threshold value. If null, a default value will be set depending on the
     selected metric.
    :vartype threshold: ~azure.mgmt.machinelearningservices.models.MonitoringThreshold
    :ivar metric: [Required] The numerical prediction drift metric to calculate. Required. Known
     values are: "JensenShannonDistance", "PopulationStabilityIndex",
     "NormalizedWassersteinDistance", and "TwoSampleKolmogorovSmirnovTest".
    :vartype metric: str or
     ~azure.mgmt.machinelearningservices.models.NumericalPredictionDriftMetric
    :ivar data_type: [Required] Specifies the data type of the metric threshold. Required. Used for
     features of numerical data type.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.NUMERICAL
    """

    metric: Union[str, "_models.NumericalPredictionDriftMetric"] = rest_field(visibility=["read", "create"])
    """[Required] The numerical prediction drift metric to calculate. Required. Known values are:
     \"JensenShannonDistance\", \"PopulationStabilityIndex\", \"NormalizedWassersteinDistance\", and
     \"TwoSampleKolmogorovSmirnovTest\"."""
    data_type: Literal[MonitoringFeatureDataType.NUMERICAL] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the data type of the metric threshold. Required. Used for features of
     numerical data type."""

    @overload
    def __init__(
        self,
        *,
        metric: Union[str, "_models.NumericalPredictionDriftMetric"],
        threshold: Optional["_models.MonitoringThreshold"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = MonitoringFeatureDataType.NUMERICAL  # type: ignore


class OAuth2AuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="OAuth2"
):  # pylint: disable=name-too-long
    """OAuth2AuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionOAuth2
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.O_AUTH2
    """

    credentials: Optional["_models.WorkspaceConnectionOAuth2"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.O_AUTH2] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionOAuth2"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.O_AUTH2  # type: ignore


class Objective(_Model):
    """Optimization objective.

    :ivar goal: [Required] Defines supported metric goals for hyperparameter tuning. Required.
     Known values are: "Minimize" and "Maximize".
    :vartype goal: str or ~azure.mgmt.machinelearningservices.models.Goal
    :ivar primary_metric: [Required] Name of the metric to optimize. Required.
    :vartype primary_metric: str
    """

    goal: Union[str, "_models.Goal"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Defines supported metric goals for hyperparameter tuning. Required. Known values
     are: \"Minimize\" and \"Maximize\"."""
    primary_metric: str = rest_field(name="primaryMetric", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Name of the metric to optimize. Required."""

    @overload
    def __init__(
        self,
        *,
        goal: Union[str, "_models.Goal"],
        primary_metric: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OneLakeDatastore(DatastoreProperties, discriminator="OneLake"):
    """OneLake (Trident) datastore configuration.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar credentials: [Required] Account credentials. Required.
    :vartype credentials: ~azure.mgmt.machinelearningservices.models.DatastoreCredentials
    :ivar is_default: Readonly property to indicate if datastore is the workspace default
     datastore.
    :vartype is_default: bool
    :ivar artifact: [Required] OneLake artifact backing the datastore. Required.
    :vartype artifact: ~azure.mgmt.machinelearningservices.models.OneLakeArtifact
    :ivar endpoint: OneLake endpoint to use for the datastore.
    :vartype endpoint: str
    :ivar one_lake_workspace_name: [Required] OneLake workspace name. Required.
    :vartype one_lake_workspace_name: str
    :ivar service_data_access_auth_identity: Indicates which identity to use to authenticate
     service data access to customer's storage. Known values are: "None",
     "WorkspaceSystemAssignedIdentity", and "WorkspaceUserAssignedIdentity".
    :vartype service_data_access_auth_identity: str or
     ~azure.mgmt.machinelearningservices.models.ServiceDataAccessAuthIdentity
    :ivar datastore_type: [Required] Storage type backing the datastore. Required.
    :vartype datastore_type: str or ~azure.mgmt.machinelearningservices.models.ONE_LAKE
    """

    artifact: "_models.OneLakeArtifact" = rest_field(visibility=["read", "create"])
    """[Required] OneLake artifact backing the datastore. Required."""
    endpoint: Optional[str] = rest_field(visibility=["read", "create"])
    """OneLake endpoint to use for the datastore."""
    one_lake_workspace_name: str = rest_field(name="oneLakeWorkspaceName", visibility=["read", "create"])
    """[Required] OneLake workspace name. Required."""
    service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = rest_field(
        name="serviceDataAccessAuthIdentity", visibility=["read", "create"]
    )
    """Indicates which identity to use to authenticate service data access to customer's storage.
     Known values are: \"None\", \"WorkspaceSystemAssignedIdentity\", and
     \"WorkspaceUserAssignedIdentity\"."""
    datastore_type: Literal[DatastoreType.ONE_LAKE] = rest_discriminator(name="datastoreType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Storage type backing the datastore. Required."""

    @overload
    def __init__(
        self,
        *,
        credentials: "_models.DatastoreCredentials",
        artifact: "_models.OneLakeArtifact",
        one_lake_workspace_name: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        endpoint: Optional[str] = None,
        service_data_access_auth_identity: Optional[Union[str, "_models.ServiceDataAccessAuthIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.datastore_type = DatastoreType.ONE_LAKE  # type: ignore


class OnlineDeployment(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.OnlineDeploymentProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.OnlineDeploymentProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.OnlineDeploymentProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineEndpoint(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.OnlineEndpointProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.OnlineEndpointProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.OnlineEndpointProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineEndpointProperties(EndpointPropertiesBase):
    """Online endpoint configuration.

    :ivar auth_mode: [Required] The authentication method for invoking the endpoint (data plane
     operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning
     token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
     Required. Known values are: "AMLToken", "Key", and "AADToken".
    :vartype auth_mode: str or ~azure.mgmt.machinelearningservices.models.EndpointAuthMode
    :ivar description: Description of the inference endpoint.
    :vartype description: str
    :ivar keys_property: EndpointAuthKeys to set initially on an Endpoint.
     This property will always be returned as null. AuthKey values must be retrieved using the
     ListKeys API.
    :vartype keys_property: ~azure.mgmt.machinelearningservices.models.EndpointAuthKeys
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar scoring_uri: Endpoint URI.
    :vartype scoring_uri: str
    :ivar swagger_uri: Endpoint Swagger URI.
    :vartype swagger_uri: str
    :ivar compute: ARM resource ID of the compute if it exists.
     optional.
    :vartype compute: str
    :ivar mirror_traffic: Percentage of traffic to be mirrored to each deployment without using
     returned scoring. Traffic values need to sum to utmost 50.
    :vartype mirror_traffic: dict[str, int]
    :ivar provisioning_state: Provisioning state for the endpoint. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.EndpointProvisioningState
    :ivar public_network_access: Enum to determine whether PublicNetworkAccess is Enabled or
     Disabled. Known values are: "Enabled" and "Disabled".
    :vartype public_network_access: str or
     ~azure.mgmt.machinelearningservices.models.PublicNetworkAccessType
    :ivar traffic: Percentage of traffic from endpoint to divert to each deployment. Traffic values
     need to sum to 100.
    :vartype traffic: dict[str, int]
    """

    compute: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """ARM resource ID of the compute if it exists.
     optional."""
    mirror_traffic: Optional[dict[str, int]] = rest_field(
        name="mirrorTraffic", visibility=["read", "create", "update", "delete", "query"]
    )
    """Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic
     values need to sum to utmost 50."""
    provisioning_state: Optional[Union[str, "_models.EndpointProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the endpoint. Known values are: \"Creating\", \"Deleting\",
     \"Succeeded\", \"Failed\", \"Updating\", and \"Canceled\"."""
    public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = rest_field(
        name="publicNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enum to determine whether PublicNetworkAccess is Enabled or Disabled. Known values are:
     \"Enabled\" and \"Disabled\"."""
    traffic: Optional[dict[str, int]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to
     100."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.EndpointAuthMode"],
        description: Optional[str] = None,
        keys_property: Optional["_models.EndpointAuthKeys"] = None,
        properties: Optional[dict[str, str]] = None,
        compute: Optional[str] = None,
        mirror_traffic: Optional[dict[str, int]] = None,
        public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = None,
        traffic: Optional[dict[str, int]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OnlineRequestSettings(_Model):
    """Online deployment scoring requests configuration.

    :ivar max_concurrent_requests_per_instance: The number of maximum concurrent requests per node
     allowed per deployment. Defaults to 1.
    :vartype max_concurrent_requests_per_instance: int
    :ivar max_queue_wait: (Deprecated for Managed Online Endpoints) The maximum amount of time a
     request will stay in the queue in ISO 8601 format.
     Defaults to 500ms.
     (Now increase ``request_timeout_ms`` to account for any networking/queue delays).
    :vartype max_queue_wait: ~datetime.timedelta
    :ivar request_timeout: The scoring timeout in ISO 8601 format.
     Defaults to 5000ms.
    :vartype request_timeout: ~datetime.timedelta
    """

    max_concurrent_requests_per_instance: Optional[int] = rest_field(
        name="maxConcurrentRequestsPerInstance", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of maximum concurrent requests per node allowed per deployment. Defaults to 1."""
    max_queue_wait: Optional[datetime.timedelta] = rest_field(
        name="maxQueueWait", visibility=["read", "create", "update", "delete", "query"]
    )
    """(Deprecated for Managed Online Endpoints) The maximum amount of time a request will stay in the
     queue in ISO 8601 format.
     Defaults to 500ms.
     (Now increase ``request_timeout_ms`` to account for any networking/queue delays)."""
    request_timeout: Optional[datetime.timedelta] = rest_field(
        name="requestTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The scoring timeout in ISO 8601 format.
     Defaults to 5000ms."""

    @overload
    def __init__(
        self,
        *,
        max_concurrent_requests_per_instance: Optional[int] = None,
        max_queue_wait: Optional[datetime.timedelta] = None,
        request_timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OpenAIEndpointDeploymentResourceProperties(
    EndpointDeploymentResourceProperties, discriminator="Azure.OpenAI"
):  # pylint: disable=name-too-long
    """OpenAIEndpointDeploymentResourceProperties.

    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar model: Model used for the endpoint deployment. Required.
    :vartype model: ~azure.mgmt.machinelearningservices.models.EndpointDeploymentModel
    :ivar rai_policy_name: The name of RAI policy.
    :vartype rai_policy_name: str
    :ivar sku:
    :vartype sku: ~azure.mgmt.machinelearningservices.models.CognitiveServicesSku
    :ivar version_upgrade_option: Deployment model version upgrade option. Known values are:
     "OnceNewDefaultVersionAvailable", "OnceCurrentVersionExpired", and "NoAutoUpgrade".
    :vartype version_upgrade_option: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentModelVersionUpgradeOption
    :ivar type: Kind of the deployment. Required. Default value is "Azure.OpenAI".
    :vartype type: str
    """

    model: "_models.EndpointDeploymentModel" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model used for the endpoint deployment. Required."""
    rai_policy_name: Optional[str] = rest_field(
        name="raiPolicyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of RAI policy."""
    sku: Optional["_models.CognitiveServicesSku"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    version_upgrade_option: Optional[Union[str, "_models.DeploymentModelVersionUpgradeOption"]] = rest_field(
        name="versionUpgradeOption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Deployment model version upgrade option. Known values are: \"OnceNewDefaultVersionAvailable\",
     \"OnceCurrentVersionExpired\", and \"NoAutoUpgrade\"."""
    type: Literal["Azure.OpenAI"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Kind of the deployment. Required. Default value is \"Azure.OpenAI\"."""

    @overload
    def __init__(
        self,
        *,
        model: "_models.EndpointDeploymentModel",
        failure_reason: Optional[str] = None,
        rai_policy_name: Optional[str] = None,
        sku: Optional["_models.CognitiveServicesSku"] = None,
        version_upgrade_option: Optional[Union[str, "_models.DeploymentModelVersionUpgradeOption"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = "Azure.OpenAI"  # type: ignore


class OpenAIEndpointResourceProperties(EndpointResourceProperties, discriminator="Azure.OpenAI"):
    """OpenAIEndpointResourceProperties.

    :ivar associated_resource_id: Byo resource id for creating the built-in model service
     endpoints.
    :vartype associated_resource_id: str
    :ivar deployments: Deployments info.
    :vartype deployments:
     list[~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourcePropertiesBasicResource]
    :ivar endpoint_uri: Uri of the endpoint.
    :vartype endpoint_uri: str
    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar location: Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace.
    :vartype location: str
    :ivar name: Name of the endpoint.
    :vartype name: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar should_create_ai_services_endpoint: Whether the proxy (non-byo) endpoint is a regular
     endpoint or a OneKeyV2 AI services account endpoint.
    :vartype should_create_ai_services_endpoint: bool
    :ivar endpoint_type: Type of the endpoint. Required.
    :vartype endpoint_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_OPEN_AI
    """

    endpoint_type: Literal[EndpointType.AZURE_OPEN_AI] = rest_discriminator(name="endpointType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        associated_resource_id: Optional[str] = None,
        deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = None,
        endpoint_uri: Optional[str] = None,
        failure_reason: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        should_create_ai_services_endpoint: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_type = EndpointType.AZURE_OPEN_AI  # type: ignore


class Operation(_Model):
    """REST API Operation.

    :ivar name: The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action".
    :vartype name: str
    :ivar is_data_action: Whether the operation applies to data-plane. This is "true" for
     data-plane operations and "false" for Azure Resource Manager/control-plane operations.
    :vartype is_data_action: bool
    :ivar display: Localized display information for this particular operation.
    :vartype display: ~azure.mgmt.machinelearningservices.models.OperationDisplay
    :ivar origin: The intended executor of the operation; as in Resource Based Access Control
     (RBAC) and audit logs UX. Default value is "user,system". Known values are: "user", "system",
     and "user,system".
    :vartype origin: str or ~azure.mgmt.machinelearningservices.models.Origin
    :ivar action_type: Extensible enum. Indicates the action type. "Internal" refers to actions
     that are for internal only APIs. "Internal"
    :vartype action_type: str or ~azure.mgmt.machinelearningservices.models.ActionType
    """

    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     \"Microsoft.Compute/virtualMachines/write\",
     \"Microsoft.Compute/virtualMachines/capture/action\"."""
    is_data_action: Optional[bool] = rest_field(name="isDataAction", visibility=["read"])
    """Whether the operation applies to data-plane. This is \"true\" for data-plane operations and
     \"false\" for Azure Resource Manager/control-plane operations."""
    display: Optional["_models.OperationDisplay"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Localized display information for this particular operation."""
    origin: Optional[Union[str, "_models.Origin"]] = rest_field(visibility=["read"])
    """The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit
     logs UX. Default value is \"user,system\". Known values are: \"user\", \"system\", and
     \"user,system\"."""
    action_type: Optional[Union[str, "_models.ActionType"]] = rest_field(name="actionType", visibility=["read"])
    """Extensible enum. Indicates the action type. \"Internal\" refers to actions that are for
     internal only APIs. \"Internal\""""

    @overload
    def __init__(
        self,
        *,
        display: Optional["_models.OperationDisplay"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OperationDisplay(_Model):
    """Localized display information for and operation.

    :ivar provider: The localized friendly form of the resource provider name, e.g. "Microsoft
     Monitoring Insights" or "Microsoft Compute".
    :vartype provider: str
    :ivar resource: The localized friendly name of the resource type related to this operation.
     E.g. "Virtual Machines" or "Job Schedule Collections".
    :vartype resource: str
    :ivar operation: The concise, localized friendly name for the operation; suitable for
     dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
    :vartype operation: str
    :ivar description: The short, localized friendly description of the operation; suitable for
     tool tips and detailed views.
    :vartype description: str
    """

    provider: Optional[str] = rest_field(visibility=["read"])
    """The localized friendly form of the resource provider name, e.g. \"Microsoft Monitoring
     Insights\" or \"Microsoft Compute\"."""
    resource: Optional[str] = rest_field(visibility=["read"])
    """The localized friendly name of the resource type related to this operation. E.g. \"Virtual
     Machines\" or \"Job Schedule Collections\"."""
    operation: Optional[str] = rest_field(visibility=["read"])
    """The concise, localized friendly name for the operation; suitable for dropdowns. E.g. \"Create
     or Update Virtual Machine\", \"Restart Virtual Machine\"."""
    description: Optional[str] = rest_field(visibility=["read"])
    """The short, localized friendly description of the operation; suitable for tool tips and detailed
     views."""


class OsPatchingStatus(_Model):
    """Returns metadata about the os patching.

    :ivar patch_status: The os patching status. Known values are: "CompletedWithWarnings",
     "Failed", "InProgress", "Succeeded", and "Unknown".
    :vartype patch_status: str or ~azure.mgmt.machinelearningservices.models.PatchStatus
    :ivar latest_patch_time: Time of the latest os patching.
    :vartype latest_patch_time: str
    :ivar reboot_pending: Specifies whether this compute instance is pending for reboot to finish
     os patching.
    :vartype reboot_pending: bool
    :ivar scheduled_reboot_time: Time of scheduled reboot.
    :vartype scheduled_reboot_time: str
    :ivar os_patching_errors: Collection of errors encountered when doing os patching.
    :vartype os_patching_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    """

    patch_status: Optional[Union[str, "_models.PatchStatus"]] = rest_field(
        name="patchStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """The os patching status. Known values are: \"CompletedWithWarnings\", \"Failed\",
     \"InProgress\", \"Succeeded\", and \"Unknown\"."""
    latest_patch_time: Optional[str] = rest_field(
        name="latestPatchTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """Time of the latest os patching."""
    reboot_pending: Optional[bool] = rest_field(
        name="rebootPending", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies whether this compute instance is pending for reboot to finish os patching."""
    scheduled_reboot_time: Optional[str] = rest_field(
        name="scheduledRebootTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """Time of scheduled reboot."""
    os_patching_errors: Optional[list["_models.ErrorResponse"]] = rest_field(
        name="osPatchingErrors", visibility=["read", "create", "update", "delete", "query"]
    )
    """Collection of errors encountered when doing os patching."""

    @overload
    def __init__(
        self,
        *,
        patch_status: Optional[Union[str, "_models.PatchStatus"]] = None,
        latest_patch_time: Optional[str] = None,
        reboot_pending: Optional[bool] = None,
        scheduled_reboot_time: Optional[str] = None,
        os_patching_errors: Optional[list["_models.ErrorResponse"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OutboundRuleBasicResource(ProxyResource):
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Outbound Rule for the managed network of a machine learning workspace.
     Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.OutboundRule
    """

    properties: "_models.OutboundRule" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Outbound Rule for the managed network of a machine learning workspace. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.OutboundRule",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OutputPathAssetReference(AssetReferenceBase, discriminator="OutputPath"):
    """Reference to an asset via its path in a job output.

    :ivar job_id: ARM resource ID of the job.
    :vartype job_id: str
    :ivar path: The path of the file/directory in the job output.
    :vartype path: str
    :ivar reference_type: [Required] Specifies the type of asset reference. Required.
    :vartype reference_type: str or ~azure.mgmt.machinelearningservices.models.OUTPUT_PATH
    """

    job_id: Optional[str] = rest_field(name="jobId", visibility=["read", "create", "update", "delete", "query"])
    """ARM resource ID of the job."""
    path: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The path of the file/directory in the job output."""
    reference_type: Literal[ReferenceType.OUTPUT_PATH] = rest_discriminator(name="referenceType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of asset reference. Required."""

    @overload
    def __init__(
        self,
        *,
        job_id: Optional[str] = None,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.reference_type = ReferenceType.OUTPUT_PATH  # type: ignore


class PackageDetails(_Model):
    """PackageDetails.

    :ivar install_path: Install path.
    :vartype install_path: str
    :ivar installed_version: Installed version.
    :vartype installed_version: str
    :ivar name: Package or dependency name.
    :vartype name: str
    :ivar patched_version: Patched version.
    :vartype patched_version: str
    """

    install_path: Optional[str] = rest_field(
        name="installPath", visibility=["read", "create", "update", "delete", "query"]
    )
    """Install path."""
    installed_version: Optional[str] = rest_field(
        name="installedVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Installed version."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Package or dependency name."""
    patched_version: Optional[str] = rest_field(
        name="patchedVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Patched version."""

    @overload
    def __init__(
        self,
        *,
        install_path: Optional[str] = None,
        installed_version: Optional[str] = None,
        name: Optional[str] = None,
        patched_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialBatchDeployment(_Model):
    """Mutable batch inference settings per deployment.

    :ivar description: Description of the endpoint deployment.
    :vartype description: str
    """

    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the endpoint deployment."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties(_Model):  # pylint: disable=name-too-long
    """Strictly used in update requests.

    :ivar properties: Additional attributes of the entity.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.PartialBatchDeployment
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    properties: Optional["_models.PartialBatchDeployment"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Additional attributes of the entity."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.PartialBatchDeployment"] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialManagedServiceIdentity(_Model):
    """Managed service identity (system assigned and/or user assigned identities).

    :ivar type: Managed service identity (system assigned and/or user assigned identities). Known
     values are: "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentityType
    :ivar user_assigned_identities: The set of user assigned identities associated with the
     resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
     The dictionary values can be empty objects ({}) in requests.
    :vartype user_assigned_identities: dict[str, any]
    """

    type: Optional[Union[str, "_models.ManagedServiceIdentityType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities). Known values are:
     \"None\", \"SystemAssigned\", \"UserAssigned\", and \"SystemAssigned,UserAssigned\"."""
    user_assigned_identities: Optional[dict[str, Any]] = rest_field(
        name="userAssignedIdentities", visibility=["read", "create", "update", "delete", "query"]
    )
    """The set of user assigned identities associated with the resource. The userAssignedIdentities
     dictionary keys will be ARM resource ids in the form:
     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
     The dictionary values can be empty objects ({}) in requests."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.ManagedServiceIdentityType"]] = None,
        user_assigned_identities: Optional[dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResource(_Model):
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResourceWithIdentity(PartialMinimalTrackedResource):  # pylint: disable=name-too-long
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.PartialManagedServiceIdentity
    """

    identity: Optional["_models.PartialManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.PartialManagedServiceIdentity"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResourceWithSku(PartialMinimalTrackedResource):
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.PartialSku
    """

    sku: Optional["_models.PartialSku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[dict[str, str]] = None,
        sku: Optional["_models.PartialSku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialMinimalTrackedResourceWithSkuAndIdentity(PartialMinimalTrackedResource):  # pylint: disable=name-too-long
    """Strictly used in update requests.

    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.PartialManagedServiceIdentity
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.PartialSku
    """

    identity: Optional["_models.PartialManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    sku: Optional["_models.PartialSku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.PartialManagedServiceIdentity"] = None,
        sku: Optional["_models.PartialSku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialRegistryPartialTrackedResource(_Model):
    """Strictly used in update requests.

    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity:
     ~azure.mgmt.machinelearningservices.models.RegistryPartialManagedServiceIdentity
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.PartialSku
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    identity: Optional["_models.RegistryPartialManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    sku: Optional["_models.PartialSku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource tags."""

    @overload
    def __init__(
        self,
        *,
        identity: Optional["_models.RegistryPartialManagedServiceIdentity"] = None,
        sku: Optional["_models.PartialSku"] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PartialSku(_Model):
    """Common SKU definition.

    :ivar capacity: If the SKU supports scale out/in then the capacity integer should be included.
     If scale out/in is not possible for the resource this may be omitted.
    :vartype capacity: int
    :ivar family: If the service has different generations of hardware, for the same SKU, then that
     can be captured here.
    :vartype family: str
    :ivar name: The name of the SKU. Ex - P3. It is typically a letter+number code.
    :vartype name: str
    :ivar size: The SKU size. When the name field is the combination of tier and some other value,
     this would be the standalone code.
    :vartype size: str
    :ivar tier: This field is required to be implemented by the Resource Provider if the service
     has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
     "Standard", and "Premium".
    :vartype tier: str or ~azure.mgmt.machinelearningservices.models.SkuTier
    """

    capacity: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If the SKU supports scale out/in then the capacity integer should be included. If scale out/in
     is not possible for the resource this may be omitted."""
    family: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If the service has different generations of hardware, for the same SKU, then that can be
     captured here."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the SKU. Ex - P3. It is typically a letter+number code."""
    size: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The SKU size. When the name field is the combination of tier and some other value, this would
     be the standalone code."""
    tier: Optional[Union[str, "_models.SkuTier"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """This field is required to be implemented by the Resource Provider if the service has more than
     one tier, but is not required on a PUT. Known values are: \"Free\", \"Basic\", \"Standard\",
     and \"Premium\"."""

    @overload
    def __init__(
        self,
        *,
        capacity: Optional[int] = None,
        family: Optional[str] = None,
        name: Optional[str] = None,
        size: Optional[str] = None,
        tier: Optional[Union[str, "_models.SkuTier"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Password(_Model):
    """Password.

    :ivar name:
    :vartype name: str
    :ivar value:
    :vartype value: str
    """

    name: Optional[str] = rest_field(visibility=["read"])
    value: Optional[str] = rest_field(visibility=["read"])


class PATAuthTypeWorkspaceConnectionProperties(WorkspaceConnectionPropertiesV2, discriminator="PAT"):
    """PATAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials:
     ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionPersonalAccessToken
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.PAT
    """

    credentials: Optional["_models.WorkspaceConnectionPersonalAccessToken"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.PAT] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionPersonalAccessToken"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.PAT  # type: ignore


class PendingUploadCredentialDto(_Model):
    """PendingUploadCredentialDto.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SASCredentialDto

    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required. "SAS"
    :vartype credential_type: str or
     ~azure.mgmt.machinelearningservices.models.PendingUploadCredentialType
    """

    __mapping__: dict[str, _Model] = {}
    credential_type: str = rest_discriminator(
        name="credentialType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Credential type used to authentication with storage. Required. \"SAS\""""

    @overload
    def __init__(
        self,
        *,
        credential_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PendingUploadRequestDto(_Model):
    """PendingUploadRequestDto.

    :ivar pending_upload_id: If PendingUploadId = null then random guid will be used.
    :vartype pending_upload_id: str
    :ivar pending_upload_type: Type of storage to use for the pending upload location. Known values
     are: "None" and "TemporaryBlobReference".
    :vartype pending_upload_type: str or
     ~azure.mgmt.machinelearningservices.models.PendingUploadType
    """

    pending_upload_id: Optional[str] = rest_field(
        name="pendingUploadId", visibility=["read", "create", "update", "delete", "query"]
    )
    """If PendingUploadId = null then random guid will be used."""
    pending_upload_type: Optional[Union[str, "_models.PendingUploadType"]] = rest_field(
        name="pendingUploadType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of storage to use for the pending upload location. Known values are: \"None\" and
     \"TemporaryBlobReference\"."""

    @overload
    def __init__(
        self,
        *,
        pending_upload_id: Optional[str] = None,
        pending_upload_type: Optional[Union[str, "_models.PendingUploadType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PendingUploadResponseDto(_Model):
    """PendingUploadResponseDto.

    :ivar blob_reference_for_consumption: Container level read, write, list SAS.
    :vartype blob_reference_for_consumption:
     ~azure.mgmt.machinelearningservices.models.BlobReferenceForConsumptionDto
    :ivar pending_upload_id: ID for this upload request.
    :vartype pending_upload_id: str
    :ivar pending_upload_type: Type of storage to use for the pending upload location. Known values
     are: "None" and "TemporaryBlobReference".
    :vartype pending_upload_type: str or
     ~azure.mgmt.machinelearningservices.models.PendingUploadType
    """

    blob_reference_for_consumption: Optional["_models.BlobReferenceForConsumptionDto"] = rest_field(
        name="blobReferenceForConsumption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Container level read, write, list SAS."""
    pending_upload_id: Optional[str] = rest_field(
        name="pendingUploadId", visibility=["read", "create", "update", "delete", "query"]
    )
    """ID for this upload request."""
    pending_upload_type: Optional[Union[str, "_models.PendingUploadType"]] = rest_field(
        name="pendingUploadType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of storage to use for the pending upload location. Known values are: \"None\" and
     \"TemporaryBlobReference\"."""

    @overload
    def __init__(
        self,
        *,
        blob_reference_for_consumption: Optional["_models.BlobReferenceForConsumptionDto"] = None,
        pending_upload_id: Optional[str] = None,
        pending_upload_type: Optional[Union[str, "_models.PendingUploadType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PersonalComputeInstanceSettings(_Model):
    """Settings for a personal compute instance.

    :ivar assigned_user: Assigned User.
    :vartype assigned_user: ~azure.mgmt.machinelearningservices.models.AssignedUser
    """

    assigned_user: Optional["_models.AssignedUser"] = rest_field(
        name="assignedUser", visibility=["read", "create", "update", "delete", "query"]
    )
    """Assigned User."""

    @overload
    def __init__(
        self,
        *,
        assigned_user: Optional["_models.AssignedUser"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PipelineJob(JobBaseProperties, discriminator="Pipeline"):
    """Pipeline Job definition: defines generic to MFE attributes.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar inputs: Inputs for the pipeline job.
    :vartype inputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobInput]
    :ivar jobs: Jobs construct the Pipeline Job.
    :vartype jobs: dict[str, any]
    :ivar outputs: Outputs for the pipeline job.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar settings: Pipeline settings, for things like ContinueRunOnStepFailure etc.
    :vartype settings: dict[str, any]
    :ivar source_job_id: ARM resource ID of source job.
    :vartype source_job_id: str
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.PIPELINE
    """

    inputs: Optional[dict[str, "_models.JobInput"]] = rest_field(visibility=["read", "create"])
    """Inputs for the pipeline job."""
    jobs: Optional[dict[str, Any]] = rest_field(visibility=["read", "create"])
    """Jobs construct the Pipeline Job."""
    outputs: Optional[dict[str, "_models.JobOutput"]] = rest_field(visibility=["read", "create"])
    """Outputs for the pipeline job."""
    settings: Optional[dict[str, Any]] = rest_field(visibility=["read", "create"])
    """Pipeline settings, for things like ContinueRunOnStepFailure etc."""
    source_job_id: Optional[str] = rest_field(name="sourceJobId", visibility=["read", "create"])
    """ARM resource ID of source job."""
    job_type: Literal[JobType.PIPELINE] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        inputs: Optional[dict[str, "_models.JobInput"]] = None,
        jobs: Optional[dict[str, Any]] = None,
        outputs: Optional[dict[str, "_models.JobOutput"]] = None,
        settings: Optional[dict[str, Any]] = None,
        source_job_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.PIPELINE  # type: ignore


class PredictionDriftMonitoringSignal(MonitoringSignalBase, discriminator="PredictionDrift"):
    """PredictionDriftMonitoringSignal.

    :ivar notification_types: The current notification mode for this signal.
    :vartype notification_types: list[str or
     ~azure.mgmt.machinelearningservices.models.MonitoringNotificationType]
    :ivar properties: Property dictionary. Properties can be added, but not removed or altered.
    :vartype properties: dict[str, str]
    :ivar feature_data_type_override: A dictionary that maps feature names to their respective data
     types.
    :vartype feature_data_type_override: dict[str, str or
     ~azure.mgmt.machinelearningservices.models.MonitoringFeatureDataType]
    :ivar metric_thresholds: [Required] A list of metrics to calculate and their associated
     thresholds. Required.
    :vartype metric_thresholds:
     list[~azure.mgmt.machinelearningservices.models.PredictionDriftMetricThresholdBase]
    :ivar production_data: [Required] The data which drift will be calculated for. Required.
    :vartype production_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar reference_data: [Required] The data to calculate drift against. Required.
    :vartype reference_data: ~azure.mgmt.machinelearningservices.models.MonitoringInputDataBase
    :ivar signal_type: [Required] Specifies the type of signal to monitor. Required. Tracks
     prediction result data distribution change, comparing against validation/test label data or
     past production data.
    :vartype signal_type: str or ~azure.mgmt.machinelearningservices.models.PREDICTION_DRIFT
    """

    feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = rest_field(
        name="featureDataTypeOverride", visibility=["read", "create"]
    )
    """A dictionary that maps feature names to their respective data types."""
    metric_thresholds: list["_models.PredictionDriftMetricThresholdBase"] = rest_field(
        name="metricThresholds", visibility=["read", "create"]
    )
    """[Required] A list of metrics to calculate and their associated thresholds. Required."""
    production_data: "_models.MonitoringInputDataBase" = rest_field(
        name="productionData", visibility=["read", "create"]
    )
    """[Required] The data which drift will be calculated for. Required."""
    reference_data: "_models.MonitoringInputDataBase" = rest_field(name="referenceData", visibility=["read", "create"])
    """[Required] The data to calculate drift against. Required."""
    signal_type: Literal[MonitoringSignalType.PREDICTION_DRIFT] = rest_discriminator(name="signalType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. Tracks prediction result data
     distribution change, comparing against validation/test label data or past production data."""

    @overload
    def __init__(
        self,
        *,
        metric_thresholds: list["_models.PredictionDriftMetricThresholdBase"],
        production_data: "_models.MonitoringInputDataBase",
        reference_data: "_models.MonitoringInputDataBase",
        notification_types: Optional[list[Union[str, "_models.MonitoringNotificationType"]]] = None,
        properties: Optional[dict[str, str]] = None,
        feature_data_type_override: Optional[dict[str, Union[str, "_models.MonitoringFeatureDataType"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.signal_type = MonitoringSignalType.PREDICTION_DRIFT  # type: ignore


class PrivateEndpoint(_Model):
    """The private endpoint resource.

    :ivar id: The resource identifier of the private endpoint.
    :vartype id: str
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """The resource identifier of the private endpoint."""


class PrivateEndpointConnection(ProxyResource):
    """The Private Endpoint Connection resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Private endpoint connection properties.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.PrivateEndpointConnectionProperties
    :ivar identity: The managed service identities assigned to this resource.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar sku: Optional. This field is required to be implemented by the RP because AML is
     supporting more than one tier.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    :ivar location: *Same as workspace location.
    :vartype location: str
    :ivar tags:
    :vartype tags: dict[str, str]
    """

    properties: Optional["_models.PrivateEndpointConnectionProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Private endpoint connection properties."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The managed service identities assigned to this resource."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional. This field is required to be implemented by the RP because AML is supporting more
     than one tier."""
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """*Same as workspace location."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    __flattened_items = ["private_endpoint", "private_link_service_connection_state", "provisioning_state"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.PrivateEndpointConnectionProperties"] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        sku: Optional["_models.Sku"] = None,
        location: Optional[str] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class PrivateEndpointConnectionProperties(_Model):
    """Private endpoint connection properties.

    :ivar private_endpoint:
    :vartype private_endpoint:
     ~azure.mgmt.machinelearningservices.models.WorkspacePrivateEndpointResource
    :ivar private_link_service_connection_state: The connection state.
    :vartype private_link_service_connection_state:
     ~azure.mgmt.machinelearningservices.models.PrivateLinkServiceConnectionState
    :ivar provisioning_state: The current provisioning state. Known values are: "Succeeded",
     "Creating", "Deleting", and "Failed".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.PrivateEndpointConnectionProvisioningState
    """

    private_endpoint: Optional["_models.WorkspacePrivateEndpointResource"] = rest_field(
        name="privateEndpoint", visibility=["read", "create", "update", "delete", "query"]
    )
    private_link_service_connection_state: Optional["_models.PrivateLinkServiceConnectionState"] = rest_field(
        name="privateLinkServiceConnectionState", visibility=["read", "create", "update", "delete", "query"]
    )
    """The connection state."""
    provisioning_state: Optional[Union[str, "_models.PrivateEndpointConnectionProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current provisioning state. Known values are: \"Succeeded\", \"Creating\", \"Deleting\",
     and \"Failed\"."""

    @overload
    def __init__(
        self,
        *,
        private_endpoint: Optional["_models.WorkspacePrivateEndpointResource"] = None,
        private_link_service_connection_state: Optional["_models.PrivateLinkServiceConnectionState"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateEndpointDestination(_Model):
    """Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a
    machine learning workspace.

    :ivar service_resource_id:
    :vartype service_resource_id: str
    :ivar spark_enabled:
    :vartype spark_enabled: bool
    :ivar spark_status: Type of a managed network Outbound Rule of a machine learning workspace.
     Known values are: "Inactive", "Active", "Provisioning", "Deleting", and "Failed".
    :vartype spark_status: str or ~azure.mgmt.machinelearningservices.models.RuleStatus
    :ivar subresource_target:
    :vartype subresource_target: str
    """

    service_resource_id: Optional[str] = rest_field(
        name="serviceResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    spark_enabled: Optional[bool] = rest_field(
        name="sparkEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    spark_status: Optional[Union[str, "_models.RuleStatus"]] = rest_field(
        name="sparkStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of a managed network Outbound Rule of a machine learning workspace. Known values are:
     \"Inactive\", \"Active\", \"Provisioning\", \"Deleting\", and \"Failed\"."""
    subresource_target: Optional[str] = rest_field(
        name="subresourceTarget", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        service_resource_id: Optional[str] = None,
        spark_enabled: Optional[bool] = None,
        spark_status: Optional[Union[str, "_models.RuleStatus"]] = None,
        subresource_target: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateEndpointOutboundRule(OutboundRule, discriminator="PrivateEndpoint"):
    """Private Endpoint Outbound Rule for the managed network of a machine learning workspace.

    :ivar category: Category of a managed network Outbound Rule of a machine learning workspace.
     Known values are: "Required", "Recommended", "UserDefined", and "Dependency".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.RuleCategory
    :ivar status: Type of a managed network Outbound Rule of a machine learning workspace. Known
     values are: "Inactive", "Active", "Provisioning", "Deleting", and "Failed".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.RuleStatus
    :ivar error_information: Error information about an outbound rule of a machine learning
     workspace if RuleStatus is failed.
    :vartype error_information: str
    :ivar parent_rule_names:
    :vartype parent_rule_names: list[str]
    :ivar destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the
     managed network of a machine learning workspace.
    :vartype destination: ~azure.mgmt.machinelearningservices.models.PrivateEndpointDestination
    :ivar fqdns:
    :vartype fqdns: list[str]
    :ivar type: Type of a managed network Outbound Rule of a machine learning workspace. Required.
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.PRIVATE_ENDPOINT
    """

    destination: Optional["_models.PrivateEndpointDestination"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a
     machine learning workspace."""
    fqdns: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    type: Literal[RuleType.PRIVATE_ENDPOINT] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of a managed network Outbound Rule of a machine learning workspace. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.RuleCategory"]] = None,
        status: Optional[Union[str, "_models.RuleStatus"]] = None,
        destination: Optional["_models.PrivateEndpointDestination"] = None,
        fqdns: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = RuleType.PRIVATE_ENDPOINT  # type: ignore


class PrivateEndpointResource(PrivateEndpoint):
    """The PE network resource that is linked to this PE connection.

    :ivar id: The resource identifier of the private endpoint.
    :vartype id: str
    :ivar subnet_arm_id: The subnetId that the private endpoint is connected to.
    :vartype subnet_arm_id: str
    """

    subnet_arm_id: Optional[str] = rest_field(
        name="subnetArmId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The subnetId that the private endpoint is connected to."""

    @overload
    def __init__(
        self,
        *,
        subnet_arm_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateLinkResource(Resource):
    """A private link resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar identity:
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar location: Same as workspace location.
    :vartype location: str
    :ivar properties: Properties of a private link resource.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.PrivateLinkResourceProperties
    :ivar sku: Optional. This field is required to be implemented by the RP because AML is
     supporting more than one tier.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    :ivar tags:
    :vartype tags: dict[str, str]
    """

    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Same as workspace location."""
    properties: Optional["_models.PrivateLinkResourceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a private link resource."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional. This field is required to be implemented by the RP because AML is supporting more
     than one tier."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    __flattened_items = ["group_id", "required_members", "required_zone_names"]

    @overload
    def __init__(
        self,
        *,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        location: Optional[str] = None,
        properties: Optional["_models.PrivateLinkResourceProperties"] = None,
        sku: Optional["_models.Sku"] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class PrivateLinkResourceProperties(_Model):
    """Properties of a private link resource.

    :ivar group_id: The private link resource group id.
    :vartype group_id: str
    :ivar required_members: The private link resource required member names.
    :vartype required_members: list[str]
    :ivar required_zone_names: The private link resource Private link DNS zone name.
    :vartype required_zone_names: list[str]
    """

    group_id: Optional[str] = rest_field(name="groupId", visibility=["read", "create", "update", "delete", "query"])
    """The private link resource group id."""
    required_members: Optional[list[str]] = rest_field(
        name="requiredMembers", visibility=["read", "create", "update", "delete", "query"]
    )
    """The private link resource required member names."""
    required_zone_names: Optional[list[str]] = rest_field(
        name="requiredZoneNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """The private link resource Private link DNS zone name."""

    @overload
    def __init__(
        self,
        *,
        group_id: Optional[str] = None,
        required_members: Optional[list[str]] = None,
        required_zone_names: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrivateLinkServiceConnectionState(_Model):
    """A collection of information about the state of the connection between service consumer and
    provider.

    :ivar actions_required: Some RP chose "None". Other RPs use this for region expansion.
    :vartype actions_required: str
    :ivar description: User-defined message that, per NRP doc, may be used for approval-related
     message.
    :vartype description: str
    :ivar status: Connection status of the service consumer with the service provider\\r\\nPossible
     state transitions\\r\\nPending -> Approved (Service provider approves the connection
     request)\\r\\nPending -> Rejected (Service provider rejects the connection
     request)\\r\\nPending -> Disconnected (Service provider deletes the connection)\\r\\nApproved
     -> Rejected (Service provider rejects the approved connection)\\r\\nApproved -> Disconnected
     (Service provider deletes the connection)\\r\\nRejected -> Pending (Service consumer
     re-initiates the connection request that was rejected)\\r\\nRejected -> Disconnected (Service
     provider deletes the connection). Known values are: "Approved", "Pending", "Rejected",
     "Disconnected", and "Timeout".
    :vartype status: str or
     ~azure.mgmt.machinelearningservices.models.EndpointServiceConnectionStatus
    """

    actions_required: Optional[str] = rest_field(
        name="actionsRequired", visibility=["read", "create", "update", "delete", "query"]
    )
    """Some RP chose \"None\". Other RPs use this for region expansion."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """User-defined message that, per NRP doc, may be used for approval-related message."""
    status: Optional[Union[str, "_models.EndpointServiceConnectionStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Connection status of the service consumer with the service provider\r\nPossible state
     transitions\r\nPending -> Approved (Service provider approves the connection
     request)\r\nPending -> Rejected (Service provider rejects the connection request)\r\nPending ->
     Disconnected (Service provider deletes the connection)\r\nApproved -> Rejected (Service
     provider rejects the approved connection)\r\nApproved -> Disconnected (Service provider deletes
     the connection)\r\nRejected -> Pending (Service consumer re-initiates the connection request
     that was rejected)\r\nRejected -> Disconnected (Service provider deletes the connection). Known
     values are: \"Approved\", \"Pending\", \"Rejected\", \"Disconnected\", and \"Timeout\"."""

    @overload
    def __init__(
        self,
        *,
        actions_required: Optional[str] = None,
        description: Optional[str] = None,
        status: Optional[Union[str, "_models.EndpointServiceConnectionStatus"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProbeSettings(_Model):
    """Deployment container liveness/readiness probe configuration.

    :ivar failure_threshold: The number of failures to allow before returning an unhealthy status.
    :vartype failure_threshold: int
    :ivar initial_delay: The delay before the first probe in ISO 8601 format.
    :vartype initial_delay: ~datetime.timedelta
    :ivar period: The length of time between probes in ISO 8601 format.
    :vartype period: ~datetime.timedelta
    :ivar success_threshold: The number of successful probes before returning a healthy status.
    :vartype success_threshold: int
    :ivar timeout: The probe timeout in ISO 8601 format.
    :vartype timeout: ~datetime.timedelta
    """

    failure_threshold: Optional[int] = rest_field(
        name="failureThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of failures to allow before returning an unhealthy status."""
    initial_delay: Optional[datetime.timedelta] = rest_field(
        name="initialDelay", visibility=["read", "create", "update", "delete", "query"]
    )
    """The delay before the first probe in ISO 8601 format."""
    period: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The length of time between probes in ISO 8601 format."""
    success_threshold: Optional[int] = rest_field(
        name="successThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of successful probes before returning a healthy status."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The probe timeout in ISO 8601 format."""

    @overload
    def __init__(
        self,
        *,
        failure_threshold: Optional[int] = None,
        initial_delay: Optional[datetime.timedelta] = None,
        period: Optional[datetime.timedelta] = None,
        success_threshold: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PromptSettings(_Model):
    """PromptSettings.

    :ivar enable_chain_of_density:
    :vartype enable_chain_of_density: bool
    :ivar enable_chain_of_thought:
    :vartype enable_chain_of_thought: bool
    :ivar max_len_summary:
    :vartype max_len_summary: int
    """

    enable_chain_of_density: Optional[bool] = rest_field(
        name="enableChainOfDensity", visibility=["read", "create", "update", "delete", "query"]
    )
    enable_chain_of_thought: Optional[bool] = rest_field(
        name="enableChainOfThought", visibility=["read", "create", "update", "delete", "query"]
    )
    max_len_summary: Optional[int] = rest_field(
        name="maxLenSummary", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        enable_chain_of_density: Optional[bool] = None,
        enable_chain_of_thought: Optional[bool] = None,
        max_len_summary: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PTUDeploymentUsage(_Model):
    """PTUDeploymentUsage.

    :ivar collection_quota_usage: Usage number from the collection level quota.
    :vartype collection_quota_usage: int
    :ivar deployment_name: Deployment name.
    :vartype deployment_name: str
    :ivar resource_group: Resource group name.
    :vartype resource_group: str
    :ivar usage: Usage number from subscription level quota.
    :vartype usage: int
    :ivar workspace_name: Workspace name.
    :vartype workspace_name: str
    """

    collection_quota_usage: Optional[int] = rest_field(
        name="collectionQuotaUsage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Usage number from the collection level quota."""
    deployment_name: Optional[str] = rest_field(
        name="deploymentName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Deployment name."""
    resource_group: Optional[str] = rest_field(
        name="resourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource group name."""
    usage: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Usage number from subscription level quota."""
    workspace_name: Optional[str] = rest_field(
        name="workspaceName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Workspace name."""

    @overload
    def __init__(
        self,
        *,
        collection_quota_usage: Optional[int] = None,
        deployment_name: Optional[str] = None,
        resource_group: Optional[str] = None,
        usage: Optional[int] = None,
        workspace_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PyTorch(DistributionConfiguration, discriminator="PyTorch"):
    """PyTorch distribution configuration.

    :ivar process_count_per_instance: Number of processes per node.
    :vartype process_count_per_instance: int
    :ivar distribution_type: [Required] Specifies the type of distribution framework. Required.
    :vartype distribution_type: str or ~azure.mgmt.machinelearningservices.models.PY_TORCH
    """

    process_count_per_instance: Optional[int] = rest_field(
        name="processCountPerInstance", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of processes per node."""
    distribution_type: Literal[DistributionType.PY_TORCH] = rest_discriminator(name="distributionType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of distribution framework. Required."""

    @overload
    def __init__(
        self,
        *,
        process_count_per_instance: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.distribution_type = DistributionType.PY_TORCH  # type: ignore


class QueueSettings(_Model):
    """QueueSettings.

    :ivar job_tier: Enum to determine the job tier. Known values are: "Null", "Spot", "Basic",
     "Standard", and "Premium".
    :vartype job_tier: str or ~azure.mgmt.machinelearningservices.models.JobTier
    """

    job_tier: Optional[Union[str, "_models.JobTier"]] = rest_field(name="jobTier", visibility=["read", "create"])
    """Enum to determine the job tier. Known values are: \"Null\", \"Spot\", \"Basic\", \"Standard\",
     and \"Premium\"."""

    @overload
    def __init__(
        self,
        *,
        job_tier: Optional[Union[str, "_models.JobTier"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QuotaBaseProperties(_Model):
    """The properties for Quota update or retrieval.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :ivar limit: Limit.
    :vartype limit: int
    :ivar unit: An enum describing the unit of quota measurement. "Count"
    :vartype unit: str or ~azure.mgmt.machinelearningservices.models.QuotaUnit
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the resource ID."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Specifies the resource type."""
    limit: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Limit."""
    unit: Optional[Union[str, "_models.QuotaUnit"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """An enum describing the unit of quota measurement. \"Count\""""

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        type: Optional[str] = None,
        limit: Optional[int] = None,
        unit: Optional[Union[str, "_models.QuotaUnit"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QuotaUpdateParameters(_Model):
    """Quota update parameters.

    :ivar value: The list for update quota.
    :vartype value: list[~azure.mgmt.machinelearningservices.models.QuotaBaseProperties]
    :ivar location: Region of workspace quota to be updated.
    :vartype location: str
    """

    value: Optional[list["_models.QuotaBaseProperties"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The list for update quota."""
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Region of workspace quota to be updated."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[list["_models.QuotaBaseProperties"]] = None,
        location: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiBlocklistConfig(_Model):
    """Azure OpenAI blocklist config.

    :ivar blocking: If blocking would occur.
    :vartype blocking: bool
    :ivar blocklist_name: Name of ContentFilter.
    :vartype blocklist_name: str
    """

    blocking: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If blocking would occur."""
    blocklist_name: Optional[str] = rest_field(
        name="blocklistName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of ContentFilter."""

    @overload
    def __init__(
        self,
        *,
        blocking: Optional[bool] = None,
        blocklist_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiBlocklistItemBulkRequest(_Model):
    """The Cognitive Services RaiBlocklist Item request body.

    :ivar name:
    :vartype name: str
    :ivar properties: Properties of Cognitive Services RaiBlocklist Item.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.RaiBlocklistItemProperties
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    properties: Optional["_models.RaiBlocklistItemProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of Cognitive Services RaiBlocklist Item."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        properties: Optional["_models.RaiBlocklistItemProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiBlocklistItemProperties(_Model):
    """RAI Custom Blocklist Item properties.

    :ivar is_regex: If the pattern is a regex pattern.
    :vartype is_regex: bool
    :ivar pattern: Pattern to match against.
    :vartype pattern: str
    """

    is_regex: Optional[bool] = rest_field(name="isRegex", visibility=["read", "create", "update", "delete", "query"])
    """If the pattern is a regex pattern."""
    pattern: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Pattern to match against."""

    @overload
    def __init__(
        self,
        *,
        is_regex: Optional[bool] = None,
        pattern: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiBlocklistItemPropertiesBasicResource(ProxyResource):
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: RAI Custom Blocklist Item properties. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.RaiBlocklistItemProperties
    """

    properties: "_models.RaiBlocklistItemProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """RAI Custom Blocklist Item properties. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.RaiBlocklistItemProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiBlocklistProperties(_Model):
    """RAI Custom Blocklist properties.

    :ivar description: Description of the block list.
    :vartype description: str
    """

    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of the block list."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiBlocklistPropertiesBasicResource(ProxyResource):
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: RAI Custom Blocklist properties. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.RaiBlocklistProperties
    """

    properties: "_models.RaiBlocklistProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """RAI Custom Blocklist properties. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.RaiBlocklistProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiPolicyContentFilter(_Model):
    """Azure OpenAI Content Filter.

    :ivar allowed_content_level: Level at which content is filtered. Known values are: "Low",
     "Medium", and "High".
    :vartype allowed_content_level: str or
     ~azure.mgmt.machinelearningservices.models.AllowedContentLevel
    :ivar blocking: If blocking would occur.
    :vartype blocking: bool
    :ivar enabled: If the ContentFilter is enabled.
    :vartype enabled: bool
    :ivar name: Name of ContentFilter.
    :vartype name: str
    :ivar source: Content source to apply the Content Filters. Known values are: "Prompt" and
     "Completion".
    :vartype source: str or ~azure.mgmt.machinelearningservices.models.RaiPolicyContentSource
    """

    allowed_content_level: Optional[Union[str, "_models.AllowedContentLevel"]] = rest_field(
        name="allowedContentLevel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Level at which content is filtered. Known values are: \"Low\", \"Medium\", and \"High\"."""
    blocking: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If blocking would occur."""
    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If the ContentFilter is enabled."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Name of ContentFilter."""
    source: Optional[Union[str, "_models.RaiPolicyContentSource"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Content source to apply the Content Filters. Known values are: \"Prompt\" and \"Completion\"."""

    @overload
    def __init__(
        self,
        *,
        allowed_content_level: Optional[Union[str, "_models.AllowedContentLevel"]] = None,
        blocking: Optional[bool] = None,
        enabled: Optional[bool] = None,
        name: Optional[str] = None,
        source: Optional[Union[str, "_models.RaiPolicyContentSource"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiPolicyProperties(_Model):
    """Azure OpenAI Content Filters properties.

    :ivar base_policy_name: Name of the base Content Filters.
    :vartype base_policy_name: str
    :ivar completion_blocklists:
    :vartype completion_blocklists:
     list[~azure.mgmt.machinelearningservices.models.RaiBlocklistConfig]
    :ivar content_filters:
    :vartype content_filters:
     list[~azure.mgmt.machinelearningservices.models.RaiPolicyContentFilter]
    :ivar mode: Content Filters mode. Known values are: "Default", "Deferred", and "Blocking".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.RaiPolicyMode
    :ivar prompt_blocklists:
    :vartype prompt_blocklists: list[~azure.mgmt.machinelearningservices.models.RaiBlocklistConfig]
    :ivar type: Content Filters policy type. Known values are: "UserManaged" and "SystemManaged".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.RaiPolicyType
    """

    base_policy_name: Optional[str] = rest_field(
        name="basePolicyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the base Content Filters."""
    completion_blocklists: Optional[list["_models.RaiBlocklistConfig"]] = rest_field(
        name="completionBlocklists", visibility=["read", "create", "update", "delete", "query"]
    )
    content_filters: Optional[list["_models.RaiPolicyContentFilter"]] = rest_field(
        name="contentFilters", visibility=["read", "create", "update", "delete", "query"]
    )
    mode: Optional[Union[str, "_models.RaiPolicyMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Content Filters mode. Known values are: \"Default\", \"Deferred\", and \"Blocking\"."""
    prompt_blocklists: Optional[list["_models.RaiBlocklistConfig"]] = rest_field(
        name="promptBlocklists", visibility=["read", "create", "update", "delete", "query"]
    )
    type: Optional[Union[str, "_models.RaiPolicyType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Content Filters policy type. Known values are: \"UserManaged\" and \"SystemManaged\"."""

    @overload
    def __init__(
        self,
        *,
        base_policy_name: Optional[str] = None,
        completion_blocklists: Optional[list["_models.RaiBlocklistConfig"]] = None,
        content_filters: Optional[list["_models.RaiPolicyContentFilter"]] = None,
        mode: Optional[Union[str, "_models.RaiPolicyMode"]] = None,
        prompt_blocklists: Optional[list["_models.RaiBlocklistConfig"]] = None,
        type: Optional[Union[str, "_models.RaiPolicyType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RaiPolicyPropertiesBasicResource(ProxyResource):
    """Azure OpenAI Content Filters resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Azure OpenAI Content Filters properties. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.RaiPolicyProperties
    """

    properties: "_models.RaiPolicyProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Azure OpenAI Content Filters properties. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.RaiPolicyProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RandomSamplingAlgorithm(SamplingAlgorithm, discriminator="Random"):
    """Defines a Sampling Algorithm that generates values randomly.

    :ivar rule: The specific type of random algorithm. Known values are: "Random" and "Sobol".
    :vartype rule: str or ~azure.mgmt.machinelearningservices.models.RandomSamplingAlgorithmRule
    :ivar seed: An optional integer to use as the seed for random number generation.
    :vartype seed: int
    :ivar sampling_algorithm_type: [Required] The algorithm used for generating hyperparameter
     values, along with configuration properties. Required.
    :vartype sampling_algorithm_type: str or ~azure.mgmt.machinelearningservices.models.RANDOM
    """

    rule: Optional[Union[str, "_models.RandomSamplingAlgorithmRule"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The specific type of random algorithm. Known values are: \"Random\" and \"Sobol\"."""
    seed: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """An optional integer to use as the seed for random number generation."""
    sampling_algorithm_type: Literal[SamplingAlgorithmType.RANDOM] = rest_discriminator(name="samplingAlgorithmType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] The algorithm used for generating hyperparameter values, along with configuration
     properties. Required."""

    @overload
    def __init__(
        self,
        *,
        rule: Optional[Union[str, "_models.RandomSamplingAlgorithmRule"]] = None,
        seed: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.sampling_algorithm_type = SamplingAlgorithmType.RANDOM  # type: ignore


class Recurrence(_Model):
    """The workflow trigger recurrence for ComputeStartStop schedule type.

    :ivar frequency: [Required] The frequency to trigger schedule. Known values are: "Minute",
     "Hour", "Day", "Week", and "Month".
    :vartype frequency: str or
     ~azure.mgmt.machinelearningservices.models.ComputeRecurrenceFrequency
    :ivar interval: [Required] Specifies schedule interval in conjunction with frequency.
    :vartype interval: int
    :ivar start_time: The start time in yyyy-MM-ddTHH:mm:ss format.
    :vartype start_time: str
    :ivar time_zone: Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_.
    :vartype time_zone: str
    :ivar schedule: [Required] The recurrence schedule.
    :vartype schedule: ~azure.mgmt.machinelearningservices.models.ComputeRecurrenceSchedule
    """

    frequency: Optional[Union[str, "_models.ComputeRecurrenceFrequency"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The frequency to trigger schedule. Known values are: \"Minute\", \"Hour\", \"Day\",
     \"Week\", and \"Month\"."""
    interval: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Specifies schedule interval in conjunction with frequency."""
    start_time: Optional[str] = rest_field(name="startTime", visibility=["read", "create", "update", "delete", "query"])
    """The start time in yyyy-MM-ddTHH:mm:ss format."""
    time_zone: Optional[str] = rest_field(name="timeZone", visibility=["read", "create", "update", "delete", "query"])
    """Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_."""
    schedule: Optional["_models.ComputeRecurrenceSchedule"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The recurrence schedule."""

    @overload
    def __init__(
        self,
        *,
        frequency: Optional[Union[str, "_models.ComputeRecurrenceFrequency"]] = None,
        interval: Optional[int] = None,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
        schedule: Optional["_models.ComputeRecurrenceSchedule"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RecurrenceSchedule(_Model):
    """RecurrenceSchedule.

    :ivar hours: [Required] List of hours for the schedule. Required.
    :vartype hours: list[int]
    :ivar minutes: [Required] List of minutes for the schedule. Required.
    :vartype minutes: list[int]
    :ivar month_days: List of month days for the schedule.
    :vartype month_days: list[int]
    :ivar week_days: List of days for the schedule.
    :vartype week_days: list[str or ~azure.mgmt.machinelearningservices.models.WeekDay]
    """

    hours: list[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] List of hours for the schedule. Required."""
    minutes: list[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] List of minutes for the schedule. Required."""
    month_days: Optional[list[int]] = rest_field(
        name="monthDays", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of month days for the schedule."""
    week_days: Optional[list[Union[str, "_models.WeekDay"]]] = rest_field(
        name="weekDays", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of days for the schedule."""

    @overload
    def __init__(
        self,
        *,
        hours: list[int],
        minutes: list[int],
        month_days: Optional[list[int]] = None,
        week_days: Optional[list[Union[str, "_models.WeekDay"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RecurrenceTrigger(TriggerBase, discriminator="Recurrence"):
    """RecurrenceTrigger.

    :ivar end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer
     `https://en.wikipedia.org/wiki/ISO_8601 <https://en.wikipedia.org/wiki/ISO_8601>`_.
     Recommented format would be "2022-06-01T00:00:01"
     If not present, the schedule will run indefinitely.
    :vartype end_time: str
    :ivar start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC
     offset.
    :vartype start_time: str
    :ivar time_zone: Specifies time zone in which the schedule runs.
     TimeZone should follow Windows time zone format. Refer:
     `https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
     <https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11>`_.
    :vartype time_zone: str
    :ivar frequency: [Required] The frequency to trigger schedule. Required. Known values are:
     "Minute", "Hour", "Day", "Week", and "Month".
    :vartype frequency: str or ~azure.mgmt.machinelearningservices.models.RecurrenceFrequency
    :ivar interval: [Required] Specifies schedule interval in conjunction with frequency. Required.
    :vartype interval: int
    :ivar schedule: The recurrence schedule.
    :vartype schedule: ~azure.mgmt.machinelearningservices.models.RecurrenceSchedule
    :ivar trigger_type: [Required]. Required.
    :vartype trigger_type: str or ~azure.mgmt.machinelearningservices.models.RECURRENCE
    """

    frequency: Union[str, "_models.RecurrenceFrequency"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The frequency to trigger schedule. Required. Known values are: \"Minute\", \"Hour\",
     \"Day\", \"Week\", and \"Month\"."""
    interval: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Specifies schedule interval in conjunction with frequency. Required."""
    schedule: Optional["_models.RecurrenceSchedule"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The recurrence schedule."""
    trigger_type: Literal[TriggerType.RECURRENCE] = rest_discriminator(name="triggerType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required]. Required."""

    @overload
    def __init__(
        self,
        *,
        frequency: Union[str, "_models.RecurrenceFrequency"],
        interval: int,
        end_time: Optional[str] = None,
        start_time: Optional[str] = None,
        time_zone: Optional[str] = None,
        schedule: Optional["_models.RecurrenceSchedule"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.trigger_type = TriggerType.RECURRENCE  # type: ignore


class RegenerateEndpointKeysRequest(_Model):
    """RegenerateEndpointKeysRequest.

    :ivar key_type: [Required] Specification for which type of key to generate. Primary or
     Secondary. Required. Known values are: "Primary" and "Secondary".
    :vartype key_type: str or ~azure.mgmt.machinelearningservices.models.KeyType
    :ivar key_value: The value the key is set to.
    :vartype key_value: str
    """

    key_type: Union[str, "_models.KeyType"] = rest_field(
        name="keyType", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Specification for which type of key to generate. Primary or Secondary. Required.
     Known values are: \"Primary\" and \"Secondary\"."""
    key_value: Optional[str] = rest_field(name="keyValue", visibility=["read", "create", "update", "delete", "query"])
    """The value the key is set to."""

    @overload
    def __init__(
        self,
        *,
        key_type: Union[str, "_models.KeyType"],
        key_value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegenerateServiceAccountKeyContent(_Model):
    """RegenerateServiceAccountKeyContent.

    :ivar key_name: Known values are: "Key1" and "Key2".
    :vartype key_name: str or ~azure.mgmt.machinelearningservices.models.ServiceAccountKeyName
    """

    key_name: Optional[Union[str, "_models.ServiceAccountKeyName"]] = rest_field(
        name="keyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Known values are: \"Key1\" and \"Key2\"."""

    @overload
    def __init__(
        self,
        *,
        key_name: Optional[Union[str, "_models.ServiceAccountKeyName"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Registry(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.RegistryProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.RegistryProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    __flattened_items = [
        "discovery_url",
        "intellectual_property_publisher",
        "managed_resource_group",
        "managed_resource_group_settings",
        "ml_flow_registry_uri",
        "registry_private_endpoint_connections",
        "public_network_access",
        "region_details",
    ]

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.RegistryProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class RegistryListCredentialsResult(_Model):
    """RegistryListCredentialsResult.

    :ivar location: The location of the workspace ACR.
    :vartype location: str
    :ivar passwords:
    :vartype passwords: list[~azure.mgmt.machinelearningservices.models.Password]
    :ivar username: The username of the workspace ACR.
    :vartype username: str
    """

    location: Optional[str] = rest_field(visibility=["read"])
    """The location of the workspace ACR."""
    passwords: Optional[list["_models.Password"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    username: Optional[str] = rest_field(visibility=["read"])
    """The username of the workspace ACR."""

    @overload
    def __init__(
        self,
        *,
        passwords: Optional[list["_models.Password"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegistryPartialManagedServiceIdentity(ManagedServiceIdentity):
    """Managed service identity (system assigned and/or user assigned identities).

    :ivar principal_id: The service principal ID of the system assigned identity. This property
     will only be provided for a system assigned identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of the system assigned identity. This property will only be
     provided for a system assigned identity.
    :vartype tenant_id: str
    :ivar type: The type of managed identity assigned to this resource. Required. Known values are:
     "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentityType
    :ivar user_assigned_identities: The identities assigned to this resource by the user.
    :vartype user_assigned_identities: dict[str,
     ~azure.mgmt.machinelearningservices.models.UserAssignedIdentity]
    """

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ManagedServiceIdentityType"],
        user_assigned_identities: Optional[dict[str, "_models.UserAssignedIdentity"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegistryPrivateEndpointConnection(_Model):
    """Private endpoint connection definition.

    :ivar id: This is the private endpoint connection name created on SRP
     Full resource id:
     /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}.
    :vartype id: str
    :ivar location: Same as workspace location.
    :vartype location: str
    :ivar properties: Properties of the Private Endpoint Connection.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.RegistryPrivateEndpointConnectionProperties
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """This is the private endpoint connection name created on SRP
     Full resource id:
     /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """Same as workspace location."""
    properties: Optional["_models.RegistryPrivateEndpointConnectionProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of the Private Endpoint Connection."""

    __flattened_items = [
        "group_ids",
        "private_endpoint",
        "registry_private_link_service_connection_state",
        "provisioning_state",
    ]

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        location: Optional[str] = None,
        properties: Optional["_models.RegistryPrivateEndpointConnectionProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class RegistryPrivateEndpointConnectionProperties(_Model):  # pylint: disable=name-too-long
    """Properties of the Private Endpoint Connection.

    :ivar group_ids: The group ids.
    :vartype group_ids: list[str]
    :ivar private_endpoint: The PE network resource that is linked to this PE connection.
    :vartype private_endpoint: ~azure.mgmt.machinelearningservices.models.PrivateEndpointResource
    :ivar registry_private_link_service_connection_state: The connection state.
    :vartype registry_private_link_service_connection_state:
     ~azure.mgmt.machinelearningservices.models.RegistryPrivateLinkServiceConnectionState
    :ivar provisioning_state: One of null, "Succeeded", "Provisioning", "Failed". While not
     approved, it's null.
    :vartype provisioning_state: str
    """

    group_ids: Optional[list[str]] = rest_field(
        name="groupIds", visibility=["read", "create", "update", "delete", "query"]
    )
    """The group ids."""
    private_endpoint: Optional["_models.PrivateEndpointResource"] = rest_field(
        name="privateEndpoint", visibility=["read", "create", "update", "delete", "query"]
    )
    """The PE network resource that is linked to this PE connection."""
    registry_private_link_service_connection_state: Optional["_models.RegistryPrivateLinkServiceConnectionState"] = (
        rest_field(
            name="registryPrivateLinkServiceConnectionState", visibility=["read", "create", "update", "delete", "query"]
        )
    )
    """The connection state."""
    provisioning_state: Optional[str] = rest_field(
        name="provisioningState", visibility=["read", "create", "update", "delete", "query"]
    )
    """One of null, \"Succeeded\", \"Provisioning\", \"Failed\". While not approved, it's null."""

    @overload
    def __init__(
        self,
        *,
        group_ids: Optional[list[str]] = None,
        private_endpoint: Optional["_models.PrivateEndpointResource"] = None,
        registry_private_link_service_connection_state: Optional[
            "_models.RegistryPrivateLinkServiceConnectionState"
        ] = None,
        provisioning_state: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegistryPrivateLinkServiceConnectionState(_Model):  # pylint: disable=name-too-long
    """The connection state.

    :ivar actions_required: Some RP chose "None". Other RPs use this for region expansion.
    :vartype actions_required: str
    :ivar description: User-defined message that, per NRP doc, may be used for approval-related
     message.
    :vartype description: str
    :ivar status: Connection status of the service consumer with the service provider. Known values
     are: "Approved", "Pending", "Rejected", "Disconnected", and "Timeout".
    :vartype status: str or
     ~azure.mgmt.machinelearningservices.models.EndpointServiceConnectionStatus
    """

    actions_required: Optional[str] = rest_field(
        name="actionsRequired", visibility=["read", "create", "update", "delete", "query"]
    )
    """Some RP chose \"None\". Other RPs use this for region expansion."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """User-defined message that, per NRP doc, may be used for approval-related message."""
    status: Optional[Union[str, "_models.EndpointServiceConnectionStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Connection status of the service consumer with the service provider. Known values are:
     \"Approved\", \"Pending\", \"Rejected\", \"Disconnected\", and \"Timeout\"."""

    @overload
    def __init__(
        self,
        *,
        actions_required: Optional[str] = None,
        description: Optional[str] = None,
        status: Optional[Union[str, "_models.EndpointServiceConnectionStatus"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegistryProperties(_Model):
    """Details of the Registry.

    :ivar discovery_url: Discovery URL for the Registry.
    :vartype discovery_url: str
    :ivar intellectual_property_publisher: IntellectualPropertyPublisher for the registry.
    :vartype intellectual_property_publisher: str
    :ivar managed_resource_group: ResourceId of the managed RG if the registry has system created
     resources.
    :vartype managed_resource_group: ~azure.mgmt.machinelearningservices.models.ArmResourceId
    :ivar managed_resource_group_settings: Managed resource group specific settings.
    :vartype managed_resource_group_settings:
     ~azure.mgmt.machinelearningservices.models.ManagedResourceGroupSettings
    :ivar ml_flow_registry_uri: MLFlow Registry URI for the Registry.
    :vartype ml_flow_registry_uri: str
    :ivar registry_private_endpoint_connections: Private endpoint connections info used for pending
     connections in private link portal.
    :vartype registry_private_endpoint_connections:
     list[~azure.mgmt.machinelearningservices.models.RegistryPrivateEndpointConnection]
    :ivar public_network_access: Is the Registry accessible from the internet?
     Possible values: "Enabled" or "Disabled".
    :vartype public_network_access: str
    :ivar region_details: Details of each region the registry is in.
    :vartype region_details:
     list[~azure.mgmt.machinelearningservices.models.RegistryRegionArmDetails]
    """

    discovery_url: Optional[str] = rest_field(
        name="discoveryUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Discovery URL for the Registry."""
    intellectual_property_publisher: Optional[str] = rest_field(
        name="intellectualPropertyPublisher", visibility=["read", "create", "update", "delete", "query"]
    )
    """IntellectualPropertyPublisher for the registry."""
    managed_resource_group: Optional["_models.ArmResourceId"] = rest_field(
        name="managedResourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """ResourceId of the managed RG if the registry has system created resources."""
    managed_resource_group_settings: Optional["_models.ManagedResourceGroupSettings"] = rest_field(
        name="managedResourceGroupSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed resource group specific settings."""
    ml_flow_registry_uri: Optional[str] = rest_field(
        name="mlFlowRegistryUri", visibility=["read", "create", "update", "delete", "query"]
    )
    """MLFlow Registry URI for the Registry."""
    registry_private_endpoint_connections: Optional[list["_models.RegistryPrivateEndpointConnection"]] = rest_field(
        name="registryPrivateEndpointConnections", visibility=["read", "create", "update", "delete", "query"]
    )
    """Private endpoint connections info used for pending connections in private link portal."""
    public_network_access: Optional[str] = rest_field(
        name="publicNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Is the Registry accessible from the internet?
     Possible values: \"Enabled\" or \"Disabled\"."""
    region_details: Optional[list["_models.RegistryRegionArmDetails"]] = rest_field(
        name="regionDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """Details of each region the registry is in."""

    @overload
    def __init__(
        self,
        *,
        discovery_url: Optional[str] = None,
        intellectual_property_publisher: Optional[str] = None,
        managed_resource_group: Optional["_models.ArmResourceId"] = None,
        managed_resource_group_settings: Optional["_models.ManagedResourceGroupSettings"] = None,
        ml_flow_registry_uri: Optional[str] = None,
        registry_private_endpoint_connections: Optional[list["_models.RegistryPrivateEndpointConnection"]] = None,
        public_network_access: Optional[str] = None,
        region_details: Optional[list["_models.RegistryRegionArmDetails"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RegistryRegionArmDetails(_Model):
    """Details for each region the registry is in.

    :ivar acr_details: List of ACR accounts.
    :vartype acr_details: list[~azure.mgmt.machinelearningservices.models.AcrDetails]
    :ivar location: The location where the registry exists.
    :vartype location: str
    :ivar storage_account_details: List of storage accounts.
    :vartype storage_account_details:
     list[~azure.mgmt.machinelearningservices.models.StorageAccountDetails]
    """

    acr_details: Optional[list["_models.AcrDetails"]] = rest_field(
        name="acrDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of ACR accounts."""
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The location where the registry exists."""
    storage_account_details: Optional[list["_models.StorageAccountDetails"]] = rest_field(
        name="storageAccountDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """List of storage accounts."""

    @overload
    def __init__(
        self,
        *,
        acr_details: Optional[list["_models.AcrDetails"]] = None,
        location: Optional[str] = None,
        storage_account_details: Optional[list["_models.StorageAccountDetails"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Regression(AutoMLVertical, discriminator="Regression"):
    """Regression task in AutoML Table vertical.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar cv_split_column_names: Columns to use for CVSplit data.
    :vartype cv_split_column_names: list[str]
    :ivar featurization_settings: Featurization inputs needed for AutoML job.
    :vartype featurization_settings:
     ~azure.mgmt.machinelearningservices.models.TableVerticalFeaturizationSettings
    :ivar limit_settings: Execution constraints for AutoMLJob.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.TableVerticalLimitSettings
    :ivar n_cross_validations: Number of cross validation folds to be applied on training dataset
     when validation dataset is not provided.
    :vartype n_cross_validations: ~azure.mgmt.machinelearningservices.models.NCrossValidations
    :ivar test_data: Test data input.
    :vartype test_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar test_data_size: The fraction of test dataset that needs to be set aside for validation
     purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype test_data_size: float
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar validation_data_size: The fraction of training dataset that needs to be set aside for
     validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided.
    :vartype validation_data_size: float
    :ivar weight_column_name: The name of the sample weight column. Automated ML supports a
     weighted column as an input, causing rows in the data to be weighted up or down.
    :vartype weight_column_name: str
    :ivar primary_metric: Primary metrics for Regression task. Known values are:
     "SpearmanCorrelation", "NormalizedRootMeanSquaredError", "R2Score", and
     "NormalizedMeanAbsoluteError".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.RegressionPrimaryMetrics
    :ivar training_settings: Inputs for training phase for an AutoML Job.
    :vartype training_settings:
     ~azure.mgmt.machinelearningservices.models.RegressionTrainingSettings
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Regression means to predict the
     value using the input data. Regression models are used to predict a continuous value.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.REGRESSION
    """

    cv_split_column_names: Optional[list[str]] = rest_field(
        name="cvSplitColumnNames", visibility=["read", "create", "update", "delete", "query"]
    )
    """Columns to use for CVSplit data."""
    featurization_settings: Optional["_models.TableVerticalFeaturizationSettings"] = rest_field(
        name="featurizationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization inputs needed for AutoML job."""
    limit_settings: Optional["_models.TableVerticalLimitSettings"] = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Execution constraints for AutoMLJob."""
    n_cross_validations: Optional["_models.NCrossValidations"] = rest_field(
        name="nCrossValidations", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of cross validation folds to be applied on training dataset
     when validation dataset is not provided."""
    test_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="testData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Test data input."""
    test_data_size: Optional[float] = rest_field(
        name="testDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of test dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    validation_data_size: Optional[float] = rest_field(
        name="validationDataSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The fraction of training dataset that needs to be set aside for validation purpose.
     Values between (0.0 , 1.0)
     Applied when validation dataset is not provided."""
    weight_column_name: Optional[str] = rest_field(
        name="weightColumnName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the sample weight column. Automated ML supports a weighted column as an input,
     causing rows in the data to be weighted up or down."""
    primary_metric: Optional[Union[str, "_models.RegressionPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for Regression task. Known values are: \"SpearmanCorrelation\",
     \"NormalizedRootMeanSquaredError\", \"R2Score\", and \"NormalizedMeanAbsoluteError\"."""
    training_settings: Optional["_models.RegressionTrainingSettings"] = rest_field(
        name="trainingSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Inputs for training phase for an AutoML Job."""
    task_type: Literal[TaskType.REGRESSION] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Regression means to predict the value using the
     input data. Regression models are used to predict a continuous value."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        cv_split_column_names: Optional[list[str]] = None,
        featurization_settings: Optional["_models.TableVerticalFeaturizationSettings"] = None,
        limit_settings: Optional["_models.TableVerticalLimitSettings"] = None,
        n_cross_validations: Optional["_models.NCrossValidations"] = None,
        test_data: Optional["_models.MLTableJobInput"] = None,
        test_data_size: Optional[float] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        validation_data_size: Optional[float] = None,
        weight_column_name: Optional[str] = None,
        primary_metric: Optional[Union[str, "_models.RegressionPrimaryMetrics"]] = None,
        training_settings: Optional["_models.RegressionTrainingSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.REGRESSION  # type: ignore


class RegressionTrainingSettings(TrainingSettings):
    """Regression Training related configuration.

    :ivar enable_dnn_training: Enable recommendation of DNN models.
    :vartype enable_dnn_training: bool
    :ivar enable_model_explainability: Flag to turn on explainability on best model.
    :vartype enable_model_explainability: bool
    :ivar enable_onnx_compatible_models: Flag for enabling onnx compatible models.
    :vartype enable_onnx_compatible_models: bool
    :ivar enable_stack_ensemble: Enable stack ensemble run.
    :vartype enable_stack_ensemble: bool
    :ivar enable_vote_ensemble: Enable voting ensemble run.
    :vartype enable_vote_ensemble: bool
    :ivar ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model
     generation, multiple fitted models from the previous child runs are downloaded.
     Configure this parameter with a higher value than 300 secs, if more time is needed.
    :vartype ensemble_model_download_timeout: ~datetime.timedelta
    :ivar stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
    :vartype stack_ensemble_settings:
     ~azure.mgmt.machinelearningservices.models.StackEnsembleSettings
    :ivar allowed_training_algorithms: Allowed models for regression task.
    :vartype allowed_training_algorithms: list[str or
     ~azure.mgmt.machinelearningservices.models.RegressionModels]
    :ivar blocked_training_algorithms: Blocked models for regression task.
    :vartype blocked_training_algorithms: list[str or
     ~azure.mgmt.machinelearningservices.models.RegressionModels]
    """

    allowed_training_algorithms: Optional[list[Union[str, "_models.RegressionModels"]]] = rest_field(
        name="allowedTrainingAlgorithms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allowed models for regression task."""
    blocked_training_algorithms: Optional[list[Union[str, "_models.RegressionModels"]]] = rest_field(
        name="blockedTrainingAlgorithms", visibility=["read", "create", "update", "delete", "query"]
    )
    """Blocked models for regression task."""

    @overload
    def __init__(
        self,
        *,
        enable_dnn_training: Optional[bool] = None,
        enable_model_explainability: Optional[bool] = None,
        enable_onnx_compatible_models: Optional[bool] = None,
        enable_stack_ensemble: Optional[bool] = None,
        enable_vote_ensemble: Optional[bool] = None,
        ensemble_model_download_timeout: Optional[datetime.timedelta] = None,
        stack_ensemble_settings: Optional["_models.StackEnsembleSettings"] = None,
        allowed_training_algorithms: Optional[list[Union[str, "_models.RegressionModels"]]] = None,
        blocked_training_algorithms: Optional[list[Union[str, "_models.RegressionModels"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequestConfiguration(_Model):
    """Scoring requests configuration.

    :ivar max_concurrent_requests_per_instance: The number of maximum concurrent requests per node
     allowed per deployment. Defaults to 1.
    :vartype max_concurrent_requests_per_instance: int
    :ivar request_timeout: The scoring timeout in ISO 8601 format.
     Defaults to 5000ms.
    :vartype request_timeout: ~datetime.timedelta
    """

    max_concurrent_requests_per_instance: Optional[int] = rest_field(
        name="maxConcurrentRequestsPerInstance", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of maximum concurrent requests per node allowed per deployment. Defaults to 1."""
    request_timeout: Optional[datetime.timedelta] = rest_field(
        name="requestTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """The scoring timeout in ISO 8601 format.
     Defaults to 5000ms."""

    @overload
    def __init__(
        self,
        *,
        max_concurrent_requests_per_instance: Optional[int] = None,
        request_timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequestLogging(_Model):
    """RequestLogging.

    :ivar capture_headers: For payload logging, we only collect payload by default. If customers
     also want to collect the specified headers, they can set them in captureHeaders so that backend
     will collect those headers along with payload.
    :vartype capture_headers: list[str]
    """

    capture_headers: Optional[list[str]] = rest_field(
        name="captureHeaders", visibility=["read", "create", "update", "delete", "query"]
    )
    """For payload logging, we only collect payload by default. If customers also want to collect the
     specified headers, they can set them in captureHeaders so that backend will collect those
     headers along with payload."""

    @overload
    def __init__(
        self,
        *,
        capture_headers: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResizeSchema(_Model):
    """Schema for Compute Instance resize.

    :ivar target_vm_size: The name of the virtual machine size.
    :vartype target_vm_size: str
    """

    target_vm_size: Optional[str] = rest_field(
        name="targetVMSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the virtual machine size."""

    @overload
    def __init__(
        self,
        *,
        target_vm_size: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceId(_Model):
    """Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.

    :ivar id: The ID of the resource. Required.
    :vartype id: str
    """

    id: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The ID of the resource. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResourceName(_Model):
    """The Resource Name.

    :ivar value: The name of the resource.
    :vartype value: str
    :ivar localized_value: The localized name of the resource.
    :vartype localized_value: str
    """

    value: Optional[str] = rest_field(visibility=["read"])
    """The name of the resource."""
    localized_value: Optional[str] = rest_field(name="localizedValue", visibility=["read"])
    """The localized name of the resource."""


class ResourceQuota(_Model):
    """The quota assigned to a resource.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar aml_workspace_location: Region of the AML workspace in the id.
    :vartype aml_workspace_location: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :ivar name: Name of the resource.
    :vartype name: ~azure.mgmt.machinelearningservices.models.ResourceName
    :ivar limit: Limit.
    :vartype limit: int
    :ivar unit: An enum describing the unit of quota measurement. "Count"
    :vartype unit: str or ~azure.mgmt.machinelearningservices.models.QuotaUnit
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Specifies the resource ID."""
    aml_workspace_location: Optional[str] = rest_field(name="amlWorkspaceLocation", visibility=["read"])
    """Region of the AML workspace in the id."""
    type: Optional[str] = rest_field(visibility=["read"])
    """Specifies the resource type."""
    name: Optional["_models.ResourceName"] = rest_field(visibility=["read"])
    """Name of the resource."""
    limit: Optional[int] = rest_field(visibility=["read"])
    """Limit."""
    unit: Optional[Union[str, "_models.QuotaUnit"]] = rest_field(visibility=["read"])
    """An enum describing the unit of quota measurement. \"Count\""""


class RollingInputData(MonitoringInputDataBase, discriminator="Rolling"):
    """Rolling input data definition.

    :ivar columns: Mapping of column names to special uses.
    :vartype columns: dict[str, str]
    :ivar data_context: The context metadata of the data source.
    :vartype data_context: str
    :ivar job_input_type: [Required] Specifies the type of job. Required. Known values are:
     "literal", "uri_file", "uri_folder", "mltable", "custom_model", "mlflow_model", and
     "triton_model".
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.JobInputType
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar preprocessing_component_id: Reference to the component asset used to preprocess the data.
    :vartype preprocessing_component_id: str
    :ivar window_offset: [Required] The time offset between the end of the data window and the
     monitor's current run time. Required.
    :vartype window_offset: ~datetime.timedelta
    :ivar window_size: [Required] The size of the rolling data window. Required.
    :vartype window_size: ~datetime.timedelta
    :ivar input_data_type: [Required] Specifies the type of signal to monitor. Required. An input
     data which rolls relatively to the monitor's current run time.
    :vartype input_data_type: str or ~azure.mgmt.machinelearningservices.models.ROLLING
    """

    preprocessing_component_id: Optional[str] = rest_field(
        name="preprocessingComponentId", visibility=["read", "create"]
    )
    """Reference to the component asset used to preprocess the data."""
    window_offset: datetime.timedelta = rest_field(name="windowOffset", visibility=["read", "create"])
    """[Required] The time offset between the end of the data window and the monitor's current run
     time. Required."""
    window_size: datetime.timedelta = rest_field(name="windowSize", visibility=["read", "create"])
    """[Required] The size of the rolling data window. Required."""
    input_data_type: Literal[MonitoringInputDataType.ROLLING] = rest_discriminator(name="inputDataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. An input data which rolls
     relatively to the monitor's current run time."""

    @overload
    def __init__(
        self,
        *,
        job_input_type: Union[str, "_models.JobInputType"],
        uri: str,
        window_offset: datetime.timedelta,
        window_size: datetime.timedelta,
        columns: Optional[dict[str, str]] = None,
        data_context: Optional[str] = None,
        preprocessing_component_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.input_data_type = MonitoringInputDataType.ROLLING  # type: ignore


class Route(_Model):
    """Route.

    :ivar path: [Required] The path for the route. Required.
    :vartype path: str
    :ivar port: [Required] The port for the route. Required.
    :vartype port: int
    """

    path: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] The path for the route. Required."""
    port: int = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] The port for the route. Required."""

    @overload
    def __init__(
        self,
        *,
        path: str,
        port: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SASAuthTypeWorkspaceConnectionProperties(WorkspaceConnectionPropertiesV2, discriminator="SAS"):
    """SASAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials:
     ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionSharedAccessSignature
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.SAS
    """

    credentials: Optional["_models.WorkspaceConnectionSharedAccessSignature"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.SAS] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionSharedAccessSignature"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.SAS  # type: ignore


class SASCredential(DataReferenceCredential, discriminator="SAS"):
    """Access with full SAS uri.

    :ivar sas_uri: Full SAS Uri, including the storage, container/blob path and SAS token.
    :vartype sas_uri: str
    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credential_type: str or ~azure.mgmt.machinelearningservices.models.SAS
    """

    sas_uri: Optional[str] = rest_field(name="sasUri", visibility=["read", "create", "update", "delete", "query"])
    """Full SAS Uri, including the storage, container/blob path and SAS token."""
    credential_type: Literal[DataReferenceCredentialType.SAS] = rest_discriminator(name="credentialType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        sas_uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credential_type = DataReferenceCredentialType.SAS  # type: ignore


class SASCredentialDto(PendingUploadCredentialDto, discriminator="SAS"):
    """SASCredentialDto.

    :ivar sas_uri: Full SAS Uri, including the storage, container/blob path and SAS token.
    :vartype sas_uri: str
    :ivar credential_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credential_type: str or ~azure.mgmt.machinelearningservices.models.SAS
    """

    sas_uri: Optional[str] = rest_field(name="sasUri", visibility=["read", "create", "update", "delete", "query"])
    """Full SAS Uri, including the storage, container/blob path and SAS token."""
    credential_type: Literal[PendingUploadCredentialType.SAS] = rest_discriminator(name="credentialType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        sas_uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credential_type = PendingUploadCredentialType.SAS  # type: ignore


class SasDatastoreCredentials(DatastoreCredentials, discriminator="Sas"):
    """SAS datastore credentials configuration.

    :ivar secrets: [Required] Storage container secrets. Required.
    :vartype secrets: ~azure.mgmt.machinelearningservices.models.SasDatastoreSecrets
    :ivar credentials_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credentials_type: str or ~azure.mgmt.machinelearningservices.models.SAS
    """

    secrets: "_models.SasDatastoreSecrets" = rest_field(visibility=["create", "update"])
    """[Required] Storage container secrets. Required."""
    credentials_type: Literal[CredentialsType.SAS] = rest_discriminator(name="credentialsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        secrets: "_models.SasDatastoreSecrets",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credentials_type = CredentialsType.SAS  # type: ignore


class SasDatastoreSecrets(DatastoreSecrets, discriminator="Sas"):
    """Datastore SAS secrets.

    :ivar sas_token: Storage container SAS token.
    :vartype sas_token: str
    :ivar secrets_type: [Required] Credential type used to authentication with storage. Required.
    :vartype secrets_type: str or ~azure.mgmt.machinelearningservices.models.SAS
    """

    sas_token: Optional[str] = rest_field(name="sasToken", visibility=["read", "create", "update", "delete", "query"])
    """Storage container SAS token."""
    secrets_type: Literal[SecretsType.SAS] = rest_discriminator(name="secretsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        sas_token: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.secrets_type = SecretsType.SAS  # type: ignore


class ScaleSettings(_Model):
    """scale settings for AML Compute.

    :ivar max_node_count: Max number of nodes to use. Required.
    :vartype max_node_count: int
    :ivar min_node_count: Min number of nodes to use.
    :vartype min_node_count: int
    :ivar node_idle_time_before_scale_down: Node Idle Time before scaling down amlCompute. This
     string needs to be in the RFC Format.
    :vartype node_idle_time_before_scale_down: ~datetime.timedelta
    """

    max_node_count: int = rest_field(name="maxNodeCount", visibility=["read", "create", "update", "delete", "query"])
    """Max number of nodes to use. Required."""
    min_node_count: Optional[int] = rest_field(
        name="minNodeCount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Min number of nodes to use."""
    node_idle_time_before_scale_down: Optional[datetime.timedelta] = rest_field(
        name="nodeIdleTimeBeforeScaleDown", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format."""

    @overload
    def __init__(
        self,
        *,
        max_node_count: int,
        min_node_count: Optional[int] = None,
        node_idle_time_before_scale_down: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScaleSettingsInformation(_Model):
    """Desired scale settings for the amlCompute.

    :ivar scale_settings: Scale settings.
    :vartype scale_settings: ~azure.mgmt.machinelearningservices.models.ScaleSettings
    """

    scale_settings: Optional["_models.ScaleSettings"] = rest_field(
        name="scaleSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Scale settings."""

    @overload
    def __init__(
        self,
        *,
        scale_settings: Optional["_models.ScaleSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScaleUnitConfiguration(_Model):
    """Configuration for ScaleUnit pool.

    :ivar disable_public_egress: Gets or sets a value indicating whether PublicEgress is disabled.
    :vartype disable_public_egress: bool
    :ivar registries: Gets or sets a list of Registry sources that will be used to confirm
     identity, storage, ACR.
    :vartype registries: list[str]
    """

    disable_public_egress: Optional[bool] = rest_field(
        name="disablePublicEgress", visibility=["read", "create", "update", "delete", "query"]
    )
    """Gets or sets a value indicating whether PublicEgress is disabled."""
    registries: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets a list of Registry sources that will be used to confirm identity, storage, ACR."""

    @overload
    def __init__(
        self,
        *,
        disable_public_egress: Optional[bool] = None,
        registries: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Schedule(ProxyResource):
    """Azure Resource Manager resource envelope.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ScheduleProperties
    """

    properties: "_models.ScheduleProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Additional attributes of the entity. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.ScheduleProperties",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduleBase(_Model):
    """ScheduleBase.

    :ivar id: A system assigned id for the schedule.
    :vartype id: str
    :ivar provisioning_status: The current deployment state of schedule. Known values are:
     "Completed", "Provisioning", and "Failed".
    :vartype provisioning_status: str or
     ~azure.mgmt.machinelearningservices.models.ScheduleProvisioningState
    :ivar status: Is the schedule enabled or disabled?. Known values are: "Enabled" and "Disabled".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.ScheduleStatus
    """

    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """A system assigned id for the schedule."""
    provisioning_status: Optional[Union[str, "_models.ScheduleProvisioningState"]] = rest_field(
        name="provisioningStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """The current deployment state of schedule. Known values are: \"Completed\", \"Provisioning\",
     and \"Failed\"."""
    status: Optional[Union[str, "_models.ScheduleStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Is the schedule enabled or disabled?. Known values are: \"Enabled\" and \"Disabled\"."""

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        provisioning_status: Optional[Union[str, "_models.ScheduleProvisioningState"]] = None,
        status: Optional[Union[str, "_models.ScheduleStatus"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduleProperties(ResourceBase):
    """Base definition of a schedule.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar action: [Required] Specifies the action of the schedule. Required.
    :vartype action: ~azure.mgmt.machinelearningservices.models.ScheduleActionBase
    :ivar display_name: Display name of schedule.
    :vartype display_name: str
    :ivar is_enabled: Is the schedule enabled?.
    :vartype is_enabled: bool
    :ivar provisioning_state: Provisioning state for the schedule. Known values are: "Creating",
     "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ScheduleProvisioningStatus
    :ivar trigger: [Required] Specifies the trigger details. Required.
    :vartype trigger: ~azure.mgmt.machinelearningservices.models.TriggerBase
    """

    action: "_models.ScheduleActionBase" = rest_field(visibility=["read", "create", "update"])
    """[Required] Specifies the action of the schedule. Required."""
    display_name: Optional[str] = rest_field(name="displayName", visibility=["read", "create"])
    """Display name of schedule."""
    is_enabled: Optional[bool] = rest_field(name="isEnabled", visibility=["read", "create", "update"])
    """Is the schedule enabled?."""
    provisioning_state: Optional[Union[str, "_models.ScheduleProvisioningStatus"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """Provisioning state for the schedule. Known values are: \"Creating\", \"Updating\",
     \"Deleting\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    trigger: "_models.TriggerBase" = rest_field(visibility=["read", "create", "update"])
    """[Required] Specifies the trigger details. Required."""

    @overload
    def __init__(
        self,
        *,
        action: "_models.ScheduleActionBase",
        trigger: "_models.TriggerBase",
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        display_name: Optional[str] = None,
        is_enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScriptReference(_Model):
    """Script reference.

    :ivar script_source: The storage source of the script: inline, workspace.
    :vartype script_source: str
    :ivar script_data: The location of scripts in the mounted volume.
    :vartype script_data: str
    :ivar script_arguments: Optional command line arguments passed to the script to run.
    :vartype script_arguments: str
    :ivar timeout: Optional time period passed to timeout command.
    :vartype timeout: str
    """

    script_source: Optional[str] = rest_field(
        name="scriptSource", visibility=["read", "create", "update", "delete", "query"]
    )
    """The storage source of the script: inline, workspace."""
    script_data: Optional[str] = rest_field(
        name="scriptData", visibility=["read", "create", "update", "delete", "query"]
    )
    """The location of scripts in the mounted volume."""
    script_arguments: Optional[str] = rest_field(
        name="scriptArguments", visibility=["read", "create", "update", "delete", "query"]
    )
    """Optional command line arguments passed to the script to run."""
    timeout: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional time period passed to timeout command."""

    @overload
    def __init__(
        self,
        *,
        script_source: Optional[str] = None,
        script_data: Optional[str] = None,
        script_arguments: Optional[str] = None,
        timeout: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScriptsToExecute(_Model):
    """Customized setup scripts.

    :ivar startup_script: Script that's run every time the machine starts.
    :vartype startup_script: ~azure.mgmt.machinelearningservices.models.ScriptReference
    :ivar creation_script: Script that's run only once during provision of the compute.
    :vartype creation_script: ~azure.mgmt.machinelearningservices.models.ScriptReference
    """

    startup_script: Optional["_models.ScriptReference"] = rest_field(
        name="startupScript", visibility=["read", "create", "update", "delete", "query"]
    )
    """Script that's run every time the machine starts."""
    creation_script: Optional["_models.ScriptReference"] = rest_field(
        name="creationScript", visibility=["read", "create", "update", "delete", "query"]
    )
    """Script that's run only once during provision of the compute."""

    @overload
    def __init__(
        self,
        *,
        startup_script: Optional["_models.ScriptReference"] = None,
        creation_script: Optional["_models.ScriptReference"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SecretExpiry(_Model):
    """Secret expiration configuration.

    :ivar expirable_secret: Indicates if the secret is expirable.
    :vartype expirable_secret: bool
    :ivar expire_after_hours: Number of hours after which the secret will expire.
    :vartype expire_after_hours: int
    """

    expirable_secret: Optional[bool] = rest_field(
        name="expirableSecret", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if the secret is expirable."""
    expire_after_hours: Optional[int] = rest_field(
        name="expireAfterHours", visibility=["read", "create", "update", "delete", "query"]
    )
    """Number of hours after which the secret will expire."""

    @overload
    def __init__(
        self,
        *,
        expirable_secret: Optional[bool] = None,
        expire_after_hours: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessComputeSettings(_Model):
    """ServerlessComputeSettings.

    :ivar serverless_compute_custom_subnet: The resource ID of an existing virtual network subnet
     in which serverless compute nodes should be deployed.
    :vartype serverless_compute_custom_subnet: str
    :ivar serverless_compute_no_public_ip: The flag to signal if serverless compute nodes deployed
     in custom vNet would have no public IP addresses for a workspace with private endpoint.
    :vartype serverless_compute_no_public_ip: bool
    """

    serverless_compute_custom_subnet: Optional[str] = rest_field(
        name="serverlessComputeCustomSubnet", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource ID of an existing virtual network subnet in which serverless compute nodes should
     be deployed."""
    serverless_compute_no_public_ip: Optional[bool] = rest_field(
        name="serverlessComputeNoPublicIP", visibility=["read", "create", "update", "delete", "query"]
    )
    """The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP
     addresses for a workspace with private endpoint."""

    @overload
    def __init__(
        self,
        *,
        serverless_compute_custom_subnet: Optional[str] = None,
        serverless_compute_no_public_ip: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessEndpoint(TrackedResource):
    """Concrete tracked resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar location: The geo-location where the resource lives. Required.
    :vartype location: str
    :ivar properties: [Required] Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.ServerlessEndpointProperties
    :ivar identity: Managed service identity (system assigned and/or user assigned identities).
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type.
    :vartype kind: str
    :ivar sku: Sku details required for ARM contract for Autoscaling.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    """

    properties: "_models.ServerlessEndpointProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Managed service identity (system assigned and/or user assigned identities)."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Sku details required for ARM contract for Autoscaling."""

    @overload
    def __init__(
        self,
        *,
        location: str,
        properties: "_models.ServerlessEndpointProperties",
        tags: Optional[dict[str, str]] = None,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessEndpointCapacityReservation(_Model):
    """ServerlessEndpointCapacityReservation.

    :ivar capacity_reservation_group_id: Required.
    :vartype capacity_reservation_group_id: str
    :ivar endpoint_reserved_capacity:
    :vartype endpoint_reserved_capacity: int
    """

    capacity_reservation_group_id: str = rest_field(
        name="capacityReservationGroupId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Required."""
    endpoint_reserved_capacity: Optional[int] = rest_field(
        name="endpointReservedCapacity", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        capacity_reservation_group_id: str,
        endpoint_reserved_capacity: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessEndpointContentSafety(_Model):
    """ServerlessEndpointContentSafety.

    :ivar content_safety_status: Specifies the status of content safety. Required. Known values
     are: "Enabled" and "Disabled".
    :vartype content_safety_status: str or
     ~azure.mgmt.machinelearningservices.models.ContentSafetyStatus
    """

    content_safety_status: Union[str, "_models.ContentSafetyStatus"] = rest_field(
        name="contentSafetyStatus", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the status of content safety. Required. Known values are: \"Enabled\" and
     \"Disabled\"."""

    @overload
    def __init__(
        self,
        *,
        content_safety_status: Union[str, "_models.ContentSafetyStatus"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessEndpointInferenceEndpoint(_Model):
    """ServerlessEndpointInferenceEndpoint.

    :ivar headers:
    :vartype headers: dict[str, str]
    :ivar uri: Required.
    :vartype uri: str
    """

    headers: Optional[dict[str, str]] = rest_field(visibility=["read"])
    uri: str = rest_field(visibility=["read"])
    """Required."""


class ServerlessEndpointModelSettings(_Model):
    """ServerlessEndpointModelSettings.

    :ivar model_id: Required.
    :vartype model_id: str
    """

    model_id: str = rest_field(name="modelId", visibility=["read", "create", "update", "delete", "query"])
    """Required."""

    @overload
    def __init__(
        self,
        *,
        model_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessEndpointProperties(_Model):
    """ServerlessEndpointProperties.

    :ivar auth_mode: [Required] Specifies the authentication mode for the Serverless endpoint.
     Required. Known values are: "Key", "AAD", and "KeyAndAAD".
    :vartype auth_mode: str or
     ~azure.mgmt.machinelearningservices.models.ServerlessInferenceEndpointAuthMode
    :ivar content_safety: Specifies the content safety options. If omitted, the default content
     safety settings will be configured.
    :vartype content_safety: ~azure.mgmt.machinelearningservices.models.ContentSafety
    :ivar endpoint_state: The current state of the ServerlessEndpoint. Known values are: "Unknown",
     "Creating", "Deleting", "Suspending", "Reinstating", "Online", "Suspended", "CreationFailed",
     and "DeletionFailed".
    :vartype endpoint_state: str or
     ~azure.mgmt.machinelearningservices.models.ServerlessEndpointState
    :ivar inference_endpoint: The inference uri to target when making requests against the
     serverless endpoint.
    :vartype inference_endpoint:
     ~azure.mgmt.machinelearningservices.models.ServerlessInferenceEndpoint
    :ivar marketplace_subscription_id: The MarketplaceSubscription Azure ID associated to this
     ServerlessEndpoint.
    :vartype marketplace_subscription_id: str
    :ivar model_settings: The model settings (model id) for the model being serviced on the
     ServerlessEndpoint.
    :vartype model_settings: ~azure.mgmt.machinelearningservices.models.ModelSettings
    :ivar provisioning_state: State of endpoint provisioning. Known values are: "Creating",
     "Deleting", "Succeeded", "Failed", "Updating", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.EndpointProvisioningState
    """

    auth_mode: Union[str, "_models.ServerlessInferenceEndpointAuthMode"] = rest_field(
        name="authMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] Specifies the authentication mode for the Serverless endpoint. Required. Known
     values are: \"Key\", \"AAD\", and \"KeyAndAAD\"."""
    content_safety: Optional["_models.ContentSafety"] = rest_field(
        name="contentSafety", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the content safety options. If omitted, the default content safety settings will be
     configured."""
    endpoint_state: Optional[Union[str, "_models.ServerlessEndpointState"]] = rest_field(
        name="endpointState", visibility=["read"]
    )
    """The current state of the ServerlessEndpoint. Known values are: \"Unknown\", \"Creating\",
     \"Deleting\", \"Suspending\", \"Reinstating\", \"Online\", \"Suspended\", \"CreationFailed\",
     and \"DeletionFailed\"."""
    inference_endpoint: Optional["_models.ServerlessInferenceEndpoint"] = rest_field(
        name="inferenceEndpoint", visibility=["read"]
    )
    """The inference uri to target when making requests against the serverless endpoint."""
    marketplace_subscription_id: Optional[str] = rest_field(name="marketplaceSubscriptionId", visibility=["read"])
    """The MarketplaceSubscription Azure ID associated to this ServerlessEndpoint."""
    model_settings: Optional["_models.ModelSettings"] = rest_field(
        name="modelSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The model settings (model id) for the model being serviced on the ServerlessEndpoint."""
    provisioning_state: Optional[Union[str, "_models.EndpointProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """State of endpoint provisioning. Known values are: \"Creating\", \"Deleting\", \"Succeeded\",
     \"Failed\", \"Updating\", and \"Canceled\"."""

    @overload
    def __init__(
        self,
        *,
        auth_mode: Union[str, "_models.ServerlessInferenceEndpointAuthMode"],
        content_safety: Optional["_models.ContentSafety"] = None,
        model_settings: Optional["_models.ModelSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServerlessEndpointResourceProperties(EndpointResourceProperties, discriminator="serverlessEndpoint"):
    """ServerlessEndpointResourceProperties.

    :ivar associated_resource_id: Byo resource id for creating the built-in model service
     endpoints.
    :vartype associated_resource_id: str
    :ivar deployments: Deployments info.
    :vartype deployments:
     list[~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourcePropertiesBasicResource]
    :ivar endpoint_uri: Uri of the endpoint.
    :vartype endpoint_uri: str
    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar location: Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace.
    :vartype location: str
    :ivar name: Name of the endpoint.
    :vartype name: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar should_create_ai_services_endpoint: Whether the proxy (non-byo) endpoint is a regular
     endpoint or a OneKeyV2 AI services account endpoint.
    :vartype should_create_ai_services_endpoint: bool
    :ivar auth_mode: Known values are: "Key", "AAD", and "KeyAndAAD".
    :vartype auth_mode: str or
     ~azure.mgmt.machinelearningservices.models.ServerlessInferenceEndpointAuthMode
    :ivar capacity_reservation:
    :vartype capacity_reservation:
     ~azure.mgmt.machinelearningservices.models.ServerlessEndpointCapacityReservation
    :ivar content_safety:
    :vartype content_safety:
     ~azure.mgmt.machinelearningservices.models.ServerlessEndpointContentSafety
    :ivar endpoint_state: State of the Serverless Endpoint. Known values are: "Unknown",
     "Creating", "Deleting", "Suspending", "Reinstating", "Online", "Suspended", "CreationFailed",
     and "DeletionFailed".
    :vartype endpoint_state: str or
     ~azure.mgmt.machinelearningservices.models.ServerlessEndpointState
    :ivar inference_endpoint:
    :vartype inference_endpoint:
     ~azure.mgmt.machinelearningservices.models.ServerlessEndpointInferenceEndpoint
    :ivar marketplace_subscription_id:
    :vartype marketplace_subscription_id: str
    :ivar metadata:
    :vartype metadata: any
    :ivar model_settings:
    :vartype model_settings:
     ~azure.mgmt.machinelearningservices.models.ServerlessEndpointModelSettings
    :ivar offer:
    :vartype offer: ~azure.mgmt.machinelearningservices.models.ServerlessOffer
    :ivar endpoint_type: Type of the endpoint. Required.
    :vartype endpoint_type: str or ~azure.mgmt.machinelearningservices.models.SERVERLESS_ENDPOINT
    """

    auth_mode: Optional[Union[str, "_models.ServerlessInferenceEndpointAuthMode"]] = rest_field(
        name="authMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Known values are: \"Key\", \"AAD\", and \"KeyAndAAD\"."""
    capacity_reservation: Optional["_models.ServerlessEndpointCapacityReservation"] = rest_field(
        name="capacityReservation", visibility=["read", "create", "update", "delete", "query"]
    )
    content_safety: Optional["_models.ServerlessEndpointContentSafety"] = rest_field(
        name="contentSafety", visibility=["read", "create", "update", "delete", "query"]
    )
    endpoint_state: Optional[Union[str, "_models.ServerlessEndpointState"]] = rest_field(
        name="endpointState", visibility=["read", "create", "update", "delete", "query"]
    )
    """State of the Serverless Endpoint. Known values are: \"Unknown\", \"Creating\", \"Deleting\",
     \"Suspending\", \"Reinstating\", \"Online\", \"Suspended\", \"CreationFailed\", and
     \"DeletionFailed\"."""
    inference_endpoint: Optional["_models.ServerlessEndpointInferenceEndpoint"] = rest_field(
        name="inferenceEndpoint", visibility=["read", "create", "update", "delete", "query"]
    )
    marketplace_subscription_id: Optional[str] = rest_field(
        name="marketplaceSubscriptionId", visibility=["read", "create", "update", "delete", "query"]
    )
    metadata: Optional[Any] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    model_settings: Optional["_models.ServerlessEndpointModelSettings"] = rest_field(
        name="modelSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    offer: Optional["_models.ServerlessOffer"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    endpoint_type: Literal[EndpointType.SERVERLESS_ENDPOINT] = rest_discriminator(name="endpointType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        associated_resource_id: Optional[str] = None,
        deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = None,
        endpoint_uri: Optional[str] = None,
        failure_reason: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        should_create_ai_services_endpoint: Optional[bool] = None,
        auth_mode: Optional[Union[str, "_models.ServerlessInferenceEndpointAuthMode"]] = None,
        capacity_reservation: Optional["_models.ServerlessEndpointCapacityReservation"] = None,
        content_safety: Optional["_models.ServerlessEndpointContentSafety"] = None,
        endpoint_state: Optional[Union[str, "_models.ServerlessEndpointState"]] = None,
        inference_endpoint: Optional["_models.ServerlessEndpointInferenceEndpoint"] = None,
        marketplace_subscription_id: Optional[str] = None,
        metadata: Optional[Any] = None,
        model_settings: Optional["_models.ServerlessEndpointModelSettings"] = None,
        offer: Optional["_models.ServerlessOffer"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_type = EndpointType.SERVERLESS_ENDPOINT  # type: ignore


class ServerlessInferenceEndpoint(_Model):
    """ServerlessInferenceEndpoint.

    :ivar headers: Specifies any required headers to target this serverless endpoint.
    :vartype headers: dict[str, str]
    :ivar uri: [Required] The inference uri to target when making requests against the Serverless
     Endpoint. Required.
    :vartype uri: str
    """

    headers: Optional[dict[str, str]] = rest_field(visibility=["read"])
    """Specifies any required headers to target this serverless endpoint."""
    uri: str = rest_field(visibility=["read"])
    """[Required] The inference uri to target when making requests against the Serverless Endpoint.
     Required."""


class ServerlessOffer(_Model):
    """ServerlessOffer.

    :ivar offer_name: Required.
    :vartype offer_name: str
    :ivar publisher: Required.
    :vartype publisher: str
    """

    offer_name: str = rest_field(name="offerName", visibility=["read", "create", "update", "delete", "query"])
    """Required."""
    publisher: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Required."""

    @overload
    def __init__(
        self,
        *,
        offer_name: str,
        publisher: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceManagedResourcesSettings(_Model):
    """ServiceManagedResourcesSettings.

    :ivar cosmos_db:
    :vartype cosmos_db: ~azure.mgmt.machinelearningservices.models.CosmosDbSettings
    """

    cosmos_db: Optional["_models.CosmosDbSettings"] = rest_field(
        name="cosmosDb", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        cosmos_db: Optional["_models.CosmosDbSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServicePrincipalAuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="ServicePrincipal"
):  # pylint: disable=name-too-long
    """ServicePrincipalAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials:
     ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionServicePrincipal
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.SERVICE_PRINCIPAL
    """

    credentials: Optional["_models.WorkspaceConnectionServicePrincipal"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.SERVICE_PRINCIPAL] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionServicePrincipal"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.SERVICE_PRINCIPAL  # type: ignore


class ServicePrincipalDatastoreCredentials(DatastoreCredentials, discriminator="ServicePrincipal"):
    """Service Principal datastore credentials configuration.

    :ivar authority_url: Authority URL used for authentication.
    :vartype authority_url: str
    :ivar client_id: [Required] Service principal client ID. Required.
    :vartype client_id: str
    :ivar resource_url: Resource the service principal has access to.
    :vartype resource_url: str
    :ivar secrets: [Required] Service principal secrets. Required.
    :vartype secrets: ~azure.mgmt.machinelearningservices.models.ServicePrincipalDatastoreSecrets
    :ivar tenant_id: [Required] ID of the tenant to which the service principal belongs. Required.
    :vartype tenant_id: str
    :ivar credentials_type: [Required] Credential type used to authentication with storage.
     Required.
    :vartype credentials_type: str or ~azure.mgmt.machinelearningservices.models.SERVICE_PRINCIPAL
    """

    authority_url: Optional[str] = rest_field(
        name="authorityUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Authority URL used for authentication."""
    client_id: str = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] Service principal client ID. Required."""
    resource_url: Optional[str] = rest_field(
        name="resourceUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource the service principal has access to."""
    secrets: "_models.ServicePrincipalDatastoreSecrets" = rest_field(visibility=["create", "update"])
    """[Required] Service principal secrets. Required."""
    tenant_id: str = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] ID of the tenant to which the service principal belongs. Required."""
    credentials_type: Literal[CredentialsType.SERVICE_PRINCIPAL] = rest_discriminator(name="credentialsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        client_id: str,
        secrets: "_models.ServicePrincipalDatastoreSecrets",
        tenant_id: str,
        authority_url: Optional[str] = None,
        resource_url: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.credentials_type = CredentialsType.SERVICE_PRINCIPAL  # type: ignore


class ServicePrincipalDatastoreSecrets(DatastoreSecrets, discriminator="ServicePrincipal"):
    """Datastore Service Principal secrets.

    :ivar client_secret: Service principal secret.
    :vartype client_secret: str
    :ivar secrets_type: [Required] Credential type used to authentication with storage. Required.
    :vartype secrets_type: str or ~azure.mgmt.machinelearningservices.models.SERVICE_PRINCIPAL
    """

    client_secret: Optional[str] = rest_field(
        name="clientSecret", visibility=["read", "create", "update", "delete", "query"]
    )
    """Service principal secret."""
    secrets_type: Literal[SecretsType.SERVICE_PRINCIPAL] = rest_discriminator(name="secretsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Credential type used to authentication with storage. Required."""

    @overload
    def __init__(
        self,
        *,
        client_secret: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.secrets_type = SecretsType.SERVICE_PRINCIPAL  # type: ignore


class ServiceTagDestination(_Model):
    """Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine
    learning workspace.

    :ivar action: The action enum for networking rule. Known values are: "Allow" and "Deny".
    :vartype action: str or ~azure.mgmt.machinelearningservices.models.RuleAction
    :ivar address_prefixes: Optional, if provided, the ServiceTag property will be ignored.
    :vartype address_prefixes: list[str]
    :ivar port_ranges:
    :vartype port_ranges: str
    :ivar protocol:
    :vartype protocol: str
    :ivar service_tag:
    :vartype service_tag: str
    """

    action: Optional[Union[str, "_models.RuleAction"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The action enum for networking rule. Known values are: \"Allow\" and \"Deny\"."""
    address_prefixes: Optional[list[str]] = rest_field(
        name="addressPrefixes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Optional, if provided, the ServiceTag property will be ignored."""
    port_ranges: Optional[str] = rest_field(
        name="portRanges", visibility=["read", "create", "update", "delete", "query"]
    )
    protocol: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    service_tag: Optional[str] = rest_field(
        name="serviceTag", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        action: Optional[Union[str, "_models.RuleAction"]] = None,
        address_prefixes: Optional[list[str]] = None,
        port_ranges: Optional[str] = None,
        protocol: Optional[str] = None,
        service_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceTagOutboundRule(OutboundRule, discriminator="ServiceTag"):
    """Service Tag Outbound Rule for the managed network of a machine learning workspace.

    :ivar category: Category of a managed network Outbound Rule of a machine learning workspace.
     Known values are: "Required", "Recommended", "UserDefined", and "Dependency".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.RuleCategory
    :ivar status: Type of a managed network Outbound Rule of a machine learning workspace. Known
     values are: "Inactive", "Active", "Provisioning", "Deleting", and "Failed".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.RuleStatus
    :ivar error_information: Error information about an outbound rule of a machine learning
     workspace if RuleStatus is failed.
    :vartype error_information: str
    :ivar parent_rule_names:
    :vartype parent_rule_names: list[str]
    :ivar destination: Service Tag destination for a Service Tag Outbound Rule for the managed
     network of a machine learning workspace.
    :vartype destination: ~azure.mgmt.machinelearningservices.models.ServiceTagDestination
    :ivar type: Type of a managed network Outbound Rule of a machine learning workspace. Required.
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.SERVICE_TAG
    """

    destination: Optional["_models.ServiceTagDestination"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine
     learning workspace."""
    type: Literal[RuleType.SERVICE_TAG] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of a managed network Outbound Rule of a machine learning workspace. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.RuleCategory"]] = None,
        status: Optional[Union[str, "_models.RuleStatus"]] = None,
        destination: Optional["_models.ServiceTagDestination"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = RuleType.SERVICE_TAG  # type: ignore


class SetupScripts(_Model):
    """Details of customized scripts to execute for setting up the cluster.

    :ivar scripts: Customized setup scripts.
    :vartype scripts: ~azure.mgmt.machinelearningservices.models.ScriptsToExecute
    """

    scripts: Optional["_models.ScriptsToExecute"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Customized setup scripts."""

    @overload
    def __init__(
        self,
        *,
        scripts: Optional["_models.ScriptsToExecute"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SharedPrivateLinkResource(_Model):
    """SharedPrivateLinkResource.

    :ivar name: Unique name of the private link.
    :vartype name: str
    :ivar properties: Properties of a shared private link resource.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.SharedPrivateLinkResourceProperty
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Unique name of the private link."""
    properties: Optional["_models.SharedPrivateLinkResourceProperty"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Properties of a shared private link resource."""

    __flattened_items = ["group_id", "private_link_resource_id", "request_message", "status"]

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        properties: Optional["_models.SharedPrivateLinkResourceProperty"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class SharedPrivateLinkResourceProperty(_Model):
    """Properties of a shared private link resource.

    :ivar group_id: group id of the private link.
    :vartype group_id: str
    :ivar private_link_resource_id: the resource id that private link links to.
    :vartype private_link_resource_id: str
    :ivar request_message: Request message.
    :vartype request_message: str
    :ivar status: Connection status of the service consumer with the service provider\\r\\nPossible
     state transitions\\r\\nPending -> Approved (Service provider approves the connection
     request)\\r\\nPending -> Rejected (Service provider rejects the connection
     request)\\r\\nPending -> Disconnected (Service provider deletes the connection)\\r\\nApproved
     -> Rejected (Service provider rejects the approved connection)\\r\\nApproved -> Disconnected
     (Service provider deletes the connection)\\r\\nRejected -> Pending (Service consumer
     re-initiates the connection request that was rejected)\\r\\nRejected -> Disconnected (Service
     provider deletes the connection). Known values are: "Approved", "Pending", "Rejected",
     "Disconnected", and "Timeout".
    :vartype status: str or
     ~azure.mgmt.machinelearningservices.models.EndpointServiceConnectionStatus
    """

    group_id: Optional[str] = rest_field(name="groupId", visibility=["read", "create", "update", "delete", "query"])
    """group id of the private link."""
    private_link_resource_id: Optional[str] = rest_field(
        name="privateLinkResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """the resource id that private link links to."""
    request_message: Optional[str] = rest_field(
        name="requestMessage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Request message."""
    status: Optional[Union[str, "_models.EndpointServiceConnectionStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Connection status of the service consumer with the service provider\r\nPossible state
     transitions\r\nPending -> Approved (Service provider approves the connection
     request)\r\nPending -> Rejected (Service provider rejects the connection request)\r\nPending ->
     Disconnected (Service provider deletes the connection)\r\nApproved -> Rejected (Service
     provider rejects the approved connection)\r\nApproved -> Disconnected (Service provider deletes
     the connection)\r\nRejected -> Pending (Service consumer re-initiates the connection request
     that was rejected)\r\nRejected -> Disconnected (Service provider deletes the connection). Known
     values are: \"Approved\", \"Pending\", \"Rejected\", \"Disconnected\", and \"Timeout\"."""

    @overload
    def __init__(
        self,
        *,
        group_id: Optional[str] = None,
        private_link_resource_id: Optional[str] = None,
        request_message: Optional[str] = None,
        status: Optional[Union[str, "_models.EndpointServiceConnectionStatus"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Sku(_Model):
    """The resource model definition representing SKU.

    :ivar name: The name of the SKU. Ex - P3. It is typically a letter+number code. Required.
    :vartype name: str
    :ivar tier: This field is required to be implemented by the Resource Provider if the service
     has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
     "Standard", and "Premium".
    :vartype tier: str or ~azure.mgmt.machinelearningservices.models.SkuTier
    :ivar size: The SKU size. When the name field is the combination of tier and some other value,
     this would be the standalone code.
    :vartype size: str
    :ivar family: If the service has different generations of hardware, for the same SKU, then that
     can be captured here.
    :vartype family: str
    :ivar capacity: If the SKU supports scale out/in then the capacity integer should be included.
     If scale out/in is not possible for the resource this may be omitted.
    :vartype capacity: int
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the SKU. Ex - P3. It is typically a letter+number code. Required."""
    tier: Optional[Union[str, "_models.SkuTier"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """This field is required to be implemented by the Resource Provider if the service has more than
     one tier, but is not required on a PUT. Known values are: \"Free\", \"Basic\", \"Standard\",
     and \"Premium\"."""
    size: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The SKU size. When the name field is the combination of tier and some other value, this would
     be the standalone code."""
    family: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If the service has different generations of hardware, for the same SKU, then that can be
     captured here."""
    capacity: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If the SKU supports scale out/in then the capacity integer should be included. If scale out/in
     is not possible for the resource this may be omitted."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        tier: Optional[Union[str, "_models.SkuTier"]] = None,
        size: Optional[str] = None,
        family: Optional[str] = None,
        capacity: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SkuCapacity(_Model):
    """SKU capacity information.

    :ivar default: Gets or sets the default capacity.
    :vartype default: int
    :ivar maximum: Gets or sets the maximum.
    :vartype maximum: int
    :ivar minimum: Gets or sets the minimum.
    :vartype minimum: int
    :ivar scale_type: Node scaling setting for the compute sku. Known values are: "Automatic",
     "Manual", and "None".
    :vartype scale_type: str or ~azure.mgmt.machinelearningservices.models.SkuScaleType
    """

    default: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the default capacity."""
    maximum: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the maximum."""
    minimum: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the minimum."""
    scale_type: Optional[Union[str, "_models.SkuScaleType"]] = rest_field(
        name="scaleType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node scaling setting for the compute sku. Known values are: \"Automatic\", \"Manual\", and
     \"None\"."""

    @overload
    def __init__(
        self,
        *,
        default: Optional[int] = None,
        maximum: Optional[int] = None,
        minimum: Optional[int] = None,
        scale_type: Optional[Union[str, "_models.SkuScaleType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SkuResource(_Model):
    """Fulfills ARM Contract requirement to list all available SKUS for a resource.

    :ivar capacity: Gets or sets the Sku Capacity.
    :vartype capacity: ~azure.mgmt.machinelearningservices.models.SkuCapacity
    :ivar resource_type: The resource type name.
    :vartype resource_type: str
    :ivar sku: Gets or sets the Sku.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.SkuSetting
    """

    capacity: Optional["_models.SkuCapacity"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the Sku Capacity."""
    resource_type: Optional[str] = rest_field(name="resourceType", visibility=["read"])
    """The resource type name."""
    sku: Optional["_models.SkuSetting"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Gets or sets the Sku."""

    @overload
    def __init__(
        self,
        *,
        capacity: Optional["_models.SkuCapacity"] = None,
        sku: Optional["_models.SkuSetting"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SkuSetting(_Model):
    """SkuSetting fulfills the need for stripped down SKU info in ARM contract.

    :ivar name: [Required] The name of the SKU. Ex - P3. It is typically a letter+number code.
     Required.
    :vartype name: str
    :ivar tier: This field is required to be implemented by the Resource Provider if the service
     has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
     "Standard", and "Premium".
    :vartype tier: str or ~azure.mgmt.machinelearningservices.models.SkuTier
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] The name of the SKU. Ex - P3. It is typically a letter+number code. Required."""
    tier: Optional[Union[str, "_models.SkuTier"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """This field is required to be implemented by the Resource Provider if the service has more than
     one tier, but is not required on a PUT. Known values are: \"Free\", \"Basic\", \"Standard\",
     and \"Premium\"."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        tier: Optional[Union[str, "_models.SkuTier"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SparkJob(JobBaseProperties, discriminator="Spark"):
    """Spark job definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar archives: Archive files used in the job.
    :vartype archives: list[str]
    :ivar args: Arguments for the job.
    :vartype args: str
    :ivar code_id: [Required] arm-id of the code asset. Required.
    :vartype code_id: str
    :ivar conf: Spark configured properties.
    :vartype conf: dict[str, str]
    :ivar entry: [Required] The entry to execute on startup of the job. Required.
    :vartype entry: ~azure.mgmt.machinelearningservices.models.SparkJobEntry
    :ivar environment_id: The ARM resource ID of the Environment specification for the job.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables included in the job.
    :vartype environment_variables: dict[str, str]
    :ivar files: Files used in the job.
    :vartype files: list[str]
    :ivar inputs: Mapping of input data bindings used in the job.
    :vartype inputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobInput]
    :ivar jars: Jar files used in the job.
    :vartype jars: list[str]
    :ivar outputs: Mapping of output data bindings used in the job.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar py_files: Python files used in the job.
    :vartype py_files: list[str]
    :ivar queue_settings: Queue settings for the job.
    :vartype queue_settings: ~azure.mgmt.machinelearningservices.models.QueueSettings
    :ivar resources: Compute Resource configuration for the job.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.SparkResourceConfiguration
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.SPARK
    """

    archives: Optional[list[str]] = rest_field(visibility=["read", "create"])
    """Archive files used in the job."""
    args: Optional[str] = rest_field(visibility=["read", "create"])
    """Arguments for the job."""
    code_id: str = rest_field(name="codeId", visibility=["read", "create"])
    """[Required] arm-id of the code asset. Required."""
    conf: Optional[dict[str, str]] = rest_field(visibility=["read", "create"])
    """Spark configured properties."""
    entry: "_models.SparkJobEntry" = rest_field(visibility=["read", "create"])
    """[Required] The entry to execute on startup of the job. Required."""
    environment_id: Optional[str] = rest_field(name="environmentId", visibility=["read", "create"])
    """The ARM resource ID of the Environment specification for the job."""
    environment_variables: Optional[dict[str, str]] = rest_field(
        name="environmentVariables", visibility=["read", "create"]
    )
    """Environment variables included in the job."""
    files: Optional[list[str]] = rest_field(visibility=["read", "create"])
    """Files used in the job."""
    inputs: Optional[dict[str, "_models.JobInput"]] = rest_field(visibility=["read", "create"])
    """Mapping of input data bindings used in the job."""
    jars: Optional[list[str]] = rest_field(visibility=["read", "create"])
    """Jar files used in the job."""
    outputs: Optional[dict[str, "_models.JobOutput"]] = rest_field(visibility=["read", "create"])
    """Mapping of output data bindings used in the job."""
    py_files: Optional[list[str]] = rest_field(name="pyFiles", visibility=["read", "create"])
    """Python files used in the job."""
    queue_settings: Optional["_models.QueueSettings"] = rest_field(name="queueSettings", visibility=["read", "create"])
    """Queue settings for the job."""
    resources: Optional["_models.SparkResourceConfiguration"] = rest_field(visibility=["read", "create"])
    """Compute Resource configuration for the job."""
    job_type: Literal[JobType.SPARK] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        code_id: str,
        entry: "_models.SparkJobEntry",
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        archives: Optional[list[str]] = None,
        args: Optional[str] = None,
        conf: Optional[dict[str, str]] = None,
        environment_id: Optional[str] = None,
        environment_variables: Optional[dict[str, str]] = None,
        files: Optional[list[str]] = None,
        inputs: Optional[dict[str, "_models.JobInput"]] = None,
        jars: Optional[list[str]] = None,
        outputs: Optional[dict[str, "_models.JobOutput"]] = None,
        py_files: Optional[list[str]] = None,
        queue_settings: Optional["_models.QueueSettings"] = None,
        resources: Optional["_models.SparkResourceConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.SPARK  # type: ignore


class SparkJobEntry(_Model):
    """Spark job entry point definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SparkJobPythonEntry, SparkJobScalaEntry

    :ivar spark_job_entry_type: [Required] Type of the job's entry point. Required. Known values
     are: "SparkJobPythonEntry" and "SparkJobScalaEntry".
    :vartype spark_job_entry_type: str or
     ~azure.mgmt.machinelearningservices.models.SparkJobEntryType
    """

    __mapping__: dict[str, _Model] = {}
    spark_job_entry_type: str = rest_discriminator(name="sparkJobEntryType", visibility=["read", "create"])
    """[Required] Type of the job's entry point. Required. Known values are: \"SparkJobPythonEntry\"
     and \"SparkJobScalaEntry\"."""

    @overload
    def __init__(
        self,
        *,
        spark_job_entry_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SparkJobPythonEntry(SparkJobEntry, discriminator="SparkJobPythonEntry"):
    """SparkJobPythonEntry.

    :ivar file: [Required] Relative python file path for job entry point. Required.
    :vartype file: str
    :ivar spark_job_entry_type: [Required] Type of the job's entry point. Required.
    :vartype spark_job_entry_type: str or
     ~azure.mgmt.machinelearningservices.models.SPARK_JOB_PYTHON_ENTRY
    """

    file: str = rest_field(visibility=["read", "create"])
    """[Required] Relative python file path for job entry point. Required."""
    spark_job_entry_type: Literal[SparkJobEntryType.SPARK_JOB_PYTHON_ENTRY] = rest_discriminator(name="sparkJobEntryType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Type of the job's entry point. Required."""

    @overload
    def __init__(
        self,
        *,
        file: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.spark_job_entry_type = SparkJobEntryType.SPARK_JOB_PYTHON_ENTRY  # type: ignore


class SparkJobScalaEntry(SparkJobEntry, discriminator="SparkJobScalaEntry"):
    """SparkJobScalaEntry.

    :ivar class_name: [Required] Scala class name used as entry point. Required.
    :vartype class_name: str
    :ivar spark_job_entry_type: [Required] Type of the job's entry point. Required.
    :vartype spark_job_entry_type: str or
     ~azure.mgmt.machinelearningservices.models.SPARK_JOB_SCALA_ENTRY
    """

    class_name: str = rest_field(name="className", visibility=["read", "create"])
    """[Required] Scala class name used as entry point. Required."""
    spark_job_entry_type: Literal[SparkJobEntryType.SPARK_JOB_SCALA_ENTRY] = rest_discriminator(name="sparkJobEntryType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Type of the job's entry point. Required."""

    @overload
    def __init__(
        self,
        *,
        class_name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.spark_job_entry_type = SparkJobEntryType.SPARK_JOB_SCALA_ENTRY  # type: ignore


class SparkResourceConfiguration(_Model):
    """SparkResourceConfiguration.

    :ivar instance_type: Optional type of VM used as supported by the compute target.
    :vartype instance_type: str
    :ivar runtime_version: Version of spark runtime used for the job.
    :vartype runtime_version: str
    """

    instance_type: Optional[str] = rest_field(name="instanceType", visibility=["read", "create"])
    """Optional type of VM used as supported by the compute target."""
    runtime_version: Optional[str] = rest_field(name="runtimeVersion", visibility=["read", "create"])
    """Version of spark runtime used for the job."""

    @overload
    def __init__(
        self,
        *,
        instance_type: Optional[str] = None,
        runtime_version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SpeechEndpointDeploymentResourceProperties(
    EndpointDeploymentResourceProperties, discriminator="Azure.Speech"
):  # pylint: disable=name-too-long
    """SpeechEndpointDeploymentResourceProperties.

    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar model: Model used for the endpoint deployment. Required.
    :vartype model: ~azure.mgmt.machinelearningservices.models.EndpointDeploymentModel
    :ivar rai_policy_name: The name of RAI policy.
    :vartype rai_policy_name: str
    :ivar sku:
    :vartype sku: ~azure.mgmt.machinelearningservices.models.CognitiveServicesSku
    :ivar version_upgrade_option: Deployment model version upgrade option. Known values are:
     "OnceNewDefaultVersionAvailable", "OnceCurrentVersionExpired", and "NoAutoUpgrade".
    :vartype version_upgrade_option: str or
     ~azure.mgmt.machinelearningservices.models.DeploymentModelVersionUpgradeOption
    :ivar type: Kind of the deployment. Required. Default value is "Azure.Speech".
    :vartype type: str
    """

    model: "_models.EndpointDeploymentModel" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Model used for the endpoint deployment. Required."""
    rai_policy_name: Optional[str] = rest_field(
        name="raiPolicyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of RAI policy."""
    sku: Optional["_models.CognitiveServicesSku"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    version_upgrade_option: Optional[Union[str, "_models.DeploymentModelVersionUpgradeOption"]] = rest_field(
        name="versionUpgradeOption", visibility=["read", "create", "update", "delete", "query"]
    )
    """Deployment model version upgrade option. Known values are: \"OnceNewDefaultVersionAvailable\",
     \"OnceCurrentVersionExpired\", and \"NoAutoUpgrade\"."""
    type: Literal["Azure.Speech"] = rest_discriminator(name="type", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Kind of the deployment. Required. Default value is \"Azure.Speech\"."""

    @overload
    def __init__(
        self,
        *,
        model: "_models.EndpointDeploymentModel",
        failure_reason: Optional[str] = None,
        rai_policy_name: Optional[str] = None,
        sku: Optional["_models.CognitiveServicesSku"] = None,
        version_upgrade_option: Optional[Union[str, "_models.DeploymentModelVersionUpgradeOption"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.type = "Azure.Speech"  # type: ignore


class SpeechEndpointResourceProperties(EndpointResourceProperties, discriminator="Azure.Speech"):
    """SpeechEndpointResourceProperties.

    :ivar associated_resource_id: Byo resource id for creating the built-in model service
     endpoints.
    :vartype associated_resource_id: str
    :ivar deployments: Deployments info.
    :vartype deployments:
     list[~azure.mgmt.machinelearningservices.models.EndpointDeploymentResourcePropertiesBasicResource]
    :ivar endpoint_uri: Uri of the endpoint.
    :vartype endpoint_uri: str
    :ivar failure_reason: The failure reason if the creation failed.
    :vartype failure_reason: str
    :ivar location: Location of the endpoint.
     Since input dto and when parse endpoint resource share the same contract
     this Location field is just for parse the endpoint resource info
     we won't let customer specify the endpoint resource location since we will create it the same
     location as workspace.
    :vartype location: str
    :ivar name: Name of the endpoint.
    :vartype name: str
    :ivar provisioning_state: Read-only provision state status property. Known values are:
     "NotStarted", "Failed", "Creating", "Updating", "Succeeded", "Deleting", "Accepted",
     "Canceled", "Scaling", and "Disabled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.DefaultResourceProvisioningState
    :ivar should_create_ai_services_endpoint: Whether the proxy (non-byo) endpoint is a regular
     endpoint or a OneKeyV2 AI services account endpoint.
    :vartype should_create_ai_services_endpoint: bool
    :ivar endpoint_type: Type of the endpoint. Required.
    :vartype endpoint_type: str or ~azure.mgmt.machinelearningservices.models.AZURE_SPEECH
    """

    endpoint_type: Literal[EndpointType.AZURE_SPEECH] = rest_discriminator(name="endpointType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Type of the endpoint. Required."""

    @overload
    def __init__(
        self,
        *,
        associated_resource_id: Optional[str] = None,
        deployments: Optional[list["_models.EndpointDeploymentResourcePropertiesBasicResource"]] = None,
        endpoint_uri: Optional[str] = None,
        failure_reason: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        should_create_ai_services_endpoint: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.endpoint_type = EndpointType.AZURE_SPEECH  # type: ignore


class SslConfiguration(_Model):
    """The ssl configuration for scoring.

    :ivar status: Enable or disable ssl for scoring. Known values are: "Disabled", "Enabled", and
     "Auto".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.SslConfigStatus
    :ivar cert: Cert data.
    :vartype cert: str
    :ivar key: Key data.
    :vartype key: str
    :ivar cname: CNAME of the cert.
    :vartype cname: str
    :ivar leaf_domain_label: Leaf domain label of public endpoint.
    :vartype leaf_domain_label: str
    :ivar overwrite_existing_domain: Indicates whether to overwrite existing domain label.
    :vartype overwrite_existing_domain: bool
    """

    status: Optional[Union[str, "_models.SslConfigStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable or disable ssl for scoring. Known values are: \"Disabled\", \"Enabled\", and \"Auto\"."""
    cert: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Cert data."""
    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Key data."""
    cname: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """CNAME of the cert."""
    leaf_domain_label: Optional[str] = rest_field(
        name="leafDomainLabel", visibility=["read", "create", "update", "delete", "query"]
    )
    """Leaf domain label of public endpoint."""
    overwrite_existing_domain: Optional[bool] = rest_field(
        name="overwriteExistingDomain", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether to overwrite existing domain label."""

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.SslConfigStatus"]] = None,
        cert: Optional[str] = None,
        key: Optional[str] = None,
        cname: Optional[str] = None,
        leaf_domain_label: Optional[str] = None,
        overwrite_existing_domain: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StackEnsembleSettings(_Model):
    """Advances setting to customize StackEnsemble run.

    :ivar stack_meta_learner_k_wargs: Optional parameters to pass to the initializer of the
     meta-learner.
    :vartype stack_meta_learner_k_wargs: any
    :ivar stack_meta_learner_train_percentage: Specifies the proportion of the training set (when
     choosing train and validation type of training) to be reserved for training the meta-learner.
     Default value is 0.2.
    :vartype stack_meta_learner_train_percentage: float
    :ivar stack_meta_learner_type: The meta-learner is a model trained on the output of the
     individual heterogeneous models.\\r\\nDefault meta-learners are LogisticRegression for
     classification tasks (or LogisticRegressionCV if cross-validation is enabled) and ElasticNet
     for regression/forecasting tasks (or ElasticNetCV if cross-validation is enabled).\\r\\nThis
     parameter can be one of the following strings: LogisticRegression, LogisticRegressionCV,
     LightGBMClassifier, ElasticNet, ElasticNetCV, LightGBMRegressor, or LinearRegression. Known
     values are: "None", "LogisticRegression", "LogisticRegressionCV", "LightGBMClassifier",
     "ElasticNet", "ElasticNetCV", "LightGBMRegressor", and "LinearRegression".
    :vartype stack_meta_learner_type: str or
     ~azure.mgmt.machinelearningservices.models.StackMetaLearnerType
    """

    stack_meta_learner_k_wargs: Optional[Any] = rest_field(
        name="stackMetaLearnerKWargs", visibility=["read", "create", "update", "delete", "query"]
    )
    """Optional parameters to pass to the initializer of the meta-learner."""
    stack_meta_learner_train_percentage: Optional[float] = rest_field(
        name="stackMetaLearnerTrainPercentage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Specifies the proportion of the training set (when choosing train and validation type of
     training) to be reserved for training the meta-learner. Default value is 0.2."""
    stack_meta_learner_type: Optional[Union[str, "_models.StackMetaLearnerType"]] = rest_field(
        name="stackMetaLearnerType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The meta-learner is a model trained on the output of the individual heterogeneous
     models.\r\nDefault meta-learners are LogisticRegression for classification tasks (or
     LogisticRegressionCV if cross-validation is enabled) and ElasticNet for regression/forecasting
     tasks (or ElasticNetCV if cross-validation is enabled).\r\nThis parameter can be one of the
     following strings: LogisticRegression, LogisticRegressionCV, LightGBMClassifier, ElasticNet,
     ElasticNetCV, LightGBMRegressor, or LinearRegression. Known values are: \"None\",
     \"LogisticRegression\", \"LogisticRegressionCV\", \"LightGBMClassifier\", \"ElasticNet\",
     \"ElasticNetCV\", \"LightGBMRegressor\", and \"LinearRegression\"."""

    @overload
    def __init__(
        self,
        *,
        stack_meta_learner_k_wargs: Optional[Any] = None,
        stack_meta_learner_train_percentage: Optional[float] = None,
        stack_meta_learner_type: Optional[Union[str, "_models.StackMetaLearnerType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StaticInputData(MonitoringInputDataBase, discriminator="Static"):
    """Static input data definition.

    :ivar columns: Mapping of column names to special uses.
    :vartype columns: dict[str, str]
    :ivar data_context: The context metadata of the data source.
    :vartype data_context: str
    :ivar job_input_type: [Required] Specifies the type of job. Required. Known values are:
     "literal", "uri_file", "uri_folder", "mltable", "custom_model", "mlflow_model", and
     "triton_model".
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.JobInputType
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar preprocessing_component_id: Reference to the component asset used to preprocess the data.
    :vartype preprocessing_component_id: str
    :ivar window_end: [Required] The end date of the data window. Required.
    :vartype window_end: ~datetime.datetime
    :ivar window_start: [Required] The start date of the data window. Required.
    :vartype window_start: ~datetime.datetime
    :ivar input_data_type: [Required] Specifies the type of signal to monitor. Required. An input
     data with a fixed window size.
    :vartype input_data_type: str or ~azure.mgmt.machinelearningservices.models.STATIC
    """

    preprocessing_component_id: Optional[str] = rest_field(
        name="preprocessingComponentId", visibility=["read", "create"]
    )
    """Reference to the component asset used to preprocess the data."""
    window_end: datetime.datetime = rest_field(name="windowEnd", visibility=["read", "create"], format="rfc3339")
    """[Required] The end date of the data window. Required."""
    window_start: datetime.datetime = rest_field(name="windowStart", visibility=["read", "create"], format="rfc3339")
    """[Required] The start date of the data window. Required."""
    input_data_type: Literal[MonitoringInputDataType.STATIC] = rest_discriminator(name="inputDataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of signal to monitor. Required. An input data with a fixed window
     size."""

    @overload
    def __init__(
        self,
        *,
        job_input_type: Union[str, "_models.JobInputType"],
        uri: str,
        window_end: datetime.datetime,
        window_start: datetime.datetime,
        columns: Optional[dict[str, str]] = None,
        data_context: Optional[str] = None,
        preprocessing_component_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.input_data_type = MonitoringInputDataType.STATIC  # type: ignore


class StorageAccountDetails(_Model):
    """Details of storage account to be used for the Registry.

    :ivar system_created_storage_account: Details of system created storage account to be used for
     the registry.
    :vartype system_created_storage_account:
     ~azure.mgmt.machinelearningservices.models.SystemCreatedStorageAccount
    """

    system_created_storage_account: Optional["_models.SystemCreatedStorageAccount"] = rest_field(
        name="systemCreatedStorageAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Details of system created storage account to be used for the registry."""

    @overload
    def __init__(
        self,
        *,
        system_created_storage_account: Optional["_models.SystemCreatedStorageAccount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StringStringKeyValuePair(_Model):
    """StringStringKeyValuePair.

    :ivar key:
    :vartype key: str
    :ivar value:
    :vartype value: str
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    value: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        key: Optional[str] = None,
        value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SweepJob(JobBaseProperties, discriminator="Sweep"):
    """Sweep job definition.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar component_id: ARM resource ID of the component resource.
    :vartype component_id: str
    :ivar compute_id: ARM resource ID of the compute resource.
    :vartype compute_id: str
    :ivar display_name: Display name of job.
    :vartype display_name: str
    :ivar experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :vartype experiment_name: str
    :ivar identity: Identity configuration. If set, this should be one of AmlToken,
     ManagedIdentity, UserIdentity or null.
     Defaults to AmlToken if null.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.IdentityConfiguration
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar notification_setting: Notification setting for the job.
    :vartype notification_setting: ~azure.mgmt.machinelearningservices.models.NotificationSetting
    :ivar parent_job_name: Parent job name.
    :vartype parent_job_name: str
    :ivar services: List of JobEndpoints.
     For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
    :vartype services: dict[str, ~azure.mgmt.machinelearningservices.models.JobService]
    :ivar status: Status of the job. Known values are: "NotStarted", "Starting", "Provisioning",
     "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed", "Failed",
     "Canceled", "NotResponding", "Paused", and "Unknown".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.JobStatus
    :ivar early_termination: Early termination policies enable canceling poor-performing runs
     before they complete.
    :vartype early_termination: ~azure.mgmt.machinelearningservices.models.EarlyTerminationPolicy
    :ivar inputs: Mapping of input data bindings used in the job.
    :vartype inputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobInput]
    :ivar limits: Sweep Job limit.
    :vartype limits: ~azure.mgmt.machinelearningservices.models.SweepJobLimits
    :ivar objective: [Required] Optimization objective. Required.
    :vartype objective: ~azure.mgmt.machinelearningservices.models.Objective
    :ivar outputs: Mapping of output data bindings used in the job.
    :vartype outputs: dict[str, ~azure.mgmt.machinelearningservices.models.JobOutput]
    :ivar queue_settings: Queue settings for the job.
    :vartype queue_settings: ~azure.mgmt.machinelearningservices.models.QueueSettings
    :ivar sampling_algorithm: [Required] The hyperparameter sampling algorithm. Required.
    :vartype sampling_algorithm: ~azure.mgmt.machinelearningservices.models.SamplingAlgorithm
    :ivar search_space: [Required] A dictionary containing each parameter and its distribution. The
     dictionary key is the name of the parameter. Required.
    :vartype search_space: dict[str, any]
    :ivar trial: [Required] Trial component definition. Required.
    :vartype trial: ~azure.mgmt.machinelearningservices.models.TrialComponent
    :ivar job_type: [Required] Specifies the type of job. Required.
    :vartype job_type: str or ~azure.mgmt.machinelearningservices.models.SWEEP
    """

    early_termination: Optional["_models.EarlyTerminationPolicy"] = rest_field(
        name="earlyTermination", visibility=["read", "create", "update", "delete", "query"]
    )
    """Early termination policies enable canceling poor-performing runs before they complete."""
    inputs: Optional[dict[str, "_models.JobInput"]] = rest_field(visibility=["read", "create"])
    """Mapping of input data bindings used in the job."""
    limits: Optional["_models.SweepJobLimits"] = rest_field(visibility=["read", "create"])
    """Sweep Job limit."""
    objective: "_models.Objective" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Optimization objective. Required."""
    outputs: Optional[dict[str, "_models.JobOutput"]] = rest_field(visibility=["read", "create"])
    """Mapping of output data bindings used in the job."""
    queue_settings: Optional["_models.QueueSettings"] = rest_field(name="queueSettings", visibility=["read", "create"])
    """Queue settings for the job."""
    sampling_algorithm: "_models.SamplingAlgorithm" = rest_field(
        name="samplingAlgorithm", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] The hyperparameter sampling algorithm. Required."""
    search_space: dict[str, Any] = rest_field(
        name="searchSpace", visibility=["read", "create", "update", "delete", "query"]
    )
    """[Required] A dictionary containing each parameter and its distribution. The dictionary key is
     the name of the parameter. Required."""
    trial: "_models.TrialComponent" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Trial component definition. Required."""
    job_type: Literal[JobType.SWEEP] = rest_discriminator(name="jobType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        objective: "_models.Objective",
        sampling_algorithm: "_models.SamplingAlgorithm",
        search_space: dict[str, Any],
        trial: "_models.TrialComponent",
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        component_id: Optional[str] = None,
        compute_id: Optional[str] = None,
        display_name: Optional[str] = None,
        experiment_name: Optional[str] = None,
        identity: Optional["_models.IdentityConfiguration"] = None,
        is_archived: Optional[bool] = None,
        notification_setting: Optional["_models.NotificationSetting"] = None,
        parent_job_name: Optional[str] = None,
        services: Optional[dict[str, "_models.JobService"]] = None,
        early_termination: Optional["_models.EarlyTerminationPolicy"] = None,
        inputs: Optional[dict[str, "_models.JobInput"]] = None,
        limits: Optional["_models.SweepJobLimits"] = None,
        outputs: Optional[dict[str, "_models.JobOutput"]] = None,
        queue_settings: Optional["_models.QueueSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_type = JobType.SWEEP  # type: ignore


class SweepJobLimits(JobLimits, discriminator="Sweep"):
    """Sweep Job limit class.

    :ivar timeout: The max run duration in ISO 8601 format, after which the job will be cancelled.
     Only supports duration with precision as low as Seconds.
    :vartype timeout: ~datetime.timedelta
    :ivar max_concurrent_trials: Sweep Job max concurrent trials.
    :vartype max_concurrent_trials: int
    :ivar max_total_trials: Sweep Job max total trials.
    :vartype max_total_trials: int
    :ivar trial_timeout: Sweep Job Trial timeout value.
    :vartype trial_timeout: ~datetime.timedelta
    :ivar job_limits_type: [Required] JobLimit type. Required.
    :vartype job_limits_type: str or ~azure.mgmt.machinelearningservices.models.SWEEP
    """

    max_concurrent_trials: Optional[int] = rest_field(
        name="maxConcurrentTrials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sweep Job max concurrent trials."""
    max_total_trials: Optional[int] = rest_field(
        name="maxTotalTrials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sweep Job max total trials."""
    trial_timeout: Optional[datetime.timedelta] = rest_field(
        name="trialTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sweep Job Trial timeout value."""
    job_limits_type: Literal[JobLimitsType.SWEEP] = rest_discriminator(name="jobLimitsType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] JobLimit type. Required."""

    @overload
    def __init__(
        self,
        *,
        timeout: Optional[datetime.timedelta] = None,
        max_concurrent_trials: Optional[int] = None,
        max_total_trials: Optional[int] = None,
        trial_timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_limits_type = JobLimitsType.SWEEP  # type: ignore


class SynapseSpark(Compute, discriminator="SynapseSpark"):
    """A SynapseSpark compute.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties:
    :vartype properties: ~azure.mgmt.machinelearningservices.models.SynapseSparkProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.SYNAPSE_SPARK
    """

    properties: Optional["_models.SynapseSparkProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    compute_type: Literal[ComputeType.SYNAPSE_SPARK] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.SynapseSparkProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.SYNAPSE_SPARK  # type: ignore


class SynapseSparkProperties(_Model):
    """SynapseSparkProperties.

    :ivar auto_scale_properties: Auto scale properties.
    :vartype auto_scale_properties: ~azure.mgmt.machinelearningservices.models.AutoScaleProperties
    :ivar auto_pause_properties: Auto pause properties.
    :vartype auto_pause_properties: ~azure.mgmt.machinelearningservices.models.AutoPauseProperties
    :ivar spark_version: Spark version.
    :vartype spark_version: str
    :ivar node_count: The number of compute nodes currently assigned to the compute.
    :vartype node_count: int
    :ivar node_size: Node size.
    :vartype node_size: str
    :ivar node_size_family: Node size family.
    :vartype node_size_family: str
    :ivar subscription_id: Azure subscription identifier.
    :vartype subscription_id: str
    :ivar resource_group: Name of the resource group in which workspace is located.
    :vartype resource_group: str
    :ivar workspace_name: Name of Azure Machine Learning workspace.
    :vartype workspace_name: str
    :ivar pool_name: Pool name.
    :vartype pool_name: str
    """

    auto_scale_properties: Optional["_models.AutoScaleProperties"] = rest_field(
        name="autoScaleProperties", visibility=["read", "create", "update", "delete", "query"]
    )
    """Auto scale properties."""
    auto_pause_properties: Optional["_models.AutoPauseProperties"] = rest_field(
        name="autoPauseProperties", visibility=["read", "create", "update", "delete", "query"]
    )
    """Auto pause properties."""
    spark_version: Optional[str] = rest_field(
        name="sparkVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """Spark version."""
    node_count: Optional[int] = rest_field(name="nodeCount", visibility=["read", "create", "update", "delete", "query"])
    """The number of compute nodes currently assigned to the compute."""
    node_size: Optional[str] = rest_field(name="nodeSize", visibility=["read", "create", "update", "delete", "query"])
    """Node size."""
    node_size_family: Optional[str] = rest_field(
        name="nodeSizeFamily", visibility=["read", "create", "update", "delete", "query"]
    )
    """Node size family."""
    subscription_id: Optional[str] = rest_field(
        name="subscriptionId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Azure subscription identifier."""
    resource_group: Optional[str] = rest_field(
        name="resourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the resource group in which workspace is located."""
    workspace_name: Optional[str] = rest_field(
        name="workspaceName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of Azure Machine Learning workspace."""
    pool_name: Optional[str] = rest_field(name="poolName", visibility=["read", "create", "update", "delete", "query"])
    """Pool name."""

    @overload
    def __init__(
        self,
        *,
        auto_scale_properties: Optional["_models.AutoScaleProperties"] = None,
        auto_pause_properties: Optional["_models.AutoPauseProperties"] = None,
        spark_version: Optional[str] = None,
        node_count: Optional[int] = None,
        node_size: Optional[str] = None,
        node_size_family: Optional[str] = None,
        subscription_id: Optional[str] = None,
        resource_group: Optional[str] = None,
        workspace_name: Optional[str] = None,
        pool_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemCreatedAcrAccount(_Model):
    """SystemCreatedAcrAccount.

    :ivar acr_account_name: Name of the ACR account.
    :vartype acr_account_name: str
    :ivar acr_account_sku: SKU of the ACR account.
    :vartype acr_account_sku: str
    :ivar arm_resource_id: This is populated once the ACR account is created.
    :vartype arm_resource_id: ~azure.mgmt.machinelearningservices.models.ArmResourceId
    """

    acr_account_name: Optional[str] = rest_field(
        name="acrAccountName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the ACR account."""
    acr_account_sku: Optional[str] = rest_field(
        name="acrAccountSku", visibility=["read", "create", "update", "delete", "query"]
    )
    """SKU of the ACR account."""
    arm_resource_id: Optional["_models.ArmResourceId"] = rest_field(
        name="armResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """This is populated once the ACR account is created."""

    @overload
    def __init__(
        self,
        *,
        acr_account_name: Optional[str] = None,
        acr_account_sku: Optional[str] = None,
        arm_resource_id: Optional["_models.ArmResourceId"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemCreatedStorageAccount(_Model):
    """SystemCreatedStorageAccount.

    :ivar allow_blob_public_access: Public blob access allowed.
    :vartype allow_blob_public_access: bool
    :ivar arm_resource_id: This is populated once the storage account is created.
    :vartype arm_resource_id: ~azure.mgmt.machinelearningservices.models.ArmResourceId
    :ivar storage_account_hns_enabled: HNS enabled for storage account.
    :vartype storage_account_hns_enabled: bool
    :ivar storage_account_name: Name of the storage account.
    :vartype storage_account_name: str
    :ivar storage_account_type: Allowed values:
     "Standard_LRS",
     "Standard_GRS",
     "Standard_RAGRS",
     "Standard_ZRS",
     "Standard_GZRS",
     "Standard_RAGZRS",
     "Premium_LRS",
     "Premium_ZRS".
    :vartype storage_account_type: str
    """

    allow_blob_public_access: Optional[bool] = rest_field(
        name="allowBlobPublicAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Public blob access allowed."""
    arm_resource_id: Optional["_models.ArmResourceId"] = rest_field(
        name="armResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """This is populated once the storage account is created."""
    storage_account_hns_enabled: Optional[bool] = rest_field(
        name="storageAccountHnsEnabled", visibility=["read", "create", "update", "delete", "query"]
    )
    """HNS enabled for storage account."""
    storage_account_name: Optional[str] = rest_field(
        name="storageAccountName", visibility=["read", "create", "update", "delete", "query"]
    )
    """Name of the storage account."""
    storage_account_type: Optional[str] = rest_field(
        name="storageAccountType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allowed values:
     \"Standard_LRS\",
     \"Standard_GRS\",
     \"Standard_RAGRS\",
     \"Standard_ZRS\",
     \"Standard_GZRS\",
     \"Standard_RAGZRS\",
     \"Premium_LRS\",
     \"Premium_ZRS\"."""

    @overload
    def __init__(
        self,
        *,
        allow_blob_public_access: Optional[bool] = None,
        arm_resource_id: Optional["_models.ArmResourceId"] = None,
        storage_account_hns_enabled: Optional[bool] = None,
        storage_account_name: Optional[str] = None,
        storage_account_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemData(_Model):
    """Metadata pertaining to creation and last modification of the resource.

    :ivar created_by: The identity that created the resource.
    :vartype created_by: str
    :ivar created_by_type: The type of identity that created the resource. Known values are:
     "User", "Application", "ManagedIdentity", and "Key".
    :vartype created_by_type: str or ~azure.mgmt.machinelearningservices.models.CreatedByType
    :ivar created_at: The timestamp of resource creation (UTC).
    :vartype created_at: ~datetime.datetime
    :ivar last_modified_by: The identity that last modified the resource.
    :vartype last_modified_by: str
    :ivar last_modified_by_type: The type of identity that last modified the resource. Known values
     are: "User", "Application", "ManagedIdentity", and "Key".
    :vartype last_modified_by_type: str or ~azure.mgmt.machinelearningservices.models.CreatedByType
    :ivar last_modified_at: The timestamp of resource last modification (UTC).
    :vartype last_modified_at: ~datetime.datetime
    """

    created_by: Optional[str] = rest_field(name="createdBy", visibility=["read", "create", "update", "delete", "query"])
    """The identity that created the resource."""
    created_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="createdByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that created the resource. Known values are: \"User\", \"Application\",
     \"ManagedIdentity\", and \"Key\"."""
    created_at: Optional[datetime.datetime] = rest_field(
        name="createdAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource creation (UTC)."""
    last_modified_by: Optional[str] = rest_field(
        name="lastModifiedBy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity that last modified the resource."""
    last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="lastModifiedByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that last modified the resource. Known values are: \"User\",
     \"Application\", \"ManagedIdentity\", and \"Key\"."""
    last_modified_at: Optional[datetime.datetime] = rest_field(
        name="lastModifiedAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource last modification (UTC)."""

    @overload
    def __init__(
        self,
        *,
        created_by: Optional[str] = None,
        created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        created_at: Optional[datetime.datetime] = None,
        last_modified_by: Optional[str] = None,
        last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        last_modified_at: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemService(_Model):
    """A system service running on a compute.

    :ivar system_service_type: The type of this system service.
    :vartype system_service_type: str
    :ivar public_ip_address: Public IP address.
    :vartype public_ip_address: str
    :ivar version: The version for this type.
    :vartype version: str
    """

    system_service_type: Optional[str] = rest_field(name="systemServiceType", visibility=["read"])
    """The type of this system service."""
    public_ip_address: Optional[str] = rest_field(name="publicIpAddress", visibility=["read"])
    """Public IP address."""
    version: Optional[str] = rest_field(visibility=["read"])
    """The version for this type."""


class TableVerticalFeaturizationSettings(FeaturizationSettings):
    """Featurization Configuration.

    :ivar dataset_language: Dataset language, useful for the text data.
    :vartype dataset_language: str
    :ivar blocked_transformers: These transformers shall not be used in featurization.
    :vartype blocked_transformers: list[str or
     ~azure.mgmt.machinelearningservices.models.BlockedTransformers]
    :ivar column_name_and_types: Dictionary of column name and its type (int, float, string,
     datetime etc).
    :vartype column_name_and_types: dict[str, str]
    :ivar enable_dnn_featurization: Determines whether to use Dnn based featurizers for data
     featurization.
    :vartype enable_dnn_featurization: bool
    :ivar mode: Featurization mode - User can keep the default 'Auto' mode and AutoML will take
     care of necessary transformation of the data in featurization phase.
     If 'Off' is selected then no featurization is done.
     If 'Custom' is selected then user can specify additional inputs to customize how featurization
     is done. Known values are: "Auto", "Custom", and "Off".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.FeaturizationMode
    :ivar transformer_params: User can specify additional transformers to be used along with the
     columns to which it would be applied and parameters for the transformer constructor.
    :vartype transformer_params: dict[str,
     list[~azure.mgmt.machinelearningservices.models.ColumnTransformer]]
    """

    blocked_transformers: Optional[list[Union[str, "_models.BlockedTransformers"]]] = rest_field(
        name="blockedTransformers", visibility=["read", "create", "update", "delete", "query"]
    )
    """These transformers shall not be used in featurization."""
    column_name_and_types: Optional[dict[str, str]] = rest_field(
        name="columnNameAndTypes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Dictionary of column name and its type (int, float, string, datetime etc)."""
    enable_dnn_featurization: Optional[bool] = rest_field(
        name="enableDnnFeaturization", visibility=["read", "create", "update", "delete", "query"]
    )
    """Determines whether to use Dnn based featurizers for data featurization."""
    mode: Optional[Union[str, "_models.FeaturizationMode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of
     necessary transformation of the data in featurization phase.
     If 'Off' is selected then no featurization is done.
     If 'Custom' is selected then user can specify additional inputs to customize how featurization
     is done. Known values are: \"Auto\", \"Custom\", and \"Off\"."""
    transformer_params: Optional[dict[str, list["_models.ColumnTransformer"]]] = rest_field(
        name="transformerParams", visibility=["read", "create", "update", "delete", "query"]
    )
    """User can specify additional transformers to be used along with the columns to which it would be
     applied and parameters for the transformer constructor."""

    @overload
    def __init__(
        self,
        *,
        dataset_language: Optional[str] = None,
        blocked_transformers: Optional[list[Union[str, "_models.BlockedTransformers"]]] = None,
        column_name_and_types: Optional[dict[str, str]] = None,
        enable_dnn_featurization: Optional[bool] = None,
        mode: Optional[Union[str, "_models.FeaturizationMode"]] = None,
        transformer_params: Optional[dict[str, list["_models.ColumnTransformer"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TableVerticalLimitSettings(_Model):
    """Job execution constraints.

    :ivar enable_early_termination: Enable early termination, determines whether or not if
     AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
    :vartype enable_early_termination: bool
    :ivar exit_score: Exit score for the AutoML job.
    :vartype exit_score: float
    :ivar max_concurrent_trials: Maximum Concurrent iterations.
    :vartype max_concurrent_trials: int
    :ivar max_cores_per_trial: Max cores per iteration.
    :vartype max_cores_per_trial: int
    :ivar max_trials: Number of iterations.
    :vartype max_trials: int
    :ivar timeout: AutoML job timeout.
    :vartype timeout: ~datetime.timedelta
    :ivar trial_timeout: Iteration timeout.
    :vartype trial_timeout: ~datetime.timedelta
    """

    enable_early_termination: Optional[bool] = rest_field(
        name="enableEarlyTermination", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enable early termination, determines whether or not if AutoMLJob will terminate early if there
     is no score improvement in last 20 iterations."""
    exit_score: Optional[float] = rest_field(
        name="exitScore", visibility=["read", "create", "update", "delete", "query"]
    )
    """Exit score for the AutoML job."""
    max_concurrent_trials: Optional[int] = rest_field(
        name="maxConcurrentTrials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Maximum Concurrent iterations."""
    max_cores_per_trial: Optional[int] = rest_field(
        name="maxCoresPerTrial", visibility=["read", "create", "update", "delete", "query"]
    )
    """Max cores per iteration."""
    max_trials: Optional[int] = rest_field(name="maxTrials", visibility=["read", "create", "update", "delete", "query"])
    """Number of iterations."""
    timeout: Optional[datetime.timedelta] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """AutoML job timeout."""
    trial_timeout: Optional[datetime.timedelta] = rest_field(
        name="trialTimeout", visibility=["read", "create", "update", "delete", "query"]
    )
    """Iteration timeout."""

    @overload
    def __init__(
        self,
        *,
        enable_early_termination: Optional[bool] = None,
        exit_score: Optional[float] = None,
        max_concurrent_trials: Optional[int] = None,
        max_cores_per_trial: Optional[int] = None,
        max_trials: Optional[int] = None,
        timeout: Optional[datetime.timedelta] = None,
        trial_timeout: Optional[datetime.timedelta] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TargetUtilizationScaleSettings(OnlineScaleSettings, discriminator="TargetUtilization"):
    """TargetUtilizationScaleSettings.

    :ivar max_instances: The maximum number of instances that the deployment can scale to. The
     quota will be reserved for max_instances.
    :vartype max_instances: int
    :ivar min_instances: The minimum number of instances to always be present.
    :vartype min_instances: int
    :ivar polling_interval: The polling interval in ISO 8691 format. Only supports duration with
     precision as low as Seconds.
    :vartype polling_interval: ~datetime.timedelta
    :ivar target_utilization_percentage: Target CPU usage for the autoscaler.
    :vartype target_utilization_percentage: int
    :ivar scale_type: [Required] Type of deployment scaling algorithm. Required.
    :vartype scale_type: str or ~azure.mgmt.machinelearningservices.models.TARGET_UTILIZATION
    """

    max_instances: Optional[int] = rest_field(
        name="maxInstances", visibility=["read", "create", "update", "delete", "query"]
    )
    """The maximum number of instances that the deployment can scale to. The quota will be reserved
     for max_instances."""
    min_instances: Optional[int] = rest_field(
        name="minInstances", visibility=["read", "create", "update", "delete", "query"]
    )
    """The minimum number of instances to always be present."""
    polling_interval: Optional[datetime.timedelta] = rest_field(
        name="pollingInterval", visibility=["read", "create", "update", "delete", "query"]
    )
    """The polling interval in ISO 8691 format. Only supports duration with precision as low as
     Seconds."""
    target_utilization_percentage: Optional[int] = rest_field(
        name="targetUtilizationPercentage", visibility=["read", "create", "update", "delete", "query"]
    )
    """Target CPU usage for the autoscaler."""
    scale_type: Literal[ScaleType.TARGET_UTILIZATION] = rest_discriminator(name="scaleType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Type of deployment scaling algorithm. Required."""

    @overload
    def __init__(
        self,
        *,
        max_instances: Optional[int] = None,
        min_instances: Optional[int] = None,
        polling_interval: Optional[datetime.timedelta] = None,
        target_utilization_percentage: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.scale_type = ScaleType.TARGET_UTILIZATION  # type: ignore


class TeacherModelEndpoint(_Model):
    """TeacherModelEndpoint.

    :ivar endpoint_name:
    :vartype endpoint_name: str
    """

    endpoint_name: Optional[str] = rest_field(
        name="endpointName", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        endpoint_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TeacherModelEndpointRequestSettings(_Model):
    """TeacherModelEndpointRequestSettings.

    :ivar min_endpoint_success_ratio:
    :vartype min_endpoint_success_ratio: float
    :ivar request_batch_size:
    :vartype request_batch_size: int
    """

    min_endpoint_success_ratio: Optional[float] = rest_field(
        name="minEndpointSuccessRatio", visibility=["read", "create", "update", "delete", "query"]
    )
    request_batch_size: Optional[int] = rest_field(
        name="requestBatchSize", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        min_endpoint_success_ratio: Optional[float] = None,
        request_batch_size: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TeacherModelSettings(_Model):
    """TeacherModelSettings.

    :ivar teacher_model_endpoint_request_settings: Teacher Model Request Settings.
    :vartype teacher_model_endpoint_request_settings:
     ~azure.mgmt.machinelearningservices.models.TeacherModelEndpointRequestSettings
    :ivar teacher_model_inference_parameters: Teacher Model Inference Settings.
    :vartype teacher_model_inference_parameters: dict[str, str]
    """

    teacher_model_endpoint_request_settings: Optional["_models.TeacherModelEndpointRequestSettings"] = rest_field(
        name="teacherModelEndpointRequestSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Teacher Model Request Settings."""
    teacher_model_inference_parameters: Optional[dict[str, str]] = rest_field(
        name="teacherModelInferenceParameters", visibility=["read", "create", "update", "delete", "query"]
    )
    """Teacher Model Inference Settings."""

    @overload
    def __init__(
        self,
        *,
        teacher_model_endpoint_request_settings: Optional["_models.TeacherModelEndpointRequestSettings"] = None,
        teacher_model_inference_parameters: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TensorFlow(DistributionConfiguration, discriminator="TensorFlow"):
    """TensorFlow distribution configuration.

    :ivar parameter_server_count: Number of parameter server tasks.
    :vartype parameter_server_count: int
    :ivar worker_count: Number of workers. If not specified, will default to the instance count.
    :vartype worker_count: int
    :ivar distribution_type: [Required] Specifies the type of distribution framework. Required.
    :vartype distribution_type: str or ~azure.mgmt.machinelearningservices.models.TENSOR_FLOW
    """

    parameter_server_count: Optional[int] = rest_field(name="parameterServerCount", visibility=["read", "create"])
    """Number of parameter server tasks."""
    worker_count: Optional[int] = rest_field(name="workerCount", visibility=["read", "create"])
    """Number of workers. If not specified, will default to the instance count."""
    distribution_type: Literal[DistributionType.TENSOR_FLOW] = rest_discriminator(name="distributionType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of distribution framework. Required."""

    @overload
    def __init__(
        self,
        *,
        parameter_server_count: Optional[int] = None,
        worker_count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.distribution_type = DistributionType.TENSOR_FLOW  # type: ignore


class TextClassification(AutoMLVertical, discriminator="TextClassification"):
    """Text Classification task in AutoML NLP vertical.
    NLP - Natural Language Processing.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar featurization_settings: Featurization inputs needed for AutoML job.
    :vartype featurization_settings:
     ~azure.mgmt.machinelearningservices.models.NlpVerticalFeaturizationSettings
    :ivar limit_settings: Execution constraints for AutoMLJob.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.NlpVerticalLimitSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar primary_metric: Primary metrics for classification tasks. Known values are:
     "AUCWeighted", "Accuracy", "NormMacroRecall", "AveragePrecisionScoreWeighted", and
     "PrecisionScoreWeighted".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ClassificationPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Text classification (also known
     as text tagging or text categorization) is the process of sorting texts into categories.
     Categories are mutually exclusive.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.TEXT_CLASSIFICATION
    """

    featurization_settings: Optional["_models.NlpVerticalFeaturizationSettings"] = rest_field(
        name="featurizationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization inputs needed for AutoML job."""
    limit_settings: Optional["_models.NlpVerticalLimitSettings"] = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Execution constraints for AutoMLJob."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read", "create", "update", "delete", "query"]
    )
    """Primary metrics for classification tasks. Known values are: \"AUCWeighted\", \"Accuracy\",
     \"NormMacroRecall\", \"AveragePrecisionScoreWeighted\", and \"PrecisionScoreWeighted\"."""
    task_type: Literal[TaskType.TEXT_CLASSIFICATION] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Text classification (also known as text tagging
     or text categorization) is the process of sorting texts into categories.
     Categories are mutually exclusive."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        featurization_settings: Optional["_models.NlpVerticalFeaturizationSettings"] = None,
        limit_settings: Optional["_models.NlpVerticalLimitSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
        primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.TEXT_CLASSIFICATION  # type: ignore


class TextClassificationMultilabel(AutoMLVertical, discriminator="TextClassificationMultilabel"):
    """Text Classification Multilabel task in AutoML NLP vertical.
    NLP - Natural Language Processing.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar featurization_settings: Featurization inputs needed for AutoML job.
    :vartype featurization_settings:
     ~azure.mgmt.machinelearningservices.models.NlpVerticalFeaturizationSettings
    :ivar limit_settings: Execution constraints for AutoMLJob.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.NlpVerticalLimitSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar primary_metric: Primary metric for Text-Classification-Multilabel task.
     Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
     Known values are: "AUCWeighted", "Accuracy", "NormMacroRecall",
     "AveragePrecisionScoreWeighted", "PrecisionScoreWeighted", and "IOU".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ClassificationMultilabelPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Multilabel classification task
     assigns each sample to a group (zero or more) of target labels.
    :vartype task_type: str or
     ~azure.mgmt.machinelearningservices.models.TEXT_CLASSIFICATION_MULTILABEL
    """

    featurization_settings: Optional["_models.NlpVerticalFeaturizationSettings"] = rest_field(
        name="featurizationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization inputs needed for AutoML job."""
    limit_settings: Optional["_models.NlpVerticalLimitSettings"] = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Execution constraints for AutoMLJob."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    primary_metric: Optional[Union[str, "_models.ClassificationMultilabelPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read"]
    )
    """Primary metric for Text-Classification-Multilabel task.
     Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
     Known values are: \"AUCWeighted\", \"Accuracy\", \"NormMacroRecall\",
     \"AveragePrecisionScoreWeighted\", \"PrecisionScoreWeighted\", and \"IOU\"."""
    task_type: Literal[TaskType.TEXT_CLASSIFICATION_MULTILABEL] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Multilabel classification task assigns each
     sample to a group (zero or more) of target labels."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        featurization_settings: Optional["_models.NlpVerticalFeaturizationSettings"] = None,
        limit_settings: Optional["_models.NlpVerticalLimitSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.TEXT_CLASSIFICATION_MULTILABEL  # type: ignore


class TextNer(AutoMLVertical, discriminator="TextNER"):
    """Text-NER task in AutoML NLP vertical.
    NER - Named Entity Recognition.
    NLP - Natural Language Processing.

    :ivar log_verbosity: Enum for setting log verbosity. Known values are: "NotSet", "Debug",
     "Info", "Warning", "Error", and "Critical".
    :vartype log_verbosity: str or ~azure.mgmt.machinelearningservices.models.LogVerbosity
    :ivar target_column_name: Target column name: This is prediction values column.
     Also known as label column name in context of classification tasks.
    :vartype target_column_name: str
    :ivar training_data: [Required] Training data input. Required.
    :vartype training_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar featurization_settings: Featurization inputs needed for AutoML job.
    :vartype featurization_settings:
     ~azure.mgmt.machinelearningservices.models.NlpVerticalFeaturizationSettings
    :ivar limit_settings: Execution constraints for AutoMLJob.
    :vartype limit_settings: ~azure.mgmt.machinelearningservices.models.NlpVerticalLimitSettings
    :ivar validation_data: Validation data inputs.
    :vartype validation_data: ~azure.mgmt.machinelearningservices.models.MLTableJobInput
    :ivar primary_metric: Primary metric for Text-NER task.
     Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly. Known values
     are: "AUCWeighted", "Accuracy", "NormMacroRecall", "AveragePrecisionScoreWeighted", and
     "PrecisionScoreWeighted".
    :vartype primary_metric: str or
     ~azure.mgmt.machinelearningservices.models.ClassificationPrimaryMetrics
    :ivar task_type: [Required] Task type for AutoMLJob. Required. Text Named Entity Recognition
     a.k.a. TextNER.
     Named Entity Recognition (NER) is the ability to take free-form text and identify the
     occurrences of entities such as people, locations, organizations, and more.
    :vartype task_type: str or ~azure.mgmt.machinelearningservices.models.TEXT_NER
    """

    featurization_settings: Optional["_models.NlpVerticalFeaturizationSettings"] = rest_field(
        name="featurizationSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Featurization inputs needed for AutoML job."""
    limit_settings: Optional["_models.NlpVerticalLimitSettings"] = rest_field(
        name="limitSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Execution constraints for AutoMLJob."""
    validation_data: Optional["_models.MLTableJobInput"] = rest_field(
        name="validationData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Validation data inputs."""
    primary_metric: Optional[Union[str, "_models.ClassificationPrimaryMetrics"]] = rest_field(
        name="primaryMetric", visibility=["read"]
    )
    """Primary metric for Text-NER task.
     Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly. Known values
     are: \"AUCWeighted\", \"Accuracy\", \"NormMacroRecall\", \"AveragePrecisionScoreWeighted\", and
     \"PrecisionScoreWeighted\"."""
    task_type: Literal[TaskType.TEXT_NER] = rest_discriminator(name="taskType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Task type for AutoMLJob. Required. Text Named Entity Recognition a.k.a. TextNER.
     Named Entity Recognition (NER) is the ability to take free-form text and identify the
     occurrences of entities such as people, locations, organizations, and more."""

    @overload
    def __init__(
        self,
        *,
        training_data: "_models.MLTableJobInput",
        log_verbosity: Optional[Union[str, "_models.LogVerbosity"]] = None,
        target_column_name: Optional[str] = None,
        featurization_settings: Optional["_models.NlpVerticalFeaturizationSettings"] = None,
        limit_settings: Optional["_models.NlpVerticalLimitSettings"] = None,
        validation_data: Optional["_models.MLTableJobInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.task_type = TaskType.TEXT_NER  # type: ignore


class TmpfsOptions(_Model):
    """TmpfsOptions.

    :ivar size: Mention the Tmpfs size.
    :vartype size: int
    """

    size: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Mention the Tmpfs size."""

    @overload
    def __init__(
        self,
        *,
        size: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TopNFeaturesByAttribution(MonitoringFeatureFilterBase, discriminator="TopNByAttribution"):
    """TopNFeaturesByAttribution.

    :ivar top: The number of top features to include.
    :vartype top: int
    :ivar filter_type: [Required] Specifies the feature filter to leverage when selecting features
     to calculate metrics over. Required. Only includes the top contributing features, measured by
     feature attribution.
    :vartype filter_type: str or ~azure.mgmt.machinelearningservices.models.TOP_N_BY_ATTRIBUTION
    """

    top: Optional[int] = rest_field(visibility=["read", "create"])
    """The number of top features to include."""
    filter_type: Literal[MonitoringFeatureFilterType.TOP_N_BY_ATTRIBUTION] = rest_discriminator(name="filterType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the feature filter to leverage when selecting features to calculate
     metrics over. Required. Only includes the top contributing features, measured by feature
     attribution."""

    @overload
    def __init__(
        self,
        *,
        top: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.filter_type = MonitoringFeatureFilterType.TOP_N_BY_ATTRIBUTION  # type: ignore


class TrialComponent(_Model):
    """Trial component definition.

    :ivar code_id: ARM resource ID of the code asset.
    :vartype code_id: str
    :ivar command: [Required] The command to execute on startup of the job. eg. "python train.py".
     Required.
    :vartype command: str
    :ivar distribution: Distribution configuration of the job. If set, this should be one of Mpi,
     Tensorflow, PyTorch, or null.
    :vartype distribution: ~azure.mgmt.machinelearningservices.models.DistributionConfiguration
    :ivar environment_id: [Required] The ARM resource ID of the Environment specification for the
     job. Required.
    :vartype environment_id: str
    :ivar environment_variables: Environment variables included in the job.
    :vartype environment_variables: dict[str, str]
    :ivar resources: Compute Resource configuration for the job.
    :vartype resources: ~azure.mgmt.machinelearningservices.models.JobResourceConfiguration
    """

    code_id: Optional[str] = rest_field(name="codeId", visibility=["read", "create"])
    """ARM resource ID of the code asset."""
    command: str = rest_field(visibility=["read", "create"])
    """[Required] The command to execute on startup of the job. eg. \"python train.py\". Required."""
    distribution: Optional["_models.DistributionConfiguration"] = rest_field(visibility=["read", "create"])
    """Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch,
     or null."""
    environment_id: str = rest_field(name="environmentId", visibility=["read", "create", "update", "delete", "query"])
    """[Required] The ARM resource ID of the Environment specification for the job. Required."""
    environment_variables: Optional[dict[str, str]] = rest_field(
        name="environmentVariables", visibility=["read", "create"]
    )
    """Environment variables included in the job."""
    resources: Optional["_models.JobResourceConfiguration"] = rest_field(visibility=["read", "create"])
    """Compute Resource configuration for the job."""

    @overload
    def __init__(
        self,
        *,
        command: str,
        environment_id: str,
        code_id: Optional[str] = None,
        distribution: Optional["_models.DistributionConfiguration"] = None,
        environment_variables: Optional[dict[str, str]] = None,
        resources: Optional["_models.JobResourceConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TritonModelJobInput(JobInput, discriminator="triton_model"):
    """TritonModelJobInput.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar mode: Enum to determine the input data delivery mode. Known values are: "ReadOnlyMount",
     "ReadWriteMount", "Download", "Direct", "EvalMount", and "EvalDownload".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.InputDeliveryMode
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.TRITON_MODEL
    """

    mode: Optional[Union[str, "_models.InputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Enum to determine the input data delivery mode. Known values are: \"ReadOnlyMount\",
     \"ReadWriteMount\", \"Download\", \"Direct\", \"EvalMount\", and \"EvalDownload\"."""
    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input Asset URI. Required."""
    job_input_type: Literal[JobInputType.TRITON_MODEL] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        uri: str,
        description: Optional[str] = None,
        mode: Optional[Union[str, "_models.InputDeliveryMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.TRITON_MODEL  # type: ignore


class TritonModelJobOutput(JobOutput, discriminator="triton_model"):
    """TritonModelJobOutput.

    :ivar description: Description for the output.
    :vartype description: str
    :ivar asset_name: Output Asset Name.
    :vartype asset_name: str
    :ivar mode: Output data delivery mode enums. Known values are: "ReadWriteMount", "Upload", and
     "Direct".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.OutputDeliveryMode
    :ivar uri: Output Asset URI.
    :vartype uri: str
    :ivar job_output_type: [Required] Specifies the type of job. Required.
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.TRITON_MODEL
    """

    asset_name: Optional[str] = rest_field(name="assetName", visibility=["read", "create", "update", "delete", "query"])
    """Output Asset Name."""
    mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Output data delivery mode enums. Known values are: \"ReadWriteMount\", \"Upload\", and
     \"Direct\"."""
    uri: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Output Asset URI."""
    job_output_type: Literal[JobOutputType.TRITON_MODEL] = rest_discriminator(name="jobOutputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = None,
        uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_output_type = JobOutputType.TRITON_MODEL  # type: ignore


class TruncationSelectionPolicy(EarlyTerminationPolicy, discriminator="TruncationSelection"):
    """Defines an early termination policy that cancels a given percentage of runs at each evaluation
    interval.

    :ivar delay_evaluation: Number of intervals by which to delay the first evaluation.
    :vartype delay_evaluation: int
    :ivar evaluation_interval: Interval (number of runs) between policy evaluations.
    :vartype evaluation_interval: int
    :ivar truncation_percentage: The percentage of runs to cancel at each evaluation interval.
    :vartype truncation_percentage: int
    :ivar policy_type: [Required] Name of policy configuration. Required.
    :vartype policy_type: str or ~azure.mgmt.machinelearningservices.models.TRUNCATION_SELECTION
    """

    truncation_percentage: Optional[int] = rest_field(
        name="truncationPercentage", visibility=["read", "create", "update", "delete", "query"]
    )
    """The percentage of runs to cancel at each evaluation interval."""
    policy_type: Literal[EarlyTerminationPolicyType.TRUNCATION_SELECTION] = rest_discriminator(name="policyType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Name of policy configuration. Required."""

    @overload
    def __init__(
        self,
        *,
        delay_evaluation: Optional[int] = None,
        evaluation_interval: Optional[int] = None,
        truncation_percentage: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.policy_type = EarlyTerminationPolicyType.TRUNCATION_SELECTION  # type: ignore


class UpdateWorkspaceQuotas(_Model):
    """The properties for update Quota response.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :ivar limit: Limit.
    :vartype limit: int
    :ivar unit: An enum describing the unit of quota measurement. "Count"
    :vartype unit: str or ~azure.mgmt.machinelearningservices.models.QuotaUnit
    :ivar status: Update Workspace Quota Status. Known values are: "Undefined", "Success",
     "Failure", "InvalidQuotaBelowClusterMinimum", "InvalidQuotaExceedsSubscriptionLimit",
     "InvalidVMFamilyName", "OperationNotSupportedForSku", and "OperationNotEnabledForRegion".
    :vartype status: str or ~azure.mgmt.machinelearningservices.models.Status
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Specifies the resource ID."""
    type: Optional[str] = rest_field(visibility=["read"])
    """Specifies the resource type."""
    limit: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Limit."""
    unit: Optional[Union[str, "_models.QuotaUnit"]] = rest_field(visibility=["read"])
    """An enum describing the unit of quota measurement. \"Count\""""
    status: Optional[Union[str, "_models.Status"]] = rest_field(visibility=["read"])
    """Update Workspace Quota Status. Known values are: \"Undefined\", \"Success\", \"Failure\",
     \"InvalidQuotaBelowClusterMinimum\", \"InvalidQuotaExceedsSubscriptionLimit\",
     \"InvalidVMFamilyName\", \"OperationNotSupportedForSku\", and \"OperationNotEnabledForRegion\"."""

    @overload
    def __init__(
        self,
        *,
        limit: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UpdateWorkspaceQuotasResult(_Model):
    """The result of update workspace quota.

    :ivar value: The list of workspace quota update result.
    :vartype value: list[~azure.mgmt.machinelearningservices.models.UpdateWorkspaceQuotas]
    :ivar next_link: The URI to fetch the next page of workspace quota update result. Call
     ListNext() with this to fetch the next page of Workspace Quota update result.
    :vartype next_link: str
    """

    value: Optional[list["_models.UpdateWorkspaceQuotas"]] = rest_field(visibility=["read"])
    """The list of workspace quota update result."""
    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read"])
    """The URI to fetch the next page of workspace quota update result. Call ListNext() with this to
     fetch the next page of Workspace Quota update result."""


class UriFileDataVersion(DataVersionBaseProperties, discriminator="uri_file"):
    """uri-file data version entity.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_uri: [Required] Uri of the data. Example:
     `https://go.microsoft.com/fwlink/?linkid=2202330
     <https://go.microsoft.com/fwlink/?linkid=2202330>`_. Required.
    :vartype data_uri: str
    :ivar data_type: [Required] Specifies the type of data. Required.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.URI_FILE
    """

    data_type: Literal[DataType.URI_FILE] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of data. Required."""

    @overload
    def __init__(
        self,
        *,
        data_uri: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = DataType.URI_FILE  # type: ignore


class UriFileJobInput(JobInput, discriminator="uri_file"):
    """UriFileJobInput.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar mode: Enum to determine the input data delivery mode. Known values are: "ReadOnlyMount",
     "ReadWriteMount", "Download", "Direct", "EvalMount", and "EvalDownload".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.InputDeliveryMode
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.URI_FILE
    """

    mode: Optional[Union[str, "_models.InputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Enum to determine the input data delivery mode. Known values are: \"ReadOnlyMount\",
     \"ReadWriteMount\", \"Download\", \"Direct\", \"EvalMount\", and \"EvalDownload\"."""
    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input Asset URI. Required."""
    job_input_type: Literal[JobInputType.URI_FILE] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        uri: str,
        description: Optional[str] = None,
        mode: Optional[Union[str, "_models.InputDeliveryMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.URI_FILE  # type: ignore


class UriFileJobOutput(JobOutput, discriminator="uri_file"):
    """UriFileJobOutput.

    :ivar description: Description for the output.
    :vartype description: str
    :ivar asset_name: Output Asset Name.
    :vartype asset_name: str
    :ivar mode: Output data delivery mode enums. Known values are: "ReadWriteMount", "Upload", and
     "Direct".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.OutputDeliveryMode
    :ivar uri: Output Asset URI.
    :vartype uri: str
    :ivar job_output_type: [Required] Specifies the type of job. Required.
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.URI_FILE
    """

    asset_name: Optional[str] = rest_field(name="assetName", visibility=["read", "create", "update", "delete", "query"])
    """Output Asset Name."""
    mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Output data delivery mode enums. Known values are: \"ReadWriteMount\", \"Upload\", and
     \"Direct\"."""
    uri: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Output Asset URI."""
    job_output_type: Literal[JobOutputType.URI_FILE] = rest_discriminator(name="jobOutputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = None,
        uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_output_type = JobOutputType.URI_FILE  # type: ignore


class UriFolderDataVersion(DataVersionBaseProperties, discriminator="uri_folder"):
    """uri-folder data version entity.

    :ivar description: The asset description text.
    :vartype description: str
    :ivar properties: The asset property dictionary.
    :vartype properties: dict[str, str]
    :ivar tags: Tag dictionary. Tags can be added, removed, and updated.
    :vartype tags: dict[str, str]
    :ivar is_anonymous: If the name version are system generated (anonymous registration).
    :vartype is_anonymous: bool
    :ivar is_archived: Is the asset archived?.
    :vartype is_archived: bool
    :ivar data_uri: [Required] Uri of the data. Example:
     `https://go.microsoft.com/fwlink/?linkid=2202330
     <https://go.microsoft.com/fwlink/?linkid=2202330>`_. Required.
    :vartype data_uri: str
    :ivar data_type: [Required] Specifies the type of data. Required.
    :vartype data_type: str or ~azure.mgmt.machinelearningservices.models.URI_FOLDER
    """

    data_type: Literal[DataType.URI_FOLDER] = rest_discriminator(name="dataType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of data. Required."""

    @overload
    def __init__(
        self,
        *,
        data_uri: str,
        description: Optional[str] = None,
        properties: Optional[dict[str, str]] = None,
        tags: Optional[dict[str, str]] = None,
        is_anonymous: Optional[bool] = None,
        is_archived: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.data_type = DataType.URI_FOLDER  # type: ignore


class UriFolderJobInput(JobInput, discriminator="uri_folder"):
    """UriFolderJobInput.

    :ivar description: Description for the input.
    :vartype description: str
    :ivar mode: Enum to determine the input data delivery mode. Known values are: "ReadOnlyMount",
     "ReadWriteMount", "Download", "Direct", "EvalMount", and "EvalDownload".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.InputDeliveryMode
    :ivar uri: [Required] Input Asset URI. Required.
    :vartype uri: str
    :ivar job_input_type: [Required] Specifies the type of job. Required.
    :vartype job_input_type: str or ~azure.mgmt.machinelearningservices.models.URI_FOLDER
    """

    mode: Optional[Union[str, "_models.InputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Enum to determine the input data delivery mode. Known values are: \"ReadOnlyMount\",
     \"ReadWriteMount\", \"Download\", \"Direct\", \"EvalMount\", and \"EvalDownload\"."""
    uri: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """[Required] Input Asset URI. Required."""
    job_input_type: Literal[JobInputType.URI_FOLDER] = rest_discriminator(name="jobInputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        uri: str,
        description: Optional[str] = None,
        mode: Optional[Union[str, "_models.InputDeliveryMode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_input_type = JobInputType.URI_FOLDER  # type: ignore


class UriFolderJobOutput(JobOutput, discriminator="uri_folder"):
    """UriFolderJobOutput.

    :ivar description: Description for the output.
    :vartype description: str
    :ivar asset_name: Output Asset Name.
    :vartype asset_name: str
    :ivar mode: Output data delivery mode enums. Known values are: "ReadWriteMount", "Upload", and
     "Direct".
    :vartype mode: str or ~azure.mgmt.machinelearningservices.models.OutputDeliveryMode
    :ivar uri: Output Asset URI.
    :vartype uri: str
    :ivar job_output_type: [Required] Specifies the type of job. Required.
    :vartype job_output_type: str or ~azure.mgmt.machinelearningservices.models.URI_FOLDER
    """

    asset_name: Optional[str] = rest_field(name="assetName", visibility=["read", "create", "update", "delete", "query"])
    """Output Asset Name."""
    mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = rest_field(visibility=["read", "create"])
    """Output data delivery mode enums. Known values are: \"ReadWriteMount\", \"Upload\", and
     \"Direct\"."""
    uri: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Output Asset URI."""
    job_output_type: Literal[JobOutputType.URI_FOLDER] = rest_discriminator(name="jobOutputType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of job. Required."""

    @overload
    def __init__(
        self,
        *,
        description: Optional[str] = None,
        asset_name: Optional[str] = None,
        mode: Optional[Union[str, "_models.OutputDeliveryMode"]] = None,
        uri: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.job_output_type = JobOutputType.URI_FOLDER  # type: ignore


class Usage(_Model):
    """Describes AML Resource Usage.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar aml_workspace_location: Region of the AML workspace in the id.
    :vartype aml_workspace_location: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :ivar unit: An enum describing the unit of usage measurement. "Count"
    :vartype unit: str or ~azure.mgmt.machinelearningservices.models.UsageUnit
    :ivar current_value: The current usage of the resource.
    :vartype current_value: int
    :ivar limit: The maximum permitted usage of the resource.
    :vartype limit: int
    :ivar name: The name of the type of usage.
    :vartype name: ~azure.mgmt.machinelearningservices.models.UsageName
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Specifies the resource ID."""
    aml_workspace_location: Optional[str] = rest_field(name="amlWorkspaceLocation", visibility=["read"])
    """Region of the AML workspace in the id."""
    type: Optional[str] = rest_field(visibility=["read"])
    """Specifies the resource type."""
    unit: Optional[Union[str, "_models.UsageUnit"]] = rest_field(visibility=["read"])
    """An enum describing the unit of usage measurement. \"Count\""""
    current_value: Optional[int] = rest_field(name="currentValue", visibility=["read"])
    """The current usage of the resource."""
    limit: Optional[int] = rest_field(visibility=["read"])
    """The maximum permitted usage of the resource."""
    name: Optional["_models.UsageName"] = rest_field(visibility=["read"])
    """The name of the type of usage."""


class UsageAndQuotaDetails(_Model):
    """UsageAndQuotaDetails.

    :ivar model_collection: Model collection name.
    :vartype model_collection: str
    :ivar quota: The total number of quota.
    :vartype quota: int
    :ivar usage_details: Usage details for each deployment.
    :vartype usage_details: list[~azure.mgmt.machinelearningservices.models.PTUDeploymentUsage]
    """

    model_collection: Optional[str] = rest_field(
        name="modelCollection", visibility=["read", "create", "update", "delete", "query"]
    )
    """Model collection name."""
    quota: Optional[int] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The total number of quota."""
    usage_details: Optional[list["_models.PTUDeploymentUsage"]] = rest_field(
        name="usageDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """Usage details for each deployment."""

    @overload
    def __init__(
        self,
        *,
        model_collection: Optional[str] = None,
        quota: Optional[int] = None,
        usage_details: Optional[list["_models.PTUDeploymentUsage"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UsageName(_Model):
    """The Usage Names.

    :ivar value: The name of the resource.
    :vartype value: str
    :ivar localized_value: The localized name of the resource.
    :vartype localized_value: str
    """

    value: Optional[str] = rest_field(visibility=["read"])
    """The name of the resource."""
    localized_value: Optional[str] = rest_field(name="localizedValue", visibility=["read"])
    """The localized name of the resource."""


class UserAccountCredentials(_Model):
    """Settings for user account that gets created on each on the nodes of a compute.

    :ivar admin_user_name: User name. Required.
    :vartype admin_user_name: str
    :ivar admin_user_ssh_public_key: SSH public key.
    :vartype admin_user_ssh_public_key: str
    :ivar admin_user_password: Password.
    :vartype admin_user_password: str
    """

    admin_user_name: str = rest_field(name="adminUserName", visibility=["read", "create", "update", "delete", "query"])
    """User name. Required."""
    admin_user_ssh_public_key: Optional[str] = rest_field(
        name="adminUserSshPublicKey", visibility=["read", "create", "update", "delete", "query"]
    )
    """SSH public key."""
    admin_user_password: Optional[str] = rest_field(
        name="adminUserPassword", visibility=["read", "create", "update", "delete", "query"]
    )
    """Password."""

    @overload
    def __init__(
        self,
        *,
        admin_user_name: str,
        admin_user_ssh_public_key: Optional[str] = None,
        admin_user_password: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserAssignedIdentity(_Model):
    """User assigned identity properties.

    :ivar principal_id: The principal ID of the assigned identity.
    :vartype principal_id: str
    :ivar client_id: The client ID of the assigned identity.
    :vartype client_id: str
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The principal ID of the assigned identity."""
    client_id: Optional[str] = rest_field(name="clientId", visibility=["read"])
    """The client ID of the assigned identity."""


class UserIdentity(IdentityConfiguration, discriminator="UserIdentity"):
    """User identity configuration.

    :ivar identity_type: [Required] Specifies the type of identity framework. Required.
    :vartype identity_type: str or ~azure.mgmt.machinelearningservices.models.USER_IDENTITY
    """

    identity_type: Literal[IdentityConfigurationType.USER_IDENTITY] = rest_discriminator(name="identityType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """[Required] Specifies the type of identity framework. Required."""

    @overload
    def __init__(
        self,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.identity_type = IdentityConfigurationType.USER_IDENTITY  # type: ignore


class UsernamePasswordAuthTypeWorkspaceConnectionProperties(
    WorkspaceConnectionPropertiesV2, discriminator="UsernamePassword"
):  # pylint: disable=name-too-long
    """UsernamePasswordAuthTypeWorkspaceConnectionProperties.

    :ivar category: Category of the connection. Known values are: "PythonFeed",
     "ContainerRegistry", "Git", "S3", "Snowflake", "AzureKeyVault", "AzureSqlDb",
     "AzureSynapseAnalytics", "AzureMySqlDb", "AzurePostgresDb", "ADLSGen2",
     "AzureContainerAppEnvironment", "Redis", "ApiKey", "AzureOpenAI", "AIServices",
     "CognitiveSearch", "CognitiveService", "CustomKeys", "AzureBlob", "AzureStorageAccount",
     "AzureOneLake", "CosmosDb", "CosmosDbMongoDbApi", "AzureDataExplorer", "AzureMariaDb",
     "AzureDatabricksDeltaLake", "AzureSqlMi", "AzureTableStorage", "AmazonRdsForOracle",
     "AmazonRdsForSqlServer", "AmazonRedshift", "Db2", "Drill", "GoogleBigQuery", "Greenplum",
     "Hbase", "Hive", "Impala", "Informix", "MariaDb", "MicrosoftAccess", "MySql", "Netezza",
     "Oracle", "Phoenix", "PostgreSql", "Presto", "SapOpenHub", "SapBw", "SapHana", "SapTable",
     "Spark", "SqlServer", "Sybase", "Teradata", "Vertica", "Pinecone", "Databricks", "Cassandra",
     "Couchbase", "MongoDbV2", "MongoDbAtlas", "AmazonS3Compatible", "FileServer", "FtpServer",
     "GoogleCloudStorage", "Hdfs", "OracleCloudStorage", "Sftp", "GenericHttp", "ODataRest", "Odbc",
     "GenericRest", "RemoteTool", "AmazonMws", "Concur", "Dynamics", "DynamicsAx", "DynamicsCrm",
     "GoogleAdWords", "Hubspot", "Jira", "Magento", "Marketo", "Office365", "Eloqua", "Responsys",
     "OracleServiceCloud", "PayPal", "QuickBooks", "Salesforce", "SalesforceServiceCloud",
     "SalesforceMarketingCloud", "SapCloudForCustomer", "SapEcc", "ServiceNow",
     "SharePointOnlineList", "Shopify", "Square", "WebTable", "Xero", "Zoho",
     "GenericContainerRegistry", "Elasticsearch", "AppInsights", "AppConfig", "OpenAI", "Serp",
     "BingLLMSearch", "Serverless", "ManagedOnlineEndpoint", "ApiManagement", "ModelGateway",
     "GroundingWithBingSearch", "GroundingWithCustomSearch", "Sharepoint", "MicrosoftFabric",
     "PowerPlatformEnvironment", and "RemoteA2A".
    :vartype category: str or ~azure.mgmt.machinelearningservices.models.ConnectionCategory
    :ivar created_by_workspace_arm_id:
    :vartype created_by_workspace_arm_id: str
    :ivar error:
    :vartype error: str
    :ivar expiry_time:
    :vartype expiry_time: ~datetime.datetime
    :ivar group: Group based on connection category. Known values are: "Azure", "AzureAI",
     "Database", "NoSQL", "File", "GenericProtocol", and "ServicesAndApps".
    :vartype group: str or ~azure.mgmt.machinelearningservices.models.ConnectionGroup
    :ivar is_shared_to_all:
    :vartype is_shared_to_all: bool
    :ivar metadata: Store user metadata for this connection.
    :vartype metadata: dict[str, str]
    :ivar pe_requirement: Known values are: "Required", "NotRequired", and "NotApplicable".
    :vartype pe_requirement: str or ~azure.mgmt.machinelearningservices.models.ManagedPERequirement
    :ivar pe_status: Known values are: "Inactive", "Active", and "NotApplicable".
    :vartype pe_status: str or ~azure.mgmt.machinelearningservices.models.ManagedPEStatus
    :ivar shared_user_list:
    :vartype shared_user_list: list[str]
    :ivar target:
    :vartype target: str
    :ivar use_workspace_managed_identity:
    :vartype use_workspace_managed_identity: bool
    :ivar credentials:
    :vartype credentials:
     ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionUsernamePassword
    :ivar auth_type: Authentication type of the connection target. Required.
    :vartype auth_type: str or ~azure.mgmt.machinelearningservices.models.USERNAME_PASSWORD
    """

    credentials: Optional["_models.WorkspaceConnectionUsernamePassword"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    auth_type: Literal[ConnectionAuthType.USERNAME_PASSWORD] = rest_discriminator(name="authType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Authentication type of the connection target. Required."""

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.ConnectionCategory"]] = None,
        error: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_shared_to_all: Optional[bool] = None,
        metadata: Optional[dict[str, str]] = None,
        pe_requirement: Optional[Union[str, "_models.ManagedPERequirement"]] = None,
        pe_status: Optional[Union[str, "_models.ManagedPEStatus"]] = None,
        shared_user_list: Optional[list[str]] = None,
        target: Optional[str] = None,
        use_workspace_managed_identity: Optional[bool] = None,
        credentials: Optional["_models.WorkspaceConnectionUsernamePassword"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.auth_type = ConnectionAuthType.USERNAME_PASSWORD  # type: ignore


class VirtualMachine(Compute, discriminator="VirtualMachine"):
    """A Machine Learning compute based on Azure Virtual Machines.

    :ivar compute_location: Location for the underlying compute.
    :vartype compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Known values are: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar description: The description of the Machine Learning compute.
    :vartype description: str
    :ivar created_on: The time at which the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The time at which the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :ivar resource_id: ARM resource id of the underlying compute.
    :vartype resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors: list[~azure.mgmt.machinelearningservices.models.ErrorResponse]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :ivar disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI
     and AAD exclusively for authentication.
    :vartype disable_local_auth: bool
    :ivar properties:
    :vartype properties: ~azure.mgmt.machinelearningservices.models.VirtualMachineSchemaProperties
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.VIRTUAL_MACHINE
    """

    properties: Optional["_models.VirtualMachineSchemaProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    compute_type: Literal[ComputeType.VIRTUAL_MACHINE] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        disable_local_auth: Optional[bool] = None,
        properties: Optional["_models.VirtualMachineSchemaProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.VIRTUAL_MACHINE  # type: ignore


class VirtualMachineImage(_Model):
    """Virtual Machine image for Windows AML Compute.

    :ivar id: Virtual Machine image path. Required.
    :vartype id: str
    """

    id: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Virtual Machine image path. Required."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VirtualMachineSchemaProperties(_Model):
    """VirtualMachineSchemaProperties.

    :ivar virtual_machine_size: Virtual Machine size.
    :vartype virtual_machine_size: str
    :ivar ssh_port: Port open for ssh connections.
    :vartype ssh_port: int
    :ivar notebook_server_port: Notebook server port open for ssh connections.
    :vartype notebook_server_port: int
    :ivar address: Public IP address of the virtual machine.
    :vartype address: str
    :ivar administrator_account: Admin credentials for virtual machine.
    :vartype administrator_account:
     ~azure.mgmt.machinelearningservices.models.VirtualMachineSshCredentials
    :ivar is_notebook_instance_compute: Indicates whether this compute will be used for running
     notebooks.
    :vartype is_notebook_instance_compute: bool
    """

    virtual_machine_size: Optional[str] = rest_field(
        name="virtualMachineSize", visibility=["read", "create", "update", "delete", "query"]
    )
    """Virtual Machine size."""
    ssh_port: Optional[int] = rest_field(name="sshPort", visibility=["read", "create", "update", "delete", "query"])
    """Port open for ssh connections."""
    notebook_server_port: Optional[int] = rest_field(
        name="notebookServerPort", visibility=["read", "create", "update", "delete", "query"]
    )
    """Notebook server port open for ssh connections."""
    address: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Public IP address of the virtual machine."""
    administrator_account: Optional["_models.VirtualMachineSshCredentials"] = rest_field(
        name="administratorAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Admin credentials for virtual machine."""
    is_notebook_instance_compute: Optional[bool] = rest_field(
        name="isNotebookInstanceCompute", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates whether this compute will be used for running notebooks."""

    @overload
    def __init__(
        self,
        *,
        virtual_machine_size: Optional[str] = None,
        ssh_port: Optional[int] = None,
        notebook_server_port: Optional[int] = None,
        address: Optional[str] = None,
        administrator_account: Optional["_models.VirtualMachineSshCredentials"] = None,
        is_notebook_instance_compute: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VirtualMachineSecrets(ComputeSecrets, discriminator="VirtualMachine"):
    """Secrets related to a Machine Learning compute based on AKS.

    :ivar administrator_account: Admin credentials for virtual machine.
    :vartype administrator_account:
     ~azure.mgmt.machinelearningservices.models.VirtualMachineSshCredentials
    :ivar compute_type: The type of compute. Required.
    :vartype compute_type: str or ~azure.mgmt.machinelearningservices.models.VIRTUAL_MACHINE
    """

    administrator_account: Optional["_models.VirtualMachineSshCredentials"] = rest_field(
        name="administratorAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """Admin credentials for virtual machine."""
    compute_type: Literal[ComputeType.VIRTUAL_MACHINE] = rest_discriminator(name="computeType", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """The type of compute. Required."""

    @overload
    def __init__(
        self,
        *,
        administrator_account: Optional["_models.VirtualMachineSshCredentials"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.compute_type = ComputeType.VIRTUAL_MACHINE  # type: ignore


class VirtualMachineSize(_Model):
    """Describes the properties of a VM size.

    :ivar name: Virtual Machine size name.
    :vartype name: str
    :ivar family: Virtual Machine family name.
    :vartype family: str
    :ivar v_cp_us: Number of vPUs.
    :vartype v_cp_us: int
    :ivar gpus: Number of gPUs.
    :vartype gpus: int
    :ivar os_vhd_size_mb: OS VHD Disk size.
    :vartype os_vhd_size_mb: int
    :ivar max_resource_volume_mb: Resource volume size.
    :vartype max_resource_volume_mb: int
    :ivar memory_gb: Memory size.
    :vartype memory_gb: float
    :ivar low_priority_capable: Low priority capable.
    :vartype low_priority_capable: bool
    :ivar premium_io: Premium IO supported.
    :vartype premium_io: bool
    :ivar estimated_vm_prices: Estimated VM prices.
    :vartype estimated_vm_prices: ~azure.mgmt.machinelearningservices.models.EstimatedVMPrices
    :ivar supported_compute_types: Supported Compute Types.
    :vartype supported_compute_types: list[str]
    """

    name: Optional[str] = rest_field(visibility=["read"])
    """Virtual Machine size name."""
    family: Optional[str] = rest_field(visibility=["read"])
    """Virtual Machine family name."""
    v_cp_us: Optional[int] = rest_field(name="vCPUs", visibility=["read"])
    """Number of vPUs."""
    gpus: Optional[int] = rest_field(visibility=["read"])
    """Number of gPUs."""
    os_vhd_size_mb: Optional[int] = rest_field(name="osVhdSizeMB", visibility=["read"])
    """OS VHD Disk size."""
    max_resource_volume_mb: Optional[int] = rest_field(name="maxResourceVolumeMB", visibility=["read"])
    """Resource volume size."""
    memory_gb: Optional[float] = rest_field(name="memoryGB", visibility=["read"])
    """Memory size."""
    low_priority_capable: Optional[bool] = rest_field(name="lowPriorityCapable", visibility=["read"])
    """Low priority capable."""
    premium_io: Optional[bool] = rest_field(name="premiumIO", visibility=["read"])
    """Premium IO supported."""
    estimated_vm_prices: Optional["_models.EstimatedVMPrices"] = rest_field(
        name="estimatedVMPrices", visibility=["read", "create", "update", "delete", "query"]
    )
    """Estimated VM prices."""
    supported_compute_types: Optional[list[str]] = rest_field(
        name="supportedComputeTypes", visibility=["read", "create", "update", "delete", "query"]
    )
    """Supported Compute Types."""

    @overload
    def __init__(
        self,
        *,
        estimated_vm_prices: Optional["_models.EstimatedVMPrices"] = None,
        supported_compute_types: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VirtualMachineSizeListResult(_Model):
    """The List Virtual Machine size operation response.

    :ivar value: The list of virtual machine sizes supported by AmlCompute.
    :vartype value: list[~azure.mgmt.machinelearningservices.models.VirtualMachineSize]
    """

    value: Optional[list["_models.VirtualMachineSize"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of virtual machine sizes supported by AmlCompute."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[list["_models.VirtualMachineSize"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VirtualMachineSshCredentials(_Model):
    """Admin credentials for virtual machine.

    :ivar username: Username of admin account.
    :vartype username: str
    :ivar password: Password of admin account.
    :vartype password: str
    :ivar public_key_data: Public key data.
    :vartype public_key_data: str
    :ivar private_key_data: Private key data.
    :vartype private_key_data: str
    """

    username: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Username of admin account."""
    password: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Password of admin account."""
    public_key_data: Optional[str] = rest_field(
        name="publicKeyData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Public key data."""
    private_key_data: Optional[str] = rest_field(
        name="privateKeyData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Private key data."""

    @overload
    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        public_key_data: Optional[str] = None,
        private_key_data: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolumeDefinition(_Model):
    """VolumeDefinition.

    :ivar type: Type of Volume Definition. Known values are: "bind", "volume", "tmpfs", and
     "npipe".
    :vartype type: str or ~azure.mgmt.machinelearningservices.models.VolumeDefinitionType
    :ivar read_only: Indicate whether to mount volume as readOnly. Default value for this is false.
    :vartype read_only: bool
    :ivar source: Source of the mount. For bind mounts this is the host path.
    :vartype source: str
    :ivar target: Target of the mount. For bind mounts this is the path in the container.
    :vartype target: str
    :ivar consistency: Consistency of the volume.
    :vartype consistency: str
    :ivar bind: Bind Options of the mount.
    :vartype bind: ~azure.mgmt.machinelearningservices.models.BindOptions
    :ivar volume: Volume Options of the mount.
    :vartype volume: ~azure.mgmt.machinelearningservices.models.VolumeOptions
    :ivar tmpfs: tmpfs option of the mount.
    :vartype tmpfs: ~azure.mgmt.machinelearningservices.models.TmpfsOptions
    """

    type: Optional[Union[str, "_models.VolumeDefinitionType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of Volume Definition. Known values are: \"bind\", \"volume\", \"tmpfs\", and \"npipe\"."""
    read_only: Optional[bool] = rest_field(name="readOnly", visibility=["read", "create", "update", "delete", "query"])
    """Indicate whether to mount volume as readOnly. Default value for this is false."""
    source: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Source of the mount. For bind mounts this is the host path."""
    target: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Target of the mount. For bind mounts this is the path in the container."""
    consistency: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Consistency of the volume."""
    bind: Optional["_models.BindOptions"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Bind Options of the mount."""
    volume: Optional["_models.VolumeOptions"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Volume Options of the mount."""
    tmpfs: Optional["_models.TmpfsOptions"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """tmpfs option of the mount."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.VolumeDefinitionType"]] = None,
        read_only: Optional[bool] = None,
        source: Optional[str] = None,
        target: Optional[str] = None,
        consistency: Optional[str] = None,
        bind: Optional["_models.BindOptions"] = None,
        volume: Optional["_models.VolumeOptions"] = None,
        tmpfs: Optional["_models.TmpfsOptions"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolumeOptions(_Model):
    """VolumeOptions.

    :ivar nocopy: Indicate whether volume is nocopy.
    :vartype nocopy: bool
    """

    nocopy: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicate whether volume is nocopy."""

    @overload
    def __init__(
        self,
        *,
        nocopy: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VulnerabilityDetails(_Model):
    """VulnerabilityDetails.

    :ivar cve: CVE id.
    :vartype cve: str
    :ivar cve_url: CVE url.
    :vartype cve_url: str
    :ivar due_date: DueDate for vulnerability. Provider data or PublishDate + 30 days.
    :vartype due_date: ~datetime.datetime
    :ivar id: Vulnerability ID.
    :vartype id: str
    :ivar package_details: Dependency details.
    :vartype package_details: list[~azure.mgmt.machinelearningservices.models.PackageDetails]
    :ivar patchable: Indicates if there is a known patch for vulnerability.
    :vartype patchable: bool
    :ivar provider_id: Vulnerability ID from provider.
    :vartype provider_id: str
    :ivar publish_date: Vulnerability publish date.
    :vartype publish_date: ~datetime.datetime
    :ivar risk: Vulnerability Risk value. Known values are: "UNKNOWN", "CRITICAL", "HIGH",
     "MEDIUM", and "LOW".
    :vartype risk: str or ~azure.mgmt.machinelearningservices.models.VulnerabilityRisk
    :ivar solution: Vulnerability description.
    :vartype solution: str
    :ivar title: Vulnerability name.
    :vartype title: str
    :ivar vendor_id: Vendor vulnerability ID (USN, GH Advisory, etc).
    :vartype vendor_id: str
    :ivar vendor_url: Vendor vulnerability url.
    :vartype vendor_url: str
    """

    cve: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """CVE id."""
    cve_url: Optional[str] = rest_field(name="cveUrl", visibility=["read", "create", "update", "delete", "query"])
    """CVE url."""
    due_date: Optional[datetime.datetime] = rest_field(
        name="dueDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """DueDate for vulnerability. Provider data or PublishDate + 30 days."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Vulnerability ID."""
    package_details: Optional[list["_models.PackageDetails"]] = rest_field(
        name="packageDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """Dependency details."""
    patchable: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Indicates if there is a known patch for vulnerability."""
    provider_id: Optional[str] = rest_field(
        name="providerId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Vulnerability ID from provider."""
    publish_date: Optional[datetime.datetime] = rest_field(
        name="publishDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Vulnerability publish date."""
    risk: Optional[Union[str, "_models.VulnerabilityRisk"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Vulnerability Risk value. Known values are: \"UNKNOWN\", \"CRITICAL\", \"HIGH\", \"MEDIUM\",
     and \"LOW\"."""
    solution: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Vulnerability description."""
    title: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Vulnerability name."""
    vendor_id: Optional[str] = rest_field(name="vendorId", visibility=["read", "create", "update", "delete", "query"])
    """Vendor vulnerability ID (USN, GH Advisory, etc)."""
    vendor_url: Optional[str] = rest_field(name="vendorUrl", visibility=["read", "create", "update", "delete", "query"])
    """Vendor vulnerability url."""

    @overload
    def __init__(
        self,
        *,
        cve: Optional[str] = None,
        cve_url: Optional[str] = None,
        due_date: Optional[datetime.datetime] = None,
        package_details: Optional[list["_models.PackageDetails"]] = None,
        patchable: Optional[bool] = None,
        provider_id: Optional[str] = None,
        publish_date: Optional[datetime.datetime] = None,
        risk: Optional[Union[str, "_models.VulnerabilityRisk"]] = None,
        solution: Optional[str] = None,
        title: Optional[str] = None,
        vendor_id: Optional[str] = None,
        vendor_url: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VulnerabilityFindings(_Model):
    """VulnerabilityFindings.

    :ivar asset_id: AssetId (Image digest).
    :vartype asset_id: str
    :ivar critical_findings_count: Number of critical findings.
    :vartype critical_findings_count: int
    :ivar data: List of vulnerability findings.
    :vartype data: list[~azure.mgmt.machinelearningservices.models.VulnerabilityDetails]
    :ivar generated_time: Time the report was generated.
    :vartype generated_time: ~datetime.datetime
    :ivar high_findings_count: Number of high findings.
    :vartype high_findings_count: int
    :ivar last_scan_date: Scan result date.
    :vartype last_scan_date: ~datetime.datetime
    :ivar scanner: Vulnerability scanner name.
    :vartype scanner: str
    :ivar source: Data source (internal).
    :vartype source: str
    :ivar total_findings_count: Total findings count.
    :vartype total_findings_count: int
    """

    asset_id: Optional[str] = rest_field(name="assetId", visibility=["read", "create", "update", "delete", "query"])
    """AssetId (Image digest)."""
    critical_findings_count: Optional[int] = rest_field(name="criticalFindingsCount", visibility=["read"])
    """Number of critical findings."""
    data: Optional[list["_models.VulnerabilityDetails"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """List of vulnerability findings."""
    generated_time: Optional[datetime.datetime] = rest_field(
        name="generatedTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Time the report was generated."""
    high_findings_count: Optional[int] = rest_field(name="highFindingsCount", visibility=["read"])
    """Number of high findings."""
    last_scan_date: Optional[datetime.datetime] = rest_field(
        name="lastScanDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Scan result date."""
    scanner: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Vulnerability scanner name."""
    source: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Data source (internal)."""
    total_findings_count: Optional[int] = rest_field(name="totalFindingsCount", visibility=["read"])
    """Total findings count."""

    @overload
    def __init__(
        self,
        *,
        asset_id: Optional[str] = None,
        data: Optional[list["_models.VulnerabilityDetails"]] = None,
        generated_time: Optional[datetime.datetime] = None,
        last_scan_date: Optional[datetime.datetime] = None,
        scanner: Optional[str] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Workspace(ProxyResource):
    """An object that represents a machine learning workspace.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Additional attributes of the entity. Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.WorkspaceProperties
    :ivar identity: The managed service identities assigned to this resource.
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar kind:
    :vartype kind: str
    :ivar location:
    :vartype location: str
    :ivar sku: Optional. This field is required to be implemented by the RP because AML is
     supporting more than one tier.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    :ivar tags:
    :vartype tags: dict[str, str]
    """

    properties: "_models.WorkspaceProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Additional attributes of the entity. Required."""
    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The managed service identities assigned to this resource."""
    kind: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    location: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional. This field is required to be implemented by the RP because AML is supporting more
     than one tier."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    __flattened_items = [
        "agents_endpoint_uri",
        "allow_public_access_when_behind_vnet",
        "allow_role_assignment_on_rg",
        "application_insights",
        "associated_workspaces",
        "container_registries",
        "container_registry",
        "description",
        "discovery_url",
        "enable_data_isolation",
        "enable_service_side_cmk_encryption",
        "enable_simplified_cmk",
        "enable_software_bill_of_materials",
        "encryption",
        "existing_workspaces",
        "feature_store_settings",
        "friendly_name",
        "hbi_workspace",
        "hub_resource_id",
        "image_build_compute",
        "ip_allowlist",
        "key_vault",
        "key_vaults",
        "managed_network",
        "ml_flow_tracking_uri",
        "network_acls",
        "notebook_info",
        "primary_user_assigned_identity",
        "private_endpoint_connections",
        "private_link_count",
        "provision_network_now",
        "provisioning_state",
        "public_network_access",
        "serverless_compute_settings",
        "service_managed_resources_settings",
        "service_provisioned_resource_group",
        "shared_private_link_resources",
        "soft_delete_retention_in_days",
        "storage_account",
        "storage_accounts",
        "storage_hns_enabled",
        "system_datastores_auth_mode",
        "tenant_id",
        "v1_legacy_mode",
        "workspace_hub_config",
        "workspace_id",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: "_models.WorkspaceProperties",
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        kind: Optional[str] = None,
        location: Optional[str] = None,
        sku: Optional["_models.Sku"] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class WorkspaceConnectionAccessKey(_Model):
    """WorkspaceConnectionAccessKey.

    :ivar access_key_id:
    :vartype access_key_id: str
    :ivar secret_access_key:
    :vartype secret_access_key: str
    """

    access_key_id: Optional[str] = rest_field(
        name="accessKeyId", visibility=["read", "create", "update", "delete", "query"]
    )
    secret_access_key: Optional[str] = rest_field(
        name="secretAccessKey", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        access_key_id: Optional[str] = None,
        secret_access_key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionAccountKey(_Model):
    """Account key object for workspace connection credential.

    :ivar key:
    :vartype key: str
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionApiKey(_Model):
    """Api key object for workspace connection credential.

    :ivar key:
    :vartype key: str
    """

    key: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionManagedIdentity(_Model):
    """WorkspaceConnectionManagedIdentity.

    :ivar client_id:
    :vartype client_id: str
    :ivar resource_id:
    :vartype resource_id: str
    """

    client_id: Optional[str] = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        client_id: Optional[str] = None,
        resource_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionOAuth2(_Model):
    """ClientId and ClientSecret are required. Other properties are optional
    depending on each OAuth2 provider's implementation.

    :ivar auth_url: Required by Concur connection category.
    :vartype auth_url: str
    :ivar client_id: Client id in the format of UUID.
    :vartype client_id: str
    :ivar client_secret:
    :vartype client_secret: str
    :ivar developer_token: Required by GoogleAdWords connection category.
    :vartype developer_token: str
    :ivar password:
    :vartype password: str
    :ivar refresh_token: Required by GoogleBigQuery, GoogleAdWords, Hubspot, QuickBooks, Square,
     Xero, Zoho
     where user needs to get RefreshToken offline.
    :vartype refresh_token: str
    :ivar tenant_id: Required by QuickBooks and Xero connection categories.
    :vartype tenant_id: str
    :ivar username: Concur, ServiceNow auth server AccessToken grant type is 'Password'
     which requires UsernamePassword.
    :vartype username: str
    """

    auth_url: Optional[str] = rest_field(name="authUrl", visibility=["read", "create", "update", "delete", "query"])
    """Required by Concur connection category."""
    client_id: Optional[str] = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    """Client id in the format of UUID."""
    client_secret: Optional[str] = rest_field(
        name="clientSecret", visibility=["read", "create", "update", "delete", "query"]
    )
    developer_token: Optional[str] = rest_field(
        name="developerToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """Required by GoogleAdWords connection category."""
    password: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    refresh_token: Optional[str] = rest_field(
        name="refreshToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """Required by GoogleBigQuery, GoogleAdWords, Hubspot, QuickBooks, Square, Xero, Zoho
     where user needs to get RefreshToken offline."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])
    """Required by QuickBooks and Xero connection categories."""
    username: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Concur, ServiceNow auth server AccessToken grant type is 'Password'
     which requires UsernamePassword."""

    @overload
    def __init__(
        self,
        *,
        auth_url: Optional[str] = None,
        client_id: Optional[str] = None,
        client_secret: Optional[str] = None,
        developer_token: Optional[str] = None,
        password: Optional[str] = None,
        refresh_token: Optional[str] = None,
        tenant_id: Optional[str] = None,
        username: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionPersonalAccessToken(_Model):
    """WorkspaceConnectionPersonalAccessToken.

    :ivar pat:
    :vartype pat: str
    """

    pat: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        pat: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionPropertiesV2BasicResource(ProxyResource):  # pylint: disable=name-too-long
    """Concrete proxy resource types can be created by aliasing this type using a specific property
    type.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.machinelearningservices.models.SystemData
    :ivar properties: Required.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionPropertiesV2
    """

    properties: "_models.WorkspaceConnectionPropertiesV2" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Required."""

    @overload
    def __init__(
        self,
        *,
        properties: "_models.WorkspaceConnectionPropertiesV2",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionServicePrincipal(_Model):
    """WorkspaceConnectionServicePrincipal.

    :ivar client_id:
    :vartype client_id: str
    :ivar client_secret:
    :vartype client_secret: str
    :ivar tenant_id:
    :vartype tenant_id: str
    """

    client_id: Optional[str] = rest_field(name="clientId", visibility=["read", "create", "update", "delete", "query"])
    client_secret: Optional[str] = rest_field(
        name="clientSecret", visibility=["read", "create", "update", "delete", "query"]
    )
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        client_id: Optional[str] = None,
        client_secret: Optional[str] = None,
        tenant_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionSharedAccessSignature(_Model):
    """WorkspaceConnectionSharedAccessSignature.

    :ivar sas:
    :vartype sas: str
    """

    sas: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        sas: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionUpdateParameter(_Model):
    """The properties that the machine learning workspace connection will be updated with.

    :ivar properties: The properties that the machine learning workspace connection will be updated
     with.
    :vartype properties: ~azure.mgmt.machinelearningservices.models.WorkspaceConnectionPropertiesV2
    """

    properties: Optional["_models.WorkspaceConnectionPropertiesV2"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties that the machine learning workspace connection will be updated with."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.WorkspaceConnectionPropertiesV2"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceConnectionUsernamePassword(_Model):
    """WorkspaceConnectionUsernamePassword.

    :ivar password:
    :vartype password: str
    :ivar security_token: Optional, required by connections like SalesForce for extra security in
     addition to UsernamePassword.
    :vartype security_token: str
    :ivar username:
    :vartype username: str
    """

    password: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    security_token: Optional[str] = rest_field(
        name="securityToken", visibility=["read", "create", "update", "delete", "query"]
    )
    """Optional, required by connections like SalesForce for extra security in addition to
     UsernamePassword."""
    username: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])

    @overload
    def __init__(
        self,
        *,
        password: Optional[str] = None,
        security_token: Optional[str] = None,
        username: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceHubConfig(_Model):
    """WorkspaceHub's configuration object.

    :ivar additional_workspace_storage_accounts:
    :vartype additional_workspace_storage_accounts: list[str]
    :ivar default_workspace_resource_group:
    :vartype default_workspace_resource_group: str
    """

    additional_workspace_storage_accounts: Optional[list[str]] = rest_field(
        name="additionalWorkspaceStorageAccounts", visibility=["read", "create", "update", "delete", "query"]
    )
    default_workspace_resource_group: Optional[str] = rest_field(
        name="defaultWorkspaceResourceGroup", visibility=["read", "create", "update", "delete", "query"]
    )

    @overload
    def __init__(
        self,
        *,
        additional_workspace_storage_accounts: Optional[list[str]] = None,
        default_workspace_resource_group: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspacePrivateEndpointResource(_Model):
    """The Private Endpoint resource.

    :ivar id: e.g.
     /subscriptions/{networkSubscriptionId}/resourceGroups/{rgName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}.
    :vartype id: str
    :ivar subnet_arm_id: The subnetId that the private endpoint is connected to.
    :vartype subnet_arm_id: str
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """e.g.
     /subscriptions/{networkSubscriptionId}/resourceGroups/{rgName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}."""
    subnet_arm_id: Optional[str] = rest_field(name="subnetArmId", visibility=["read"])
    """The subnetId that the private endpoint is connected to."""


class WorkspaceProperties(_Model):
    """The properties of a machine learning workspace.

    :ivar agents_endpoint_uri: The URI of agents endpoint associated with this workspace.
    :vartype agents_endpoint_uri: str
    :ivar allow_public_access_when_behind_vnet: The flag to indicate whether to allow public access
     when behind VNet.
    :vartype allow_public_access_when_behind_vnet: bool
    :ivar allow_role_assignment_on_rg: The flag to indicate whether we will do role assignment for
     the workspace MSI on resource group level.
    :vartype allow_role_assignment_on_rg: bool
    :ivar application_insights: ARM id of the application insights associated with this workspace.
    :vartype application_insights: str
    :ivar associated_workspaces:
    :vartype associated_workspaces: list[str]
    :ivar container_registries:
    :vartype container_registries: list[str]
    :ivar container_registry: ARM id of the container registry associated with this workspace.
    :vartype container_registry: str
    :ivar description: The description of this workspace.
    :vartype description: str
    :ivar discovery_url: Url for the discovery service to identify regional endpoints for machine
     learning experimentation services.
    :vartype discovery_url: str
    :ivar enable_data_isolation:
    :vartype enable_data_isolation: bool
    :ivar enable_service_side_cmk_encryption:
    :vartype enable_service_side_cmk_encryption: bool
    :ivar enable_simplified_cmk: Flag to tell if simplified CMK should be enabled for this
     workspace.
    :vartype enable_simplified_cmk: bool
    :ivar enable_software_bill_of_materials: Flag to tell if SoftwareBillOfMaterials should be
     enabled for this workspace.
    :vartype enable_software_bill_of_materials: bool
    :ivar encryption:
    :vartype encryption: ~azure.mgmt.machinelearningservices.models.EncryptionProperty
    :ivar existing_workspaces:
    :vartype existing_workspaces: list[str]
    :ivar feature_store_settings: Settings for feature store type workspace.
    :vartype feature_store_settings:
     ~azure.mgmt.machinelearningservices.models.FeatureStoreSettings
    :ivar friendly_name: The friendly name for this workspace. This name in mutable.
    :vartype friendly_name: str
    :ivar hbi_workspace: The flag to signal HBI data in the workspace and reduce diagnostic data
     collected by the service.
    :vartype hbi_workspace: bool
    :ivar hub_resource_id:
    :vartype hub_resource_id: str
    :ivar image_build_compute: The compute name for image build.
    :vartype image_build_compute: str
    :ivar ip_allowlist: The list of IPv4  addresses that are allowed to access the workspace.
    :vartype ip_allowlist: list[str]
    :ivar key_vault: ARM id of the key vault associated with this workspace. This cannot be changed
     once the workspace has been created.
    :vartype key_vault: str
    :ivar key_vaults:
    :vartype key_vaults: list[str]
    :ivar managed_network:
    :vartype managed_network: ~azure.mgmt.machinelearningservices.models.ManagedNetworkSettings
    :ivar ml_flow_tracking_uri: The URI associated with this workspace that machine learning flow
     must point at to set up tracking.
    :vartype ml_flow_tracking_uri: str
    :ivar network_acls: A set of rules governing the network accessibility of the workspace.
    :vartype network_acls: ~azure.mgmt.machinelearningservices.models.NetworkAcls
    :ivar notebook_info: The notebook info of Azure ML workspace.
    :vartype notebook_info: ~azure.mgmt.machinelearningservices.models.NotebookResourceInfo
    :ivar primary_user_assigned_identity: The user assigned identity resource id that represents
     the workspace identity.
    :vartype primary_user_assigned_identity: str
    :ivar private_endpoint_connections: The list of private endpoint connections in the workspace.
    :vartype private_endpoint_connections:
     list[~azure.mgmt.machinelearningservices.models.PrivateEndpointConnection]
    :ivar private_link_count: Count of private connections in the workspace.
    :vartype private_link_count: int
    :ivar provision_network_now: Set to trigger the provisioning of the managed VNet with the
     default Options when creating a Workspace with the managed VNet enabled, or else it does
     nothing.
    :vartype provision_network_now: bool
    :ivar provisioning_state: The current deployment state of workspace resource. The
     provisioningState is to indicate states for resource provisioning. Known values are: "Unknown",
     "Updating", "Creating", "Deleting", "Succeeded", "Failed", and "Canceled".
    :vartype provisioning_state: str or
     ~azure.mgmt.machinelearningservices.models.ProvisioningState
    :ivar public_network_access: Whether requests from Public Network are allowed. Known values
     are: "Enabled" and "Disabled".
    :vartype public_network_access: str or
     ~azure.mgmt.machinelearningservices.models.PublicNetworkAccessType
    :ivar serverless_compute_settings: Settings for serverless compute in a workspace.
    :vartype serverless_compute_settings:
     ~azure.mgmt.machinelearningservices.models.ServerlessComputeSettings
    :ivar service_managed_resources_settings: The service managed resource settings.
    :vartype service_managed_resources_settings:
     ~azure.mgmt.machinelearningservices.models.ServiceManagedResourcesSettings
    :ivar service_provisioned_resource_group: The name of the managed resource group created by
     workspace RP in customer subscription if the workspace is CMK workspace.
    :vartype service_provisioned_resource_group: str
    :ivar shared_private_link_resources: The list of shared private link resources in this
     workspace.
    :vartype shared_private_link_resources:
     list[~azure.mgmt.machinelearningservices.models.SharedPrivateLinkResource]
    :ivar soft_delete_retention_in_days: Retention time in days after workspace get soft deleted.
    :vartype soft_delete_retention_in_days: int
    :ivar storage_account: ARM id of the storage account associated with this workspace. This
     cannot be changed once the workspace has been created.
    :vartype storage_account: str
    :ivar storage_accounts:
    :vartype storage_accounts: list[str]
    :ivar storage_hns_enabled: If the storage associated with the workspace has hierarchical
     namespace(HNS) enabled.
    :vartype storage_hns_enabled: bool
    :ivar system_datastores_auth_mode: The auth mode used for accessing the system datastores of
     the workspace. Known values are: "AccessKey", "Identity", and "UserDelegationSAS".
    :vartype system_datastores_auth_mode: str or
     ~azure.mgmt.machinelearningservices.models.SystemDatastoresAuthMode
    :ivar tenant_id: The tenant id associated with this workspace.
    :vartype tenant_id: str
    :ivar v1_legacy_mode: Enabling v1_legacy_mode may prevent you from using features provided by
     the v2 API.
    :vartype v1_legacy_mode: bool
    :ivar workspace_hub_config: WorkspaceHub's configuration object.
    :vartype workspace_hub_config: ~azure.mgmt.machinelearningservices.models.WorkspaceHubConfig
    :ivar workspace_id: The immutable id associated with this workspace.
    :vartype workspace_id: str
    """

    agents_endpoint_uri: Optional[str] = rest_field(name="agentsEndpointUri", visibility=["read"])
    """The URI of agents endpoint associated with this workspace."""
    allow_public_access_when_behind_vnet: Optional[bool] = rest_field(
        name="allowPublicAccessWhenBehindVnet", visibility=["read", "create", "update", "delete", "query"]
    )
    """The flag to indicate whether to allow public access when behind VNet."""
    allow_role_assignment_on_rg: Optional[bool] = rest_field(
        name="allowRoleAssignmentOnRG", visibility=["read", "create", "update", "delete", "query"]
    )
    """The flag to indicate whether we will do role assignment for the workspace MSI on resource group
     level."""
    application_insights: Optional[str] = rest_field(
        name="applicationInsights", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM id of the application insights associated with this workspace."""
    associated_workspaces: Optional[list[str]] = rest_field(
        name="associatedWorkspaces", visibility=["read", "create", "update", "delete", "query"]
    )
    container_registries: Optional[list[str]] = rest_field(
        name="containerRegistries", visibility=["read", "create", "update", "delete", "query"]
    )
    container_registry: Optional[str] = rest_field(
        name="containerRegistry", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM id of the container registry associated with this workspace."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of this workspace."""
    discovery_url: Optional[str] = rest_field(
        name="discoveryUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Url for the discovery service to identify regional endpoints for machine learning
     experimentation services."""
    enable_data_isolation: Optional[bool] = rest_field(
        name="enableDataIsolation", visibility=["read", "create", "update", "delete", "query"]
    )
    enable_service_side_cmk_encryption: Optional[bool] = rest_field(
        name="enableServiceSideCMKEncryption", visibility=["read", "create", "update", "delete", "query"]
    )
    enable_simplified_cmk: Optional[bool] = rest_field(
        name="enableSimplifiedCmk", visibility=["read", "create", "update", "delete", "query"]
    )
    """Flag to tell if simplified CMK should be enabled for this workspace."""
    enable_software_bill_of_materials: Optional[bool] = rest_field(
        name="enableSoftwareBillOfMaterials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Flag to tell if SoftwareBillOfMaterials should be enabled for this workspace."""
    encryption: Optional["_models.EncryptionProperty"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    existing_workspaces: Optional[list[str]] = rest_field(
        name="existingWorkspaces", visibility=["read", "create", "update", "delete", "query"]
    )
    feature_store_settings: Optional["_models.FeatureStoreSettings"] = rest_field(
        name="featureStoreSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for feature store type workspace."""
    friendly_name: Optional[str] = rest_field(
        name="friendlyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The friendly name for this workspace. This name in mutable."""
    hbi_workspace: Optional[bool] = rest_field(
        name="hbiWorkspace", visibility=["read", "create", "update", "delete", "query"]
    )
    """The flag to signal HBI data in the workspace and reduce diagnostic data collected by the
     service."""
    hub_resource_id: Optional[str] = rest_field(
        name="hubResourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    image_build_compute: Optional[str] = rest_field(
        name="imageBuildCompute", visibility=["read", "create", "update", "delete", "query"]
    )
    """The compute name for image build."""
    ip_allowlist: Optional[list[str]] = rest_field(
        name="ipAllowlist", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of IPv4  addresses that are allowed to access the workspace."""
    key_vault: Optional[str] = rest_field(name="keyVault", visibility=["read", "create", "update", "delete", "query"])
    """ARM id of the key vault associated with this workspace. This cannot be changed once the
     workspace has been created."""
    key_vaults: Optional[list[str]] = rest_field(
        name="keyVaults", visibility=["read", "create", "update", "delete", "query"]
    )
    managed_network: Optional["_models.ManagedNetworkSettings"] = rest_field(
        name="managedNetwork", visibility=["read", "create", "update", "delete", "query"]
    )
    ml_flow_tracking_uri: Optional[str] = rest_field(name="mlFlowTrackingUri", visibility=["read"])
    """The URI associated with this workspace that machine learning flow must point at to set up
     tracking."""
    network_acls: Optional["_models.NetworkAcls"] = rest_field(
        name="networkAcls", visibility=["read", "create", "update", "delete", "query"]
    )
    """A set of rules governing the network accessibility of the workspace."""
    notebook_info: Optional["_models.NotebookResourceInfo"] = rest_field(name="notebookInfo", visibility=["read"])
    """The notebook info of Azure ML workspace."""
    primary_user_assigned_identity: Optional[str] = rest_field(
        name="primaryUserAssignedIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user assigned identity resource id that represents the workspace identity."""
    private_endpoint_connections: Optional[list["_models.PrivateEndpointConnection"]] = rest_field(
        name="privateEndpointConnections", visibility=["read"]
    )
    """The list of private endpoint connections in the workspace."""
    private_link_count: Optional[int] = rest_field(name="privateLinkCount", visibility=["read"])
    """Count of private connections in the workspace."""
    provision_network_now: Optional[bool] = rest_field(
        name="provisionNetworkNow", visibility=["read", "create", "update", "delete", "query"]
    )
    """Set to trigger the provisioning of the managed VNet with the default Options when creating a
     Workspace with the managed VNet enabled, or else it does nothing."""
    provisioning_state: Optional[Union[str, "_models.ProvisioningState"]] = rest_field(
        name="provisioningState", visibility=["read"]
    )
    """The current deployment state of workspace resource. The provisioningState is to indicate states
     for resource provisioning. Known values are: \"Unknown\", \"Updating\", \"Creating\",
     \"Deleting\", \"Succeeded\", \"Failed\", and \"Canceled\"."""
    public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = rest_field(
        name="publicNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether requests from Public Network are allowed. Known values are: \"Enabled\" and
     \"Disabled\"."""
    serverless_compute_settings: Optional["_models.ServerlessComputeSettings"] = rest_field(
        name="serverlessComputeSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for serverless compute in a workspace."""
    service_managed_resources_settings: Optional["_models.ServiceManagedResourcesSettings"] = rest_field(
        name="serviceManagedResourcesSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The service managed resource settings."""
    service_provisioned_resource_group: Optional[str] = rest_field(
        name="serviceProvisionedResourceGroup", visibility=["read"]
    )
    """The name of the managed resource group created by workspace RP in customer subscription if the
     workspace is CMK workspace."""
    shared_private_link_resources: Optional[list["_models.SharedPrivateLinkResource"]] = rest_field(
        name="sharedPrivateLinkResources", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of shared private link resources in this workspace."""
    soft_delete_retention_in_days: Optional[int] = rest_field(
        name="softDeleteRetentionInDays", visibility=["read", "create", "update", "delete", "query"]
    )
    """Retention time in days after workspace get soft deleted."""
    storage_account: Optional[str] = rest_field(
        name="storageAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM id of the storage account associated with this workspace. This cannot be changed once the
     workspace has been created."""
    storage_accounts: Optional[list[str]] = rest_field(
        name="storageAccounts", visibility=["read", "create", "update", "delete", "query"]
    )
    storage_hns_enabled: Optional[bool] = rest_field(name="storageHnsEnabled", visibility=["read"])
    """If the storage associated with the workspace has hierarchical namespace(HNS) enabled."""
    system_datastores_auth_mode: Optional[Union[str, "_models.SystemDatastoresAuthMode"]] = rest_field(
        name="systemDatastoresAuthMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The auth mode used for accessing the system datastores of the workspace. Known values are:
     \"AccessKey\", \"Identity\", and \"UserDelegationSAS\"."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read"])
    """The tenant id associated with this workspace."""
    v1_legacy_mode: Optional[bool] = rest_field(
        name="v1LegacyMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enabling v1_legacy_mode may prevent you from using features provided by the v2 API."""
    workspace_hub_config: Optional["_models.WorkspaceHubConfig"] = rest_field(
        name="workspaceHubConfig", visibility=["read", "create", "update", "delete", "query"]
    )
    """WorkspaceHub's configuration object."""
    workspace_id: Optional[str] = rest_field(name="workspaceId", visibility=["read"])
    """The immutable id associated with this workspace."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        allow_public_access_when_behind_vnet: Optional[bool] = None,
        allow_role_assignment_on_rg: Optional[bool] = None,
        application_insights: Optional[str] = None,
        associated_workspaces: Optional[list[str]] = None,
        container_registries: Optional[list[str]] = None,
        container_registry: Optional[str] = None,
        description: Optional[str] = None,
        discovery_url: Optional[str] = None,
        enable_data_isolation: Optional[bool] = None,
        enable_service_side_cmk_encryption: Optional[bool] = None,
        enable_simplified_cmk: Optional[bool] = None,
        enable_software_bill_of_materials: Optional[bool] = None,
        encryption: Optional["_models.EncryptionProperty"] = None,
        existing_workspaces: Optional[list[str]] = None,
        feature_store_settings: Optional["_models.FeatureStoreSettings"] = None,
        friendly_name: Optional[str] = None,
        hbi_workspace: Optional[bool] = None,
        hub_resource_id: Optional[str] = None,
        image_build_compute: Optional[str] = None,
        ip_allowlist: Optional[list[str]] = None,
        key_vault: Optional[str] = None,
        key_vaults: Optional[list[str]] = None,
        managed_network: Optional["_models.ManagedNetworkSettings"] = None,
        network_acls: Optional["_models.NetworkAcls"] = None,
        primary_user_assigned_identity: Optional[str] = None,
        provision_network_now: Optional[bool] = None,
        public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = None,
        serverless_compute_settings: Optional["_models.ServerlessComputeSettings"] = None,
        service_managed_resources_settings: Optional["_models.ServiceManagedResourcesSettings"] = None,
        shared_private_link_resources: Optional[list["_models.SharedPrivateLinkResource"]] = None,
        soft_delete_retention_in_days: Optional[int] = None,
        storage_account: Optional[str] = None,
        storage_accounts: Optional[list[str]] = None,
        system_datastores_auth_mode: Optional[Union[str, "_models.SystemDatastoresAuthMode"]] = None,
        v1_legacy_mode: Optional[bool] = None,
        workspace_hub_config: Optional["_models.WorkspaceHubConfig"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspacePropertiesUpdateParameters(_Model):
    """The parameters for updating a machine learning workspace.

    :ivar allow_role_assignment_on_rg:
    :vartype allow_role_assignment_on_rg: bool
    :ivar application_insights: ARM id of the application insights associated with this workspace.
    :vartype application_insights: str
    :ivar container_registry: ARM id of the container registry associated with this workspace.
    :vartype container_registry: str
    :ivar description: The description of this workspace.
    :vartype description: str
    :ivar enable_data_isolation:
    :vartype enable_data_isolation: bool
    :ivar enable_software_bill_of_materials: Flag to tell if SoftwareBillOfMaterials should be
     enabled for this workspace.
    :vartype enable_software_bill_of_materials: bool
    :ivar encryption:
    :vartype encryption: ~azure.mgmt.machinelearningservices.models.EncryptionUpdateProperties
    :ivar feature_store_settings: Settings for feature store type workspace.
    :vartype feature_store_settings:
     ~azure.mgmt.machinelearningservices.models.FeatureStoreSettings
    :ivar friendly_name: The friendly name for this workspace. This name in mutable.
    :vartype friendly_name: str
    :ivar image_build_compute: The compute name for image build.
    :vartype image_build_compute: str
    :ivar ip_allowlist: The list of IPv4 addresses that are allowed to access the workspace.
    :vartype ip_allowlist: list[str]
    :ivar managed_network:
    :vartype managed_network: ~azure.mgmt.machinelearningservices.models.ManagedNetworkSettings
    :ivar network_acls: A set of rules governing the network accessibility of the workspace.
    :vartype network_acls: ~azure.mgmt.machinelearningservices.models.NetworkAcls
    :ivar primary_user_assigned_identity: The user assigned identity resource id that represents
     the workspace identity.
    :vartype primary_user_assigned_identity: str
    :ivar public_network_access: Whether requests from Public Network are allowed. Known values
     are: "Enabled" and "Disabled".
    :vartype public_network_access: str or
     ~azure.mgmt.machinelearningservices.models.PublicNetworkAccessType
    :ivar serverless_compute_settings: Settings for serverless compute in a workspace.
    :vartype serverless_compute_settings:
     ~azure.mgmt.machinelearningservices.models.ServerlessComputeSettings
    :ivar service_managed_resources_settings: The service managed resource settings.
    :vartype service_managed_resources_settings:
     ~azure.mgmt.machinelearningservices.models.ServiceManagedResourcesSettings
    :ivar soft_delete_retention_in_days: Retention time in days after workspace get soft deleted.
    :vartype soft_delete_retention_in_days: int
    :ivar system_datastores_auth_mode: The auth mode used for accessing the system datastores of
     the workspace. Known values are: "AccessKey", "Identity", and "UserDelegationSAS".
    :vartype system_datastores_auth_mode: str or
     ~azure.mgmt.machinelearningservices.models.SystemDatastoresAuthMode
    :ivar v1_legacy_mode: Enabling v1_legacy_mode may prevent you from using features provided by
     the v2 API.
    :vartype v1_legacy_mode: bool
    """

    allow_role_assignment_on_rg: Optional[bool] = rest_field(
        name="allowRoleAssignmentOnRG", visibility=["read", "create", "update", "delete", "query"]
    )
    application_insights: Optional[str] = rest_field(
        name="applicationInsights", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM id of the application insights associated with this workspace."""
    container_registry: Optional[str] = rest_field(
        name="containerRegistry", visibility=["read", "create", "update", "delete", "query"]
    )
    """ARM id of the container registry associated with this workspace."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The description of this workspace."""
    enable_data_isolation: Optional[bool] = rest_field(
        name="enableDataIsolation", visibility=["read", "create", "update", "delete", "query"]
    )
    enable_software_bill_of_materials: Optional[bool] = rest_field(
        name="enableSoftwareBillOfMaterials", visibility=["read", "create", "update", "delete", "query"]
    )
    """Flag to tell if SoftwareBillOfMaterials should be enabled for this workspace."""
    encryption: Optional["_models.EncryptionUpdateProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    feature_store_settings: Optional["_models.FeatureStoreSettings"] = rest_field(
        name="featureStoreSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for feature store type workspace."""
    friendly_name: Optional[str] = rest_field(
        name="friendlyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """The friendly name for this workspace. This name in mutable."""
    image_build_compute: Optional[str] = rest_field(
        name="imageBuildCompute", visibility=["read", "create", "update", "delete", "query"]
    )
    """The compute name for image build."""
    ip_allowlist: Optional[list[str]] = rest_field(
        name="ipAllowlist", visibility=["read", "create", "update", "delete", "query"]
    )
    """The list of IPv4 addresses that are allowed to access the workspace."""
    managed_network: Optional["_models.ManagedNetworkSettings"] = rest_field(
        name="managedNetwork", visibility=["read", "create", "update", "delete", "query"]
    )
    network_acls: Optional["_models.NetworkAcls"] = rest_field(
        name="networkAcls", visibility=["read", "create", "update", "delete", "query"]
    )
    """A set of rules governing the network accessibility of the workspace."""
    primary_user_assigned_identity: Optional[str] = rest_field(
        name="primaryUserAssignedIdentity", visibility=["read", "create", "update", "delete", "query"]
    )
    """The user assigned identity resource id that represents the workspace identity."""
    public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = rest_field(
        name="publicNetworkAccess", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether requests from Public Network are allowed. Known values are: \"Enabled\" and
     \"Disabled\"."""
    serverless_compute_settings: Optional["_models.ServerlessComputeSettings"] = rest_field(
        name="serverlessComputeSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """Settings for serverless compute in a workspace."""
    service_managed_resources_settings: Optional["_models.ServiceManagedResourcesSettings"] = rest_field(
        name="serviceManagedResourcesSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The service managed resource settings."""
    soft_delete_retention_in_days: Optional[int] = rest_field(
        name="softDeleteRetentionInDays", visibility=["read", "create", "update", "delete", "query"]
    )
    """Retention time in days after workspace get soft deleted."""
    system_datastores_auth_mode: Optional[Union[str, "_models.SystemDatastoresAuthMode"]] = rest_field(
        name="systemDatastoresAuthMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The auth mode used for accessing the system datastores of the workspace. Known values are:
     \"AccessKey\", \"Identity\", and \"UserDelegationSAS\"."""
    v1_legacy_mode: Optional[bool] = rest_field(
        name="v1LegacyMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Enabling v1_legacy_mode may prevent you from using features provided by the v2 API."""

    @overload
    def __init__(
        self,
        *,
        allow_role_assignment_on_rg: Optional[bool] = None,
        application_insights: Optional[str] = None,
        container_registry: Optional[str] = None,
        description: Optional[str] = None,
        enable_data_isolation: Optional[bool] = None,
        enable_software_bill_of_materials: Optional[bool] = None,
        encryption: Optional["_models.EncryptionUpdateProperties"] = None,
        feature_store_settings: Optional["_models.FeatureStoreSettings"] = None,
        friendly_name: Optional[str] = None,
        image_build_compute: Optional[str] = None,
        ip_allowlist: Optional[list[str]] = None,
        managed_network: Optional["_models.ManagedNetworkSettings"] = None,
        network_acls: Optional["_models.NetworkAcls"] = None,
        primary_user_assigned_identity: Optional[str] = None,
        public_network_access: Optional[Union[str, "_models.PublicNetworkAccessType"]] = None,
        serverless_compute_settings: Optional["_models.ServerlessComputeSettings"] = None,
        service_managed_resources_settings: Optional["_models.ServiceManagedResourcesSettings"] = None,
        soft_delete_retention_in_days: Optional[int] = None,
        system_datastores_auth_mode: Optional[Union[str, "_models.SystemDatastoresAuthMode"]] = None,
        v1_legacy_mode: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WorkspaceUpdateParameters(_Model):
    """The parameters for updating a machine learning workspace.

    :ivar identity:
    :vartype identity: ~azure.mgmt.machinelearningservices.models.ManagedServiceIdentity
    :ivar properties: The properties that the machine learning workspace will be updated with.
    :vartype properties:
     ~azure.mgmt.machinelearningservices.models.WorkspacePropertiesUpdateParameters
    :ivar sku: Optional. This field is required to be implemented by the RP because AML is
     supporting more than one tier.
    :vartype sku: ~azure.mgmt.machinelearningservices.models.Sku
    :ivar tags: The resource tags for the machine learning workspace.
    :vartype tags: dict[str, str]
    """

    identity: Optional["_models.ManagedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    properties: Optional["_models.WorkspacePropertiesUpdateParameters"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties that the machine learning workspace will be updated with."""
    sku: Optional["_models.Sku"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional. This field is required to be implemented by the RP because AML is supporting more
     than one tier."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource tags for the machine learning workspace."""

    __flattened_items = [
        "allow_role_assignment_on_rg",
        "application_insights",
        "container_registry",
        "description",
        "enable_data_isolation",
        "enable_software_bill_of_materials",
        "encryption",
        "feature_store_settings",
        "friendly_name",
        "image_build_compute",
        "ip_allowlist",
        "managed_network",
        "network_acls",
        "primary_user_assigned_identity",
        "public_network_access",
        "serverless_compute_settings",
        "service_managed_resources_settings",
        "soft_delete_retention_in_days",
        "system_datastores_auth_mode",
        "v1_legacy_mode",
    ]

    @overload
    def __init__(
        self,
        *,
        identity: Optional["_models.ManagedServiceIdentity"] = None,
        properties: Optional["_models.WorkspacePropertiesUpdateParameters"] = None,
        sku: Optional["_models.Sku"] = None,
        tags: Optional[dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)
