# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, Callable, IO, Optional, TypeVar, Union, overload
import urllib.parse

from azure.core import PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models as _models
from .._configuration import AlertsManagementClientConfiguration
from .._utils.model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from .._utils.serialization import Deserializer, Serializer

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]
List = list

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.AlertsManagement/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_by_id_tenant_request(alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.AlertsManagement/alerts/{alertId}"
    path_format_arguments = {
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_history_tenant_request(alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.AlertsManagement/alerts/{alertId}/history"
    path_format_arguments = {
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_change_state_tenant_request(
    alert_id: str, *, new_state: Union[str, _models.AlertState], **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.AlertsManagement/alerts/{alertId}/changestate"
    path_format_arguments = {
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["newState"] = _SERIALIZER.query("new_state", new_state, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_all_tenant_request(
    *,
    target_resource: Optional[str] = None,
    target_resource_type: Optional[str] = None,
    target_resource_group: Optional[str] = None,
    monitor_service: Optional[Union[str, _models.MonitorService]] = None,
    monitor_condition: Optional[Union[str, _models.MonitorCondition]] = None,
    severity: Optional[Union[str, _models.Severity]] = None,
    alert_state: Optional[Union[str, _models.AlertState]] = None,
    alert_rule: Optional[str] = None,
    smart_group_id: Optional[str] = None,
    include_context: Optional[bool] = None,
    include_egress_config: Optional[bool] = None,
    page_count: Optional[int] = None,
    sort_by: Optional[Union[str, _models.AlertsSortByFields]] = None,
    sort_order: Optional[Union[str, _models.SortOrder]] = None,
    select: Optional[str] = None,
    time_range: Optional[Union[str, _models.TimeRange]] = None,
    custom_time_range: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.AlertsManagement/alerts"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if target_resource is not None:
        _params["targetResource"] = _SERIALIZER.query("target_resource", target_resource, "str")
    if target_resource_type is not None:
        _params["targetResourceType"] = _SERIALIZER.query("target_resource_type", target_resource_type, "str")
    if target_resource_group is not None:
        _params["targetResourceGroup"] = _SERIALIZER.query("target_resource_group", target_resource_group, "str")
    if monitor_service is not None:
        _params["monitorService"] = _SERIALIZER.query("monitor_service", monitor_service, "str")
    if monitor_condition is not None:
        _params["monitorCondition"] = _SERIALIZER.query("monitor_condition", monitor_condition, "str")
    if severity is not None:
        _params["severity"] = _SERIALIZER.query("severity", severity, "str")
    if alert_state is not None:
        _params["alertState"] = _SERIALIZER.query("alert_state", alert_state, "str")
    if alert_rule is not None:
        _params["alertRule"] = _SERIALIZER.query("alert_rule", alert_rule, "str")
    if smart_group_id is not None:
        _params["smartGroupId"] = _SERIALIZER.query("smart_group_id", smart_group_id, "str")
    if include_context is not None:
        _params["includeContext"] = _SERIALIZER.query("include_context", include_context, "bool")
    if include_egress_config is not None:
        _params["includeEgressConfig"] = _SERIALIZER.query("include_egress_config", include_egress_config, "bool")
    if page_count is not None:
        _params["pageCount"] = _SERIALIZER.query("page_count", page_count, "int")
    if sort_by is not None:
        _params["sortBy"] = _SERIALIZER.query("sort_by", sort_by, "str")
    if sort_order is not None:
        _params["sortOrder"] = _SERIALIZER.query("sort_order", sort_order, "str")
    if select is not None:
        _params["select"] = _SERIALIZER.query("select", select, "str")
    if time_range is not None:
        _params["timeRange"] = _SERIALIZER.query("time_range", time_range, "str")
    if custom_time_range is not None:
        _params["customTimeRange"] = _SERIALIZER.query("custom_time_range", custom_time_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_by_id_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.AlertsManagement/alerts/{alertId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_all_request(
    scope: str,
    *,
    target_resource: Optional[str] = None,
    target_resource_type: Optional[str] = None,
    target_resource_group: Optional[str] = None,
    monitor_service: Optional[Union[str, _models.MonitorService]] = None,
    monitor_condition: Optional[Union[str, _models.MonitorCondition]] = None,
    severity: Optional[Union[str, _models.Severity]] = None,
    alert_state: Optional[Union[str, _models.AlertState]] = None,
    alert_rule: Optional[str] = None,
    smart_group_id: Optional[str] = None,
    include_context: Optional[bool] = None,
    include_egress_config: Optional[bool] = None,
    page_count: Optional[int] = None,
    sort_by: Optional[Union[str, _models.AlertsSortByFields]] = None,
    sort_order: Optional[Union[str, _models.SortOrder]] = None,
    select: Optional[str] = None,
    time_range: Optional[Union[str, _models.TimeRange]] = None,
    custom_time_range: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.AlertsManagement/alerts"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if target_resource is not None:
        _params["targetResource"] = _SERIALIZER.query("target_resource", target_resource, "str")
    if target_resource_type is not None:
        _params["targetResourceType"] = _SERIALIZER.query("target_resource_type", target_resource_type, "str")
    if target_resource_group is not None:
        _params["targetResourceGroup"] = _SERIALIZER.query("target_resource_group", target_resource_group, "str")
    if monitor_service is not None:
        _params["monitorService"] = _SERIALIZER.query("monitor_service", monitor_service, "str")
    if monitor_condition is not None:
        _params["monitorCondition"] = _SERIALIZER.query("monitor_condition", monitor_condition, "str")
    if severity is not None:
        _params["severity"] = _SERIALIZER.query("severity", severity, "str")
    if alert_state is not None:
        _params["alertState"] = _SERIALIZER.query("alert_state", alert_state, "str")
    if alert_rule is not None:
        _params["alertRule"] = _SERIALIZER.query("alert_rule", alert_rule, "str")
    if smart_group_id is not None:
        _params["smartGroupId"] = _SERIALIZER.query("smart_group_id", smart_group_id, "str")
    if include_context is not None:
        _params["includeContext"] = _SERIALIZER.query("include_context", include_context, "bool")
    if include_egress_config is not None:
        _params["includeEgressConfig"] = _SERIALIZER.query("include_egress_config", include_egress_config, "bool")
    if page_count is not None:
        _params["pageCount"] = _SERIALIZER.query("page_count", page_count, "int")
    if sort_by is not None:
        _params["sortBy"] = _SERIALIZER.query("sort_by", sort_by, "str")
    if sort_order is not None:
        _params["sortOrder"] = _SERIALIZER.query("sort_order", sort_order, "str")
    if select is not None:
        _params["select"] = _SERIALIZER.query("select", select, "str")
    if time_range is not None:
        _params["timeRange"] = _SERIALIZER.query("time_range", time_range, "str")
    if custom_time_range is not None:
        _params["customTimeRange"] = _SERIALIZER.query("custom_time_range", custom_time_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_change_state_request(
    scope: str, alert_id: str, *, new_state: Union[str, _models.AlertState], **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.AlertsManagement/alerts/{alertId}/changestate"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["newState"] = _SERIALIZER.query("new_state", new_state, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_history_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.AlertsManagement/alerts/{alertId}/history"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_enrichments_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.AlertsManagement/alerts/{alertId}/enrichments"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_meta_data_request(*, identifier: Union[str, _models.Identifier], **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.AlertsManagement/alertsMetaData"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["identifier"] = _SERIALIZER.query("identifier", identifier, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_summary_request(
    scope: str,
    *,
    groupby: Union[str, _models.AlertsSummaryGroupByFields],
    include_smart_groups_count: Optional[bool] = None,
    target_resource: Optional[str] = None,
    target_resource_type: Optional[str] = None,
    target_resource_group: Optional[str] = None,
    monitor_service: Optional[Union[str, _models.MonitorService]] = None,
    monitor_condition: Optional[Union[str, _models.MonitorCondition]] = None,
    severity: Optional[Union[str, _models.Severity]] = None,
    alert_state: Optional[Union[str, _models.AlertState]] = None,
    alert_rule: Optional[str] = None,
    time_range: Optional[Union[str, _models.TimeRange]] = None,
    custom_time_range: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-05-25-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.AlertsManagement/alertsSummary"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["groupby"] = _SERIALIZER.query("groupby", groupby, "str")
    if include_smart_groups_count is not None:
        _params["includeSmartGroupsCount"] = _SERIALIZER.query(
            "include_smart_groups_count", include_smart_groups_count, "bool"
        )
    if target_resource is not None:
        _params["targetResource"] = _SERIALIZER.query("target_resource", target_resource, "str")
    if target_resource_type is not None:
        _params["targetResourceType"] = _SERIALIZER.query("target_resource_type", target_resource_type, "str")
    if target_resource_group is not None:
        _params["targetResourceGroup"] = _SERIALIZER.query("target_resource_group", target_resource_group, "str")
    if monitor_service is not None:
        _params["monitorService"] = _SERIALIZER.query("monitor_service", monitor_service, "str")
    if monitor_condition is not None:
        _params["monitorCondition"] = _SERIALIZER.query("monitor_condition", monitor_condition, "str")
    if severity is not None:
        _params["severity"] = _SERIALIZER.query("severity", severity, "str")
    if alert_state is not None:
        _params["alertState"] = _SERIALIZER.query("alert_state", alert_state, "str")
    if alert_rule is not None:
        _params["alertRule"] = _SERIALIZER.query("alert_rule", alert_rule, "str")
    if time_range is not None:
        _params["timeRange"] = _SERIALIZER.query("time_range", time_range, "str")
    if custom_time_range is not None:
        _params["customTimeRange"] = _SERIALIZER.query("custom_time_range", custom_time_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.alertsmanagement.AlertsManagementClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AlertsManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> ItemPaged["_models.Operation"]:
        """List all operations available through Azure Alerts Management Resource Provider.

        :return: An iterator like instance of Operation
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.alertsmanagement.models.Operation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Operation]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Operation], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class AlertsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.alertsmanagement.AlertsManagementClient`'s
        :attr:`alerts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AlertsManagementClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_by_id_tenant(self, alert_id: str, **kwargs: Any) -> _models.Alert:
        """Get a specific alert.

        Get information related to a specific alert.

        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)

        _request = build_alerts_get_by_id_tenant_request(
            alert_id=alert_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Alert, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_history_tenant(self, alert_id: str, **kwargs: Any) -> _models.AlertModification:
        """Get the history of an alert, which captures any monitor condition changes (Fired/Resolved),
        alert state changes (New/Acknowledged/Closed) and applied action rules for that particular
        alert.

        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :return: AlertModification. The AlertModification is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.AlertModification
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AlertModification] = kwargs.pop("cls", None)

        _request = build_alerts_get_history_tenant_request(
            alert_id=alert_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AlertModification, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def change_state_tenant(
        self,
        alert_id: str,
        comment: _models.Comments,
        *,
        new_state: Union[str, _models.AlertState],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert.

        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Required.
        :type comment: ~azure.mgmt.alertsmanagement.models.Comments
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def change_state_tenant(
        self,
        alert_id: str,
        comment: JSON,
        *,
        new_state: Union[str, _models.AlertState],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert.

        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Required.
        :type comment: JSON
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def change_state_tenant(
        self,
        alert_id: str,
        comment: IO[bytes],
        *,
        new_state: Union[str, _models.AlertState],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert.

        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Required.
        :type comment: IO[bytes]
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def change_state_tenant(
        self,
        alert_id: str,
        comment: Union[_models.Comments, JSON, IO[bytes]],
        *,
        new_state: Union[str, _models.AlertState],
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert.

        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Is one of the following types: Comments, JSON,
         IO[bytes] Required.
        :type comment: ~azure.mgmt.alertsmanagement.models.Comments or JSON or IO[bytes]
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(comment, (IOBase, bytes)):
            _content = comment
        else:
            _content = json.dumps(comment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_alerts_change_state_tenant_request(
            alert_id=alert_id,
            new_state=new_state,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Alert, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_all_tenant(  # pylint: disable=too-many-locals
        self,
        *,
        target_resource: Optional[str] = None,
        target_resource_type: Optional[str] = None,
        target_resource_group: Optional[str] = None,
        monitor_service: Optional[Union[str, _models.MonitorService]] = None,
        monitor_condition: Optional[Union[str, _models.MonitorCondition]] = None,
        severity: Optional[Union[str, _models.Severity]] = None,
        alert_state: Optional[Union[str, _models.AlertState]] = None,
        alert_rule: Optional[str] = None,
        smart_group_id: Optional[str] = None,
        include_context: Optional[bool] = None,
        include_egress_config: Optional[bool] = None,
        page_count: Optional[int] = None,
        sort_by: Optional[Union[str, _models.AlertsSortByFields]] = None,
        sort_order: Optional[Union[str, _models.SortOrder]] = None,
        select: Optional[str] = None,
        time_range: Optional[Union[str, _models.TimeRange]] = None,
        custom_time_range: Optional[str] = None,
        **kwargs: Any
    ) -> ItemPaged["_models.Alert"]:
        """List all existing alerts, where the results can be filtered on the basis of multiple parameters
        (e.g. time range). The results can then be sorted on the basis specific fields, with the
        default being lastModifiedDateTime.

        :keyword target_resource: Filter by target resource( which is full ARM ID) Default value is
         select all. Default value is None.
        :paramtype target_resource: str
        :keyword target_resource_type: Filter by target resource type. Default value is select all.
         Default value is None.
        :paramtype target_resource_type: str
        :keyword target_resource_group: Filter by target resource group name. Default value is select
         all. Default value is None.
        :paramtype target_resource_group: str
        :keyword monitor_service: Filter by monitor service which generates the alert instance. Default
         value is select all. Known values are: "Application Insights", "ActivityLog Administrative",
         "ActivityLog Security", "ActivityLog Recommendation", "ActivityLog Policy", "ActivityLog
         Autoscale", "Log Analytics", "Nagios", "Platform", "SCOM", "ServiceHealth", "SmartDetector",
         "VM Insights", "Zabbix", and "Resource Health". Default value is None.
        :paramtype monitor_service: str or ~azure.mgmt.alertsmanagement.models.MonitorService
        :keyword monitor_condition: Filter by monitor condition which is either 'Fired' or 'Resolved'.
         Default value is to select all. Known values are: "Fired" and "Resolved". Default value is
         None.
        :paramtype monitor_condition: str or ~azure.mgmt.alertsmanagement.models.MonitorCondition
        :keyword severity: Filter by severity.  Default value is select all. Known values are: "Sev0",
         "Sev1", "Sev2", "Sev3", and "Sev4". Default value is None.
        :paramtype severity: str or ~azure.mgmt.alertsmanagement.models.Severity
        :keyword alert_state: Filter by state of the alert instance. Default value is to select all.
         Known values are: "New", "Acknowledged", and "Closed". Default value is None.
        :paramtype alert_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword alert_rule: Filter by specific alert rule.  Default value is to select all. Default
         value is None.
        :paramtype alert_rule: str
        :keyword smart_group_id: Filter the alerts list by the Smart Group Id. Default value is none.
         Default value is None.
        :paramtype smart_group_id: str
        :keyword include_context: Include context which has contextual data specific to the monitor
         service. Default value is false'. Default value is None.
        :paramtype include_context: bool
        :keyword include_egress_config: Include egress config which would be used for displaying the
         content in portal.  Default value is 'false'. Default value is None.
        :paramtype include_egress_config: bool
        :keyword page_count: Determines number of alerts returned per page in response. Permissible
         value is between 1 to 250. When the "includeContent"  filter is selected, maximum value allowed
         is 25. Default value is 25. Default value is None.
        :paramtype page_count: int
        :keyword sort_by: Sort the query results by input field,  Default value is
         'lastModifiedDateTime'. Known values are: "name", "severity", "alertState", "monitorCondition",
         "targetResource", "targetResourceName", "targetResourceGroup", "targetResourceType",
         "startDateTime", and "lastModifiedDateTime". Default value is None.
        :paramtype sort_by: str or ~azure.mgmt.alertsmanagement.models.AlertsSortByFields
        :keyword sort_order: Sort the query results order in either ascending or descending.  Default
         value is 'desc' for time fields and 'asc' for others. Known values are: "asc" and "desc".
         Default value is None.
        :paramtype sort_order: str or ~azure.mgmt.alertsmanagement.models.SortOrder
        :keyword select: This filter allows to selection of the fields(comma separated) which would  be
         part of the essential section. This would allow to project only the  required fields rather
         than getting entire content.  Default is to fetch all the fields in the essentials section.
         Default value is None.
        :paramtype select: str
        :keyword time_range: Filter by time range by below listed values. Default value is 1 day. Known
         values are: "1h", "1d", "7d", and "30d". Default value is None.
        :paramtype time_range: str or ~azure.mgmt.alertsmanagement.models.TimeRange
        :keyword custom_time_range: Filter by custom time range in the format <start-time>/<end-time>
         where time is in (ISO-8601 format)'. Permissible values is within 30 days from  query time.
         Either timeRange or customTimeRange could be used but not both. Default is none. Default value
         is None.
        :paramtype custom_time_range: str
        :return: An iterator like instance of Alert
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.alertsmanagement.models.Alert]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Alert]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_alerts_get_all_tenant_request(
                    target_resource=target_resource,
                    target_resource_type=target_resource_type,
                    target_resource_group=target_resource_group,
                    monitor_service=monitor_service,
                    monitor_condition=monitor_condition,
                    severity=severity,
                    alert_state=alert_state,
                    alert_rule=alert_rule,
                    smart_group_id=smart_group_id,
                    include_context=include_context,
                    include_egress_config=include_egress_config,
                    page_count=page_count,
                    sort_by=sort_by,
                    sort_order=sort_order,
                    select=select,
                    time_range=time_range,
                    custom_time_range=custom_time_range,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Alert], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.AlertsManagementErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_by_id(self, scope: str, alert_id: str, **kwargs: Any) -> _models.Alert:
        """Get a specific alert.

        Get information related to a specific alert. If scope is a deleted resource then please use
        scope as parent resource of the delete resource. For example if my alert id is
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/virtualMachines/vm1/providers/Microsoft.AlertsManagement/alerts/{alertId}'
        and 'vm1' is deleted then if you want to get alert by id then use parent resource of scope. So
        in this example get alert by id call will look like this:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.AlertsManagement/alerts/{alertId}'.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)

        _request = build_alerts_get_by_id_request(
            scope=scope,
            alert_id=alert_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Alert, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_all(  # pylint: disable=too-many-locals
        self,
        scope: str,
        *,
        target_resource: Optional[str] = None,
        target_resource_type: Optional[str] = None,
        target_resource_group: Optional[str] = None,
        monitor_service: Optional[Union[str, _models.MonitorService]] = None,
        monitor_condition: Optional[Union[str, _models.MonitorCondition]] = None,
        severity: Optional[Union[str, _models.Severity]] = None,
        alert_state: Optional[Union[str, _models.AlertState]] = None,
        alert_rule: Optional[str] = None,
        smart_group_id: Optional[str] = None,
        include_context: Optional[bool] = None,
        include_egress_config: Optional[bool] = None,
        page_count: Optional[int] = None,
        sort_by: Optional[Union[str, _models.AlertsSortByFields]] = None,
        sort_order: Optional[Union[str, _models.SortOrder]] = None,
        select: Optional[str] = None,
        time_range: Optional[Union[str, _models.TimeRange]] = None,
        custom_time_range: Optional[str] = None,
        **kwargs: Any
    ) -> ItemPaged["_models.Alert"]:
        """List all existing alerts, where the results can be filtered on the basis of multiple parameters
        (e.g. time range). The results can then be sorted on the basis specific fields, with the
        default being lastModifiedDateTime.

        :param scope: undefined. Required.
        :type scope: str
        :keyword target_resource: Filter by target resource( which is full ARM ID) Default value is
         select all. Default value is None.
        :paramtype target_resource: str
        :keyword target_resource_type: Filter by target resource type. Default value is select all.
         Default value is None.
        :paramtype target_resource_type: str
        :keyword target_resource_group: Filter by target resource group name. Default value is select
         all. Default value is None.
        :paramtype target_resource_group: str
        :keyword monitor_service: Filter by monitor service which generates the alert instance. Default
         value is select all. Known values are: "Application Insights", "ActivityLog Administrative",
         "ActivityLog Security", "ActivityLog Recommendation", "ActivityLog Policy", "ActivityLog
         Autoscale", "Log Analytics", "Nagios", "Platform", "SCOM", "ServiceHealth", "SmartDetector",
         "VM Insights", "Zabbix", and "Resource Health". Default value is None.
        :paramtype monitor_service: str or ~azure.mgmt.alertsmanagement.models.MonitorService
        :keyword monitor_condition: Filter by monitor condition which is either 'Fired' or 'Resolved'.
         Default value is to select all. Known values are: "Fired" and "Resolved". Default value is
         None.
        :paramtype monitor_condition: str or ~azure.mgmt.alertsmanagement.models.MonitorCondition
        :keyword severity: Filter by severity.  Default value is select all. Known values are: "Sev0",
         "Sev1", "Sev2", "Sev3", and "Sev4". Default value is None.
        :paramtype severity: str or ~azure.mgmt.alertsmanagement.models.Severity
        :keyword alert_state: Filter by state of the alert instance. Default value is to select all.
         Known values are: "New", "Acknowledged", and "Closed". Default value is None.
        :paramtype alert_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword alert_rule: Filter by specific alert rule.  Default value is to select all. Default
         value is None.
        :paramtype alert_rule: str
        :keyword smart_group_id: Filter the alerts list by the Smart Group Id. Default value is none.
         Default value is None.
        :paramtype smart_group_id: str
        :keyword include_context: Include context which has contextual data specific to the monitor
         service. Default value is false'. Default value is None.
        :paramtype include_context: bool
        :keyword include_egress_config: Include egress config which would be used for displaying the
         content in portal.  Default value is 'false'. Default value is None.
        :paramtype include_egress_config: bool
        :keyword page_count: Determines number of alerts returned per page in response. Permissible
         value is between 1 to 250. When the "includeContent"  filter is selected, maximum value allowed
         is 25. Default value is 25. Default value is None.
        :paramtype page_count: int
        :keyword sort_by: Sort the query results by input field,  Default value is
         'lastModifiedDateTime'. Known values are: "name", "severity", "alertState", "monitorCondition",
         "targetResource", "targetResourceName", "targetResourceGroup", "targetResourceType",
         "startDateTime", and "lastModifiedDateTime". Default value is None.
        :paramtype sort_by: str or ~azure.mgmt.alertsmanagement.models.AlertsSortByFields
        :keyword sort_order: Sort the query results order in either ascending or descending.  Default
         value is 'desc' for time fields and 'asc' for others. Known values are: "asc" and "desc".
         Default value is None.
        :paramtype sort_order: str or ~azure.mgmt.alertsmanagement.models.SortOrder
        :keyword select: This filter allows to selection of the fields(comma separated) which would  be
         part of the essential section. This would allow to project only the  required fields rather
         than getting entire content.  Default is to fetch all the fields in the essentials section.
         Default value is None.
        :paramtype select: str
        :keyword time_range: Filter by time range by below listed values. Default value is 1 day. Known
         values are: "1h", "1d", "7d", and "30d". Default value is None.
        :paramtype time_range: str or ~azure.mgmt.alertsmanagement.models.TimeRange
        :keyword custom_time_range: Filter by custom time range in the format <start-time>/<end-time>
         where time is in (ISO-8601 format)'. Permissible values is within 30 days from  query time.
         Either timeRange or customTimeRange could be used but not both. Default is none. Default value
         is None.
        :paramtype custom_time_range: str
        :return: An iterator like instance of Alert
        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.alertsmanagement.models.Alert]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Alert]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_alerts_get_all_request(
                    scope=scope,
                    target_resource=target_resource,
                    target_resource_type=target_resource_type,
                    target_resource_group=target_resource_group,
                    monitor_service=monitor_service,
                    monitor_condition=monitor_condition,
                    severity=severity,
                    alert_state=alert_state,
                    alert_rule=alert_rule,
                    smart_group_id=smart_group_id,
                    include_context=include_context,
                    include_egress_config=include_egress_config,
                    page_count=page_count,
                    sort_by=sort_by,
                    sort_order=sort_order,
                    select=select,
                    time_range=time_range,
                    custom_time_range=custom_time_range,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Alert], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.AlertsManagementErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def change_state(
        self,
        scope: str,
        alert_id: str,
        comment: Optional[_models.Comments] = None,
        *,
        new_state: Union[str, _models.AlertState],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert. If scope is a deleted resource then please use scope as parent
        resource of the delete resource. For example if my alert id is
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/virtualMachines/vm1/providers/Microsoft.AlertsManagement/alerts/{alertId}'
        and 'vm1' is deleted then if you want to change state of this particular alert then use parent
        resource of scope. So in this example change state call will look like this:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.AlertsManagement/alerts/{alertId}'.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Default value is None.
        :type comment: ~azure.mgmt.alertsmanagement.models.Comments
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def change_state(
        self,
        scope: str,
        alert_id: str,
        comment: Optional[JSON] = None,
        *,
        new_state: Union[str, _models.AlertState],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert. If scope is a deleted resource then please use scope as parent
        resource of the delete resource. For example if my alert id is
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/virtualMachines/vm1/providers/Microsoft.AlertsManagement/alerts/{alertId}'
        and 'vm1' is deleted then if you want to change state of this particular alert then use parent
        resource of scope. So in this example change state call will look like this:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.AlertsManagement/alerts/{alertId}'.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Default value is None.
        :type comment: JSON
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def change_state(
        self,
        scope: str,
        alert_id: str,
        comment: Optional[IO[bytes]] = None,
        *,
        new_state: Union[str, _models.AlertState],
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert. If scope is a deleted resource then please use scope as parent
        resource of the delete resource. For example if my alert id is
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/virtualMachines/vm1/providers/Microsoft.AlertsManagement/alerts/{alertId}'
        and 'vm1' is deleted then if you want to change state of this particular alert then use parent
        resource of scope. So in this example change state call will look like this:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.AlertsManagement/alerts/{alertId}'.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Default value is None.
        :type comment: IO[bytes]
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def change_state(
        self,
        scope: str,
        alert_id: str,
        comment: Optional[Union[_models.Comments, JSON, IO[bytes]]] = None,
        *,
        new_state: Union[str, _models.AlertState],
        **kwargs: Any
    ) -> _models.Alert:
        """Change the state of an alert. If scope is a deleted resource then please use scope as parent
        resource of the delete resource. For example if my alert id is
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/virtualMachines/vm1/providers/Microsoft.AlertsManagement/alerts/{alertId}'
        and 'vm1' is deleted then if you want to change state of this particular alert then use parent
        resource of scope. So in this example change state call will look like this:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.AlertsManagement/alerts/{alertId}'.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :param comment: reason of change alert state. Is one of the following types: Comments, JSON,
         IO[bytes] Default value is None.
        :type comment: ~azure.mgmt.alertsmanagement.models.Comments or JSON or IO[bytes]
        :keyword new_state: New state of the alert. Known values are: "New", "Acknowledged", and
         "Closed". Required.
        :paramtype new_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :return: Alert. The Alert is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.Alert
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        content_type = content_type if comment else None
        cls: ClsType[_models.Alert] = kwargs.pop("cls", None)

        content_type = content_type or "application/json" if comment else None
        _content = None
        if isinstance(comment, (IOBase, bytes)):
            _content = comment
        else:
            if comment is not None:
                _content = json.dumps(comment, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_alerts_change_state_request(
            scope=scope,
            alert_id=alert_id,
            new_state=new_state,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Alert, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_history(self, scope: str, alert_id: str, **kwargs: Any) -> _models.AlertModification:
        """Get the history of an alert, which captures any monitor condition changes (Fired/Resolved),
        alert state changes (New/Acknowledged/Closed) and applied action rules for that particular
        alert. If scope is a deleted resource then please use scope as parent resource of the delete
        resource. For example if my alert id is
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/virtualMachines/vm1/providers/Microsoft.AlertsManagement/alerts/{alertId}'
        and 'vm1' is deleted then if you want to get history of this particular alert then use parent
        resource of scope. So in this example get history call will look like this:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.AlertsManagement/alerts/{alertId}/history'.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :return: AlertModification. The AlertModification is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.AlertModification
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AlertModification] = kwargs.pop("cls", None)

        _request = build_alerts_get_history_request(
            scope=scope,
            alert_id=alert_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AlertModification, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_enrichments(self, scope: str, alert_id: str, **kwargs: Any) -> ItemPaged["_models.AlertEnrichmentResponse"]:
        """Get the enrichments of an alert. It returns a collection of one object named default.

        :param scope: undefined. Required.
        :type scope: str
        :param alert_id: Unique ID of an alert instance. Required.
        :type alert_id: str
        :return: An iterator like instance of AlertEnrichmentResponse
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.mgmt.alertsmanagement.models.AlertEnrichmentResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AlertEnrichmentResponse]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_alerts_get_enrichments_request(
                    scope=scope,
                    alert_id=alert_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.AlertEnrichmentResponse], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def meta_data(self, *, identifier: Union[str, _models.Identifier], **kwargs: Any) -> _models.AlertsMetaData:
        """List alerts meta data information based on value of identifier parameter.

        :keyword identifier: Identification of the information to be retrieved by API call.
         "MonitorServiceList" Required.
        :paramtype identifier: str or ~azure.mgmt.alertsmanagement.models.Identifier
        :return: AlertsMetaData. The AlertsMetaData is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.AlertsMetaData
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AlertsMetaData] = kwargs.pop("cls", None)

        _request = build_alerts_meta_data_request(
            identifier=identifier,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AlertsMetaData, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_summary(  # pylint: disable=too-many-locals
        self,
        scope: str,
        *,
        groupby: Union[str, _models.AlertsSummaryGroupByFields],
        include_smart_groups_count: Optional[bool] = None,
        target_resource: Optional[str] = None,
        target_resource_type: Optional[str] = None,
        target_resource_group: Optional[str] = None,
        monitor_service: Optional[Union[str, _models.MonitorService]] = None,
        monitor_condition: Optional[Union[str, _models.MonitorCondition]] = None,
        severity: Optional[Union[str, _models.Severity]] = None,
        alert_state: Optional[Union[str, _models.AlertState]] = None,
        alert_rule: Optional[str] = None,
        time_range: Optional[Union[str, _models.TimeRange]] = None,
        custom_time_range: Optional[str] = None,
        **kwargs: Any
    ) -> _models.AlertsSummary:
        """Get a summarized count of your alerts grouped by various parameters (e.g. grouping by
        'Severity' returns the count of alerts for each severity).

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :keyword groupby: This parameter allows the result set to be grouped by input fields. For
         example, groupby=severity,alertstate. Known values are: "severity", "alertState",
         "monitorCondition", "monitorService", "signalType", and "alertRule". Required.
        :paramtype groupby: str or ~azure.mgmt.alertsmanagement.models.AlertsSummaryGroupByFields
        :keyword include_smart_groups_count: Include count of the SmartGroups as part of the summary.
         Default value is 'false'. Default value is None.
        :paramtype include_smart_groups_count: bool
        :keyword target_resource: Filter by target resource( which is full ARM ID) Default value is
         select all. Default value is None.
        :paramtype target_resource: str
        :keyword target_resource_type: Filter by target resource type. Default value is select all.
         Default value is None.
        :paramtype target_resource_type: str
        :keyword target_resource_group: Filter by target resource group name. Default value is select
         all. Default value is None.
        :paramtype target_resource_group: str
        :keyword monitor_service: Filter by monitor service which generates the alert instance. Default
         value is select all. Known values are: "Application Insights", "ActivityLog Administrative",
         "ActivityLog Security", "ActivityLog Recommendation", "ActivityLog Policy", "ActivityLog
         Autoscale", "Log Analytics", "Nagios", "Platform", "SCOM", "ServiceHealth", "SmartDetector",
         "VM Insights", "Zabbix", and "Resource Health". Default value is None.
        :paramtype monitor_service: str or ~azure.mgmt.alertsmanagement.models.MonitorService
        :keyword monitor_condition: Filter by monitor condition which is either 'Fired' or 'Resolved'.
         Default value is to select all. Known values are: "Fired" and "Resolved". Default value is
         None.
        :paramtype monitor_condition: str or ~azure.mgmt.alertsmanagement.models.MonitorCondition
        :keyword severity: Filter by severity.  Default value is select all. Known values are: "Sev0",
         "Sev1", "Sev2", "Sev3", and "Sev4". Default value is None.
        :paramtype severity: str or ~azure.mgmt.alertsmanagement.models.Severity
        :keyword alert_state: Filter by state of the alert instance. Default value is to select all.
         Known values are: "New", "Acknowledged", and "Closed". Default value is None.
        :paramtype alert_state: str or ~azure.mgmt.alertsmanagement.models.AlertState
        :keyword alert_rule: Filter by specific alert rule.  Default value is to select all. Default
         value is None.
        :paramtype alert_rule: str
        :keyword time_range: Filter by time range by below listed values. Default value is 1 day. Known
         values are: "1h", "1d", "7d", and "30d". Default value is None.
        :paramtype time_range: str or ~azure.mgmt.alertsmanagement.models.TimeRange
        :keyword custom_time_range: Filter by custom time range in the format <start-time>/<end-time>
         where time is in (ISO-8601 format)'. Permissible values is within 30 days from  query time.
         Either timeRange or customTimeRange could be used but not both. Default is none. Default value
         is None.
        :paramtype custom_time_range: str
        :return: AlertsSummary. The AlertsSummary is compatible with MutableMapping
        :rtype: ~azure.mgmt.alertsmanagement.models.AlertsSummary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AlertsSummary] = kwargs.pop("cls", None)

        _request = build_alerts_get_summary_request(
            scope=scope,
            groupby=groupby,
            include_smart_groups_count=include_smart_groups_count,
            target_resource=target_resource,
            target_resource_type=target_resource_type,
            target_resource_group=target_resource_group,
            monitor_service=monitor_service,
            monitor_condition=monitor_condition,
            severity=severity,
            alert_state=alert_state,
            alert_rule=alert_rule,
            time_range=time_range,
            custom_time_range=custom_time_range,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.AlertsManagementErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AlertsSummary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
