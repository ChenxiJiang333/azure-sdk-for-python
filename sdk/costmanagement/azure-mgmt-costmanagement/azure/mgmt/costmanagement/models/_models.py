# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
# pylint: disable=useless-super-delegation

import datetime
import decimal
from typing import Any, Literal, Mapping, Optional, TYPE_CHECKING, Union, overload

from .._utils.model_base import Model as _Model, rest_discriminator, rest_field
from ._enums import BenefitKind, Scope, SettingsKind

if TYPE_CHECKING:
    from .. import models as _models


class Resource(_Model):
    """Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}."""
    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the resource."""
    type: Optional[str] = rest_field(visibility=["read"])
    """The type of the resource. E.g. \"Microsoft.Compute/virtualMachines\" or
     \"Microsoft.Storage/storageAccounts\"."""
    system_data: Optional["_models.SystemData"] = rest_field(name="systemData", visibility=["read"])
    """Azure Resource Manager metadata containing createdBy and modifiedBy information."""


class ExtensionResource(Resource):
    """The base extension resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    """


class Alert(ExtensionResource):
    """An individual alert.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: Alert properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.AlertProperties
    :ivar e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
     used to determine whether the user is updating the latest version or not.
    :vartype e_tag: str
    """

    properties: Optional["_models.AlertProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Alert properties."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read", "create", "update", "delete", "query"])
    """eTag of the resource. To handle concurrent update scenario, this field will be used to
     determine whether the user is updating the latest version or not."""

    __flattened_items = [
        "definition",
        "description",
        "source",
        "details",
        "cost_entity_id",
        "status",
        "creation_time",
        "close_time",
        "modification_time",
        "status_modification_user_name",
        "status_modification_time",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.AlertProperties"] = None,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class AlertProperties(_Model):
    """Alert properties.

    :ivar definition: defines the type of alert.
    :vartype definition: ~azure.mgmt.costmanagement.models.AlertPropertiesDefinition
    :ivar description: Alert description.
    :vartype description: str
    :ivar source: Source of alert. Known values are: "Preset" and "User".
    :vartype source: str or ~azure.mgmt.costmanagement.models.AlertSource
    :ivar details: Alert details.
    :vartype details: ~azure.mgmt.costmanagement.models.AlertPropertiesDetails
    :ivar cost_entity_id: related budget.
    :vartype cost_entity_id: str
    :ivar status: alert status. Known values are: "None", "Active", "Overridden", "Resolved", and
     "Dismissed".
    :vartype status: str or ~azure.mgmt.costmanagement.models.AlertStatus
    :ivar creation_time: dateTime in which alert was created.
    :vartype creation_time: str
    :ivar close_time: dateTime in which alert was closed.
    :vartype close_time: str
    :ivar modification_time: dateTime in which alert was last modified.
    :vartype modification_time: str
    :ivar status_modification_user_name: User who last modified the alert.
    :vartype status_modification_user_name: str
    :ivar status_modification_time: dateTime in which the alert status was last modified.
    :vartype status_modification_time: str
    """

    definition: Optional["_models.AlertPropertiesDefinition"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """defines the type of alert."""
    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Alert description."""
    source: Optional[Union[str, "_models.AlertSource"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Source of alert. Known values are: \"Preset\" and \"User\"."""
    details: Optional["_models.AlertPropertiesDetails"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Alert details."""
    cost_entity_id: Optional[str] = rest_field(
        name="costEntityId", visibility=["read", "create", "update", "delete", "query"]
    )
    """related budget."""
    status: Optional[Union[str, "_models.AlertStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """alert status. Known values are: \"None\", \"Active\", \"Overridden\", \"Resolved\", and
     \"Dismissed\"."""
    creation_time: Optional[str] = rest_field(
        name="creationTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """dateTime in which alert was created."""
    close_time: Optional[str] = rest_field(name="closeTime", visibility=["read", "create", "update", "delete", "query"])
    """dateTime in which alert was closed."""
    modification_time: Optional[str] = rest_field(
        name="modificationTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """dateTime in which alert was last modified."""
    status_modification_user_name: Optional[str] = rest_field(
        name="statusModificationUserName", visibility=["read", "create", "update", "delete", "query"]
    )
    """User who last modified the alert."""
    status_modification_time: Optional[str] = rest_field(
        name="statusModificationTime", visibility=["read", "create", "update", "delete", "query"]
    )
    """dateTime in which the alert status was last modified."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.AlertPropertiesDefinition"] = None,
        description: Optional[str] = None,
        source: Optional[Union[str, "_models.AlertSource"]] = None,
        details: Optional["_models.AlertPropertiesDetails"] = None,
        cost_entity_id: Optional[str] = None,
        status: Optional[Union[str, "_models.AlertStatus"]] = None,
        creation_time: Optional[str] = None,
        close_time: Optional[str] = None,
        modification_time: Optional[str] = None,
        status_modification_user_name: Optional[str] = None,
        status_modification_time: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AlertPropertiesDefinition(_Model):
    """defines the type of alert.

    :ivar type: type of alert. Known values are: "Budget", "Invoice", "Credit", "Quota", "General",
     "xCloud", and "BudgetForecast".
    :vartype type: str or ~azure.mgmt.costmanagement.models.AlertType
    :ivar category: Alert category. Known values are: "Cost", "Usage", "Billing", and "System".
    :vartype category: str or ~azure.mgmt.costmanagement.models.AlertCategory
    :ivar criteria: Criteria that triggered alert. Known values are: "CostThresholdExceeded",
     "UsageThresholdExceeded", "CreditThresholdApproaching", "CreditThresholdReached",
     "QuotaThresholdApproaching", "QuotaThresholdReached", "MultiCurrency",
     "ForecastCostThresholdExceeded", "ForecastUsageThresholdExceeded", "InvoiceDueDateApproaching",
     "InvoiceDueDateReached", "CrossCloudNewDataAvailable", "CrossCloudCollectionError", and
     "GeneralThresholdError".
    :vartype criteria: str or ~azure.mgmt.costmanagement.models.AlertCriteria
    """

    type: Optional[Union[str, "_models.AlertType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """type of alert. Known values are: \"Budget\", \"Invoice\", \"Credit\", \"Quota\", \"General\",
     \"xCloud\", and \"BudgetForecast\"."""
    category: Optional[Union[str, "_models.AlertCategory"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Alert category. Known values are: \"Cost\", \"Usage\", \"Billing\", and \"System\"."""
    criteria: Optional[Union[str, "_models.AlertCriteria"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Criteria that triggered alert. Known values are: \"CostThresholdExceeded\",
     \"UsageThresholdExceeded\", \"CreditThresholdApproaching\", \"CreditThresholdReached\",
     \"QuotaThresholdApproaching\", \"QuotaThresholdReached\", \"MultiCurrency\",
     \"ForecastCostThresholdExceeded\", \"ForecastUsageThresholdExceeded\",
     \"InvoiceDueDateApproaching\", \"InvoiceDueDateReached\", \"CrossCloudNewDataAvailable\",
     \"CrossCloudCollectionError\", and \"GeneralThresholdError\"."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.AlertType"]] = None,
        category: Optional[Union[str, "_models.AlertCategory"]] = None,
        criteria: Optional[Union[str, "_models.AlertCriteria"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AlertPropertiesDetails(_Model):
    """Alert details.

    :ivar time_grain_type: Type of timegrain cadence. Known values are: "None", "Monthly",
     "Quarterly", "Annually", "BillingMonth", "BillingQuarter", and "BillingAnnual".
    :vartype time_grain_type: str or ~azure.mgmt.costmanagement.models.AlertTimeGrainType
    :ivar period_start_date: datetime of periodStartDate.
    :vartype period_start_date: str
    :ivar triggered_by: notificationId that triggered this alert.
    :vartype triggered_by: str
    :ivar resource_group_filter: array of resourceGroups to filter by.
    :vartype resource_group_filter: list[any]
    :ivar resource_filter: array of resources to filter by.
    :vartype resource_filter: list[any]
    :ivar meter_filter: array of meters to filter by.
    :vartype meter_filter: list[any]
    :ivar tag_filter: tags to filter by.
    :vartype tag_filter: any
    :ivar threshold: notification threshold percentage as a decimal which activated this alert.
    :vartype threshold: ~decimal.Decimal
    :ivar operator: operator used to compare currentSpend with amount. Known values are: "None",
     "EqualTo", "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and "LessThanOrEqualTo".
    :vartype operator: str or ~azure.mgmt.costmanagement.models.AlertOperator
    :ivar amount: budget threshold amount.
    :vartype amount: ~decimal.Decimal
    :ivar unit: unit of currency being used.
    :vartype unit: str
    :ivar current_spend: current spend.
    :vartype current_spend: ~decimal.Decimal
    :ivar contact_emails: list of emails to contact.
    :vartype contact_emails: list[str]
    :ivar contact_groups: list of action groups to broadcast to.
    :vartype contact_groups: list[str]
    :ivar contact_roles: list of contact roles.
    :vartype contact_roles: list[str]
    :ivar overriding_alert: overriding alert.
    :vartype overriding_alert: str
    :ivar department_name: department name.
    :vartype department_name: str
    :ivar company_name: company name.
    :vartype company_name: str
    :ivar enrollment_number: enrollment number.
    :vartype enrollment_number: str
    :ivar enrollment_start_date: datetime of enrollmentStartDate.
    :vartype enrollment_start_date: str
    :ivar enrollment_end_date: datetime of enrollmentEndDate.
    :vartype enrollment_end_date: str
    :ivar invoicing_threshold: invoicing threshold.
    :vartype invoicing_threshold: ~decimal.Decimal
    """

    time_grain_type: Optional[Union[str, "_models.AlertTimeGrainType"]] = rest_field(
        name="timeGrainType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of timegrain cadence. Known values are: \"None\", \"Monthly\", \"Quarterly\",
     \"Annually\", \"BillingMonth\", \"BillingQuarter\", and \"BillingAnnual\"."""
    period_start_date: Optional[str] = rest_field(
        name="periodStartDate", visibility=["read", "create", "update", "delete", "query"]
    )
    """datetime of periodStartDate."""
    triggered_by: Optional[str] = rest_field(
        name="triggeredBy", visibility=["read", "create", "update", "delete", "query"]
    )
    """notificationId that triggered this alert."""
    resource_group_filter: Optional[list[Any]] = rest_field(
        name="resourceGroupFilter", visibility=["read", "create", "update", "delete", "query"]
    )
    """array of resourceGroups to filter by."""
    resource_filter: Optional[list[Any]] = rest_field(
        name="resourceFilter", visibility=["read", "create", "update", "delete", "query"]
    )
    """array of resources to filter by."""
    meter_filter: Optional[list[Any]] = rest_field(
        name="meterFilter", visibility=["read", "create", "update", "delete", "query"]
    )
    """array of meters to filter by."""
    tag_filter: Optional[Any] = rest_field(name="tagFilter", visibility=["read", "create", "update", "delete", "query"])
    """tags to filter by."""
    threshold: Optional[decimal.Decimal] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """notification threshold percentage as a decimal which activated this alert."""
    operator: Optional[Union[str, "_models.AlertOperator"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """operator used to compare currentSpend with amount. Known values are: \"None\", \"EqualTo\",
     \"GreaterThan\", \"GreaterThanOrEqualTo\", \"LessThan\", and \"LessThanOrEqualTo\"."""
    amount: Optional[decimal.Decimal] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """budget threshold amount."""
    unit: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """unit of currency being used."""
    current_spend: Optional[decimal.Decimal] = rest_field(
        name="currentSpend", visibility=["read", "create", "update", "delete", "query"]
    )
    """current spend."""
    contact_emails: Optional[list[str]] = rest_field(
        name="contactEmails", visibility=["read", "create", "update", "delete", "query"]
    )
    """list of emails to contact."""
    contact_groups: Optional[list[str]] = rest_field(
        name="contactGroups", visibility=["read", "create", "update", "delete", "query"]
    )
    """list of action groups to broadcast to."""
    contact_roles: Optional[list[str]] = rest_field(
        name="contactRoles", visibility=["read", "create", "update", "delete", "query"]
    )
    """list of contact roles."""
    overriding_alert: Optional[str] = rest_field(
        name="overridingAlert", visibility=["read", "create", "update", "delete", "query"]
    )
    """overriding alert."""
    department_name: Optional[str] = rest_field(
        name="departmentName", visibility=["read", "create", "update", "delete", "query"]
    )
    """department name."""
    company_name: Optional[str] = rest_field(
        name="companyName", visibility=["read", "create", "update", "delete", "query"]
    )
    """company name."""
    enrollment_number: Optional[str] = rest_field(
        name="enrollmentNumber", visibility=["read", "create", "update", "delete", "query"]
    )
    """enrollment number."""
    enrollment_start_date: Optional[str] = rest_field(
        name="enrollmentStartDate", visibility=["read", "create", "update", "delete", "query"]
    )
    """datetime of enrollmentStartDate."""
    enrollment_end_date: Optional[str] = rest_field(
        name="enrollmentEndDate", visibility=["read", "create", "update", "delete", "query"]
    )
    """datetime of enrollmentEndDate."""
    invoicing_threshold: Optional[decimal.Decimal] = rest_field(
        name="invoicingThreshold", visibility=["read", "create", "update", "delete", "query"]
    )
    """invoicing threshold."""

    @overload
    def __init__(
        self,
        *,
        time_grain_type: Optional[Union[str, "_models.AlertTimeGrainType"]] = None,
        period_start_date: Optional[str] = None,
        triggered_by: Optional[str] = None,
        resource_group_filter: Optional[list[Any]] = None,
        resource_filter: Optional[list[Any]] = None,
        meter_filter: Optional[list[Any]] = None,
        tag_filter: Optional[Any] = None,
        threshold: Optional[decimal.Decimal] = None,
        operator: Optional[Union[str, "_models.AlertOperator"]] = None,
        amount: Optional[decimal.Decimal] = None,
        unit: Optional[str] = None,
        current_spend: Optional[decimal.Decimal] = None,
        contact_emails: Optional[list[str]] = None,
        contact_groups: Optional[list[str]] = None,
        contact_roles: Optional[list[str]] = None,
        overriding_alert: Optional[str] = None,
        department_name: Optional[str] = None,
        company_name: Optional[str] = None,
        enrollment_number: Optional[str] = None,
        enrollment_start_date: Optional[str] = None,
        enrollment_end_date: Optional[str] = None,
        invoicing_threshold: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AlertsResult(_Model):
    """Result of alerts.

    :ivar value: List of alerts.
    :vartype value: list[~azure.mgmt.costmanagement.models.Alert]
    :ivar next_link: URL to get the next set of alerts results if there are any.
    :vartype next_link: str
    """

    value: Optional[list["_models.Alert"]] = rest_field(visibility=["read"])
    """List of alerts."""
    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read"])
    """URL to get the next set of alerts results if there are any."""


class AllSavingsBenefitDetails(_Model):
    """Benefit recommendation details.

    :ivar overage_cost: The difference between total cost and benefit cost for the 'totalHours' in
     the look-back period.
    :vartype overage_cost: ~decimal.Decimal
    :ivar benefit_cost: The estimated cost with benefit for the 'totalHours' in the look-back
     period. It's equal to (commitmentAmount * totalHours).
    :vartype benefit_cost: ~decimal.Decimal
    :ivar total_cost: Total cost, which is sum of benefit cost and overage cost.
    :vartype total_cost: ~decimal.Decimal
    :ivar savings_amount: The amount saved for the 'totalHours' in the look-back period, by
     purchasing the recommended quantity of the benefit.
    :vartype savings_amount: ~decimal.Decimal
    :ivar savings_percentage: The savings in percentage for the 'totalHours' in the look-back
     period, by purchasing the recommended quantity of benefit.
    :vartype savings_percentage: ~decimal.Decimal
    :ivar coverage_percentage: Estimated benefit coverage percentage for the 'totalHours' in the
     look-back period, with this commitment.
    :vartype coverage_percentage: ~decimal.Decimal
    :ivar commitment_amount: The commitment amount at the commitmentGranularity.
    :vartype commitment_amount: ~decimal.Decimal
    :ivar average_utilization_percentage: Estimated average utilization percentage for the
     'totalHours' in the look-back period, with this commitment.
    :vartype average_utilization_percentage: ~decimal.Decimal
    :ivar wastage_cost: Estimated unused portion of the 'benefitCost'.
    :vartype wastage_cost: ~decimal.Decimal
    """

    overage_cost: Optional[decimal.Decimal] = rest_field(name="overageCost", visibility=["read"])
    """The difference between total cost and benefit cost for the 'totalHours' in the look-back
     period."""
    benefit_cost: Optional[decimal.Decimal] = rest_field(name="benefitCost", visibility=["read"])
    """The estimated cost with benefit for the 'totalHours' in the look-back period. It's equal to
     (commitmentAmount * totalHours)."""
    total_cost: Optional[decimal.Decimal] = rest_field(name="totalCost", visibility=["read"])
    """Total cost, which is sum of benefit cost and overage cost."""
    savings_amount: Optional[decimal.Decimal] = rest_field(name="savingsAmount", visibility=["read"])
    """The amount saved for the 'totalHours' in the look-back period, by purchasing the recommended
     quantity of the benefit."""
    savings_percentage: Optional[decimal.Decimal] = rest_field(name="savingsPercentage", visibility=["read"])
    """The savings in percentage for the 'totalHours' in the look-back period, by purchasing the
     recommended quantity of benefit."""
    coverage_percentage: Optional[decimal.Decimal] = rest_field(name="coveragePercentage", visibility=["read"])
    """Estimated benefit coverage percentage for the 'totalHours' in the look-back period, with this
     commitment."""
    commitment_amount: Optional[decimal.Decimal] = rest_field(name="commitmentAmount", visibility=["read"])
    """The commitment amount at the commitmentGranularity."""
    average_utilization_percentage: Optional[decimal.Decimal] = rest_field(
        name="averageUtilizationPercentage", visibility=["read"]
    )
    """Estimated average utilization percentage for the 'totalHours' in the look-back period, with
     this commitment."""
    wastage_cost: Optional[decimal.Decimal] = rest_field(name="wastageCost", visibility=["read"])
    """Estimated unused portion of the 'benefitCost'."""


class AllSavingsList(_Model):
    """The list of all benefit recommendations with the recommendation details.

    :ivar value: The list of benefit recommendations with the recommendation details..
    :vartype value: list[~azure.mgmt.costmanagement.models.AllSavingsBenefitDetails]
    :ivar next_link: The link (URL) to the next page of results.
    :vartype next_link: str
    """

    value: Optional[list["_models.AllSavingsBenefitDetails"]] = rest_field(visibility=["read"])
    """The list of benefit recommendations with the recommendation details.."""
    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read"])
    """The link (URL) to the next page of results."""


class ArmErrorResponse(_Model):
    """Error response.

    :ivar error: The error object.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetail
    """

    error: Optional["_models.ErrorDetail"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The error object."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetail"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncOperationStatusProperties(_Model):
    """Object representing the report url and valid until date of the async report generated.

    :ivar report_url: Sas url to the async benefit utilization summaries report. Will be empty if
     the report is in Running or Failed state. Known values are: "Kind", "AvgUtilizationPercentage",
     "BenefitOrderId", "BenefitId", "BenefitType", "MaxUtilizationPercentage",
     "MinUtilizationPercentage", "UsageDate", and "UtilizedPercentage".
    :vartype report_url: str or
     ~azure.mgmt.costmanagement.models.BenefitUtilizationSummaryReportSchema
    :ivar secondary_report_url: Sas url to async benefit utilization summaries report in secondary
     storage in case of primary outage. Will be empty if the report is in Running or Failed state.
     Known values are: "Kind", "AvgUtilizationPercentage", "BenefitOrderId", "BenefitId",
     "BenefitType", "MaxUtilizationPercentage", "MinUtilizationPercentage", "UsageDate", and
     "UtilizedPercentage".
    :vartype secondary_report_url: str or
     ~azure.mgmt.costmanagement.models.BenefitUtilizationSummaryReportSchema
    :ivar valid_until: The date that the sas url provided in reportUrl expires.
    :vartype valid_until: ~datetime.datetime
    """

    report_url: Optional[Union[str, "_models.BenefitUtilizationSummaryReportSchema"]] = rest_field(
        name="reportUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sas url to the async benefit utilization summaries report. Will be empty if the report is in
     Running or Failed state. Known values are: \"Kind\", \"AvgUtilizationPercentage\",
     \"BenefitOrderId\", \"BenefitId\", \"BenefitType\", \"MaxUtilizationPercentage\",
     \"MinUtilizationPercentage\", \"UsageDate\", and \"UtilizedPercentage\"."""
    secondary_report_url: Optional[Union[str, "_models.BenefitUtilizationSummaryReportSchema"]] = rest_field(
        name="secondaryReportUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """Sas url to async benefit utilization summaries report in secondary storage in case of primary
     outage. Will be empty if the report is in Running or Failed state. Known values are: \"Kind\",
     \"AvgUtilizationPercentage\", \"BenefitOrderId\", \"BenefitId\", \"BenefitType\",
     \"MaxUtilizationPercentage\", \"MinUtilizationPercentage\", \"UsageDate\", and
     \"UtilizedPercentage\"."""
    valid_until: Optional[datetime.datetime] = rest_field(
        name="validUntil", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The date that the sas url provided in reportUrl expires."""

    @overload
    def __init__(
        self,
        *,
        report_url: Optional[Union[str, "_models.BenefitUtilizationSummaryReportSchema"]] = None,
        secondary_report_url: Optional[Union[str, "_models.BenefitUtilizationSummaryReportSchema"]] = None,
        valid_until: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitResource(Resource):
    """The benefit resource model definition.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar kind: Reservation or SavingsPlan. Known values are: "IncludedQuantity", "Reservation",
     and "SavingsPlan".
    :vartype kind: str or ~azure.mgmt.costmanagement.models.BenefitKind
    """

    kind: Optional[Union[str, "_models.BenefitKind"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Reservation or SavingsPlan. Known values are: \"IncludedQuantity\", \"Reservation\", and
     \"SavingsPlan\"."""

    @overload
    def __init__(
        self,
        *,
        kind: Optional[Union[str, "_models.BenefitKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitRecommendationModel(BenefitResource):
    """benefit plan recommendation details.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar kind: Reservation or SavingsPlan. Known values are: "IncludedQuantity", "Reservation",
     and "SavingsPlan".
    :vartype kind: str or ~azure.mgmt.costmanagement.models.BenefitKind
    :ivar properties: The properties of the benefit recommendations.
    :vartype properties: ~azure.mgmt.costmanagement.models.BenefitRecommendationProperties
    """

    properties: Optional["_models.BenefitRecommendationProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the benefit recommendations."""

    @overload
    def __init__(
        self,
        *,
        kind: Optional[Union[str, "_models.BenefitKind"]] = None,
        properties: Optional["_models.BenefitRecommendationProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitRecommendationProperties(_Model):
    """The properties of the benefit recommendations.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SharedScopeBenefitRecommendationProperties, SingleScopeBenefitRecommendationProperties

    :ivar first_consumption_date: The first usage date used for looking back for computing the
     recommendations.
    :vartype first_consumption_date: ~datetime.datetime
    :ivar last_consumption_date: The last usage date used for looking back for computing the
     recommendations.
    :vartype last_consumption_date: ~datetime.datetime
    :ivar look_back_period: The number of days of usage evaluated for computing the
     recommendations. Known values are: "Last7Days", "Last30Days", and "Last60Days".
    :vartype look_back_period: str or ~azure.mgmt.costmanagement.models.LookBackPeriod
    :ivar total_hours: The total hours for which the cost is covered. Its equal to number of
     records in a property 'properties/usage/charges'.
    :vartype total_hours: int
    :ivar usage: On-demand charges between firstConsumptionDate and lastConsumptionDate that were
     used for computing benefit recommendations.
    :vartype usage: ~azure.mgmt.costmanagement.models.RecommendationUsageDetails
    :ivar arm_sku_name: ARM SKU name. 'Compute_Savings_Plan' for SavingsPlan.
    :vartype arm_sku_name: str
    :ivar term: Term period of the benefit. For example, P1Y or P3Y. Known values are: "P1Y" and
     "P3Y".
    :vartype term: str or ~azure.mgmt.costmanagement.models.Term
    :ivar commitment_granularity: Grain of the proposed commitment amount. Supported values:
     'Hourly'. Known values are: "Hourly", "Daily", and "Monthly".
    :vartype commitment_granularity: str or ~azure.mgmt.costmanagement.models.Grain
    :ivar currency_code: An ISO 4217 currency code identifier for the costs and savings amounts.
    :vartype currency_code: str
    :ivar cost_without_benefit: The current cost without benefit, corresponds to 'totalHours' in
     the look-back period.
    :vartype cost_without_benefit: ~decimal.Decimal
    :ivar recommendation_details: The details of the proposed recommendation.
    :vartype recommendation_details: ~azure.mgmt.costmanagement.models.AllSavingsBenefitDetails
    :ivar all_recommendation_details: The list of all benefit recommendations with the
     recommendation details.
    :vartype all_recommendation_details: ~azure.mgmt.costmanagement.models.AllSavingsList
    :ivar scope: Benefit scope. For example, Single or Shared. Required. Known values are: "Single"
     and "Shared".
    :vartype scope: str or ~azure.mgmt.costmanagement.models.Scope
    """

    __mapping__: dict[str, _Model] = {}
    first_consumption_date: Optional[datetime.datetime] = rest_field(
        name="firstConsumptionDate", visibility=["read"], format="rfc3339"
    )
    """The first usage date used for looking back for computing the recommendations."""
    last_consumption_date: Optional[datetime.datetime] = rest_field(
        name="lastConsumptionDate", visibility=["read"], format="rfc3339"
    )
    """The last usage date used for looking back for computing the recommendations."""
    look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = rest_field(
        name="lookBackPeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The number of days of usage evaluated for computing the recommendations. Known values are:
     \"Last7Days\", \"Last30Days\", and \"Last60Days\"."""
    total_hours: Optional[int] = rest_field(name="totalHours", visibility=["read"])
    """The total hours for which the cost is covered. Its equal to number of records in a property
     'properties/usage/charges'."""
    usage: Optional["_models.RecommendationUsageDetails"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """On-demand charges between firstConsumptionDate and lastConsumptionDate that were used for
     computing benefit recommendations."""
    arm_sku_name: Optional[str] = rest_field(name="armSkuName", visibility=["read"])
    """ARM SKU name. 'Compute_Savings_Plan' for SavingsPlan."""
    term: Optional[Union[str, "_models.Term"]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Term period of the benefit. For example, P1Y or P3Y. Known values are: \"P1Y\" and \"P3Y\"."""
    commitment_granularity: Optional[Union[str, "_models.Grain"]] = rest_field(
        name="commitmentGranularity", visibility=["read", "create", "update", "delete", "query"]
    )
    """Grain of the proposed commitment amount. Supported values: 'Hourly'. Known values are:
     \"Hourly\", \"Daily\", and \"Monthly\"."""
    currency_code: Optional[str] = rest_field(name="currencyCode", visibility=["read"])
    """An ISO 4217 currency code identifier for the costs and savings amounts."""
    cost_without_benefit: Optional[decimal.Decimal] = rest_field(name="costWithoutBenefit", visibility=["read"])
    """The current cost without benefit, corresponds to 'totalHours' in the look-back period."""
    recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = rest_field(
        name="recommendationDetails", visibility=["read", "create", "update", "delete", "query"]
    )
    """The details of the proposed recommendation."""
    all_recommendation_details: Optional["_models.AllSavingsList"] = rest_field(
        name="allRecommendationDetails", visibility=["read"]
    )
    """The list of all benefit recommendations with the recommendation details."""
    scope: str = rest_discriminator(name="scope", visibility=["read", "create", "update", "delete", "query"])
    """Benefit scope. For example, Single or Shared. Required. Known values are: \"Single\" and
     \"Shared\"."""

    @overload
    def __init__(
        self,
        *,
        scope: str,
        look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = None,
        usage: Optional["_models.RecommendationUsageDetails"] = None,
        term: Optional[Union[str, "_models.Term"]] = None,
        commitment_granularity: Optional[Union[str, "_models.Grain"]] = None,
        recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitUtilizationSummariesOperationStatus(_Model):  # pylint: disable=name-too-long
    """Status of a benefit utilization summaries report. Provides Async Benefit Utilization Summaries
    Request input, status, and report sas url.

    :ivar input: Input given to create the benefit utilization summaries report.
    :vartype input: ~azure.mgmt.costmanagement.models.BenefitUtilizationSummariesRequest
    :ivar status: The status of the creation of the benefit utilization summaries report. Known
     values are: "Running", "Completed", and "Failed".
    :vartype status: str or ~azure.mgmt.costmanagement.models.OperationStatusType
    :ivar properties: Contains sas url to the async benefit utilization summaries report and a date
     that the url is valid until. These values will be empty if the report is in a Running or Failed
     state.
    :vartype properties: ~azure.mgmt.costmanagement.models.AsyncOperationStatusProperties
    """

    input: Optional["_models.BenefitUtilizationSummariesRequest"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Input given to create the benefit utilization summaries report."""
    status: Optional[Union[str, "_models.OperationStatusType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The status of the creation of the benefit utilization summaries report. Known values are:
     \"Running\", \"Completed\", and \"Failed\"."""
    properties: Optional["_models.AsyncOperationStatusProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Contains sas url to the async benefit utilization summaries report and a date that the url is
     valid until. These values will be empty if the report is in a Running or Failed state."""

    @overload
    def __init__(
        self,
        *,
        input: Optional["_models.BenefitUtilizationSummariesRequest"] = None,
        status: Optional[Union[str, "_models.OperationStatusType"]] = None,
        properties: Optional["_models.AsyncOperationStatusProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitUtilizationSummariesRequest(_Model):
    """Properties of an async benefit utilization summaries request.

    :ivar billing_account_id: Billing account the benefit utilization summaries report is for.
     Required for billing account and billing profile scopes. Not supported for any benefit scopes.
    :vartype billing_account_id: str
    :ivar billing_profile_id: Billing profile id the benefit utilization summaries report is for.
     Required for billing profile scope. Not supported for billing account or any benefit scopes.
    :vartype billing_profile_id: str
    :ivar benefit_order_id: Benefit order id the benefit utilization summaries report is for.
     Required for benefit order and benefit id scopes. Not supported for any billing scopes.
    :vartype benefit_order_id: str
    :ivar benefit_id: Benefit id the benefit utilization summaries report is for. Required for
     benefit id scope. Not supported for benefit order or any billing scopes.
    :vartype benefit_id: str
    :ivar grain: The grain the summaries data is served at in the report. Accepted values are
     'Daily' or 'Monthly'. Required. Known values are: "Hourly", "Daily", and "Monthly".
    :vartype grain: str or ~azure.mgmt.costmanagement.models.Grain
    :ivar start_date: The start date of the summaries data that will be served in the report.
     Required.
    :vartype start_date: ~datetime.datetime
    :ivar end_date: The end date of the summaries data that will be served in the report. Required.
    :vartype end_date: ~datetime.datetime
    :ivar kind: The type of benefit data requested. Required for billing account and billing
     profile scopes. Implied and not to be passed at benefit scopes. Supported values are
     Reservation and SavingsPlan. Known values are: "IncludedQuantity", "Reservation", and
     "SavingsPlan".
    :vartype kind: str or ~azure.mgmt.costmanagement.models.BenefitKind
    """

    billing_account_id: Optional[str] = rest_field(
        name="billingAccountId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Billing account the benefit utilization summaries report is for. Required for billing account
     and billing profile scopes. Not supported for any benefit scopes."""
    billing_profile_id: Optional[str] = rest_field(
        name="billingProfileId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Billing profile id the benefit utilization summaries report is for. Required for billing
     profile scope. Not supported for billing account or any benefit scopes."""
    benefit_order_id: Optional[str] = rest_field(
        name="benefitOrderId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Benefit order id the benefit utilization summaries report is for. Required for benefit order
     and benefit id scopes. Not supported for any billing scopes."""
    benefit_id: Optional[str] = rest_field(name="benefitId", visibility=["read", "create", "update", "delete", "query"])
    """Benefit id the benefit utilization summaries report is for. Required for benefit id scope. Not
     supported for benefit order or any billing scopes."""
    grain: Union[str, "_models.Grain"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The grain the summaries data is served at in the report. Accepted values are 'Daily' or
     'Monthly'. Required. Known values are: \"Hourly\", \"Daily\", and \"Monthly\"."""
    start_date: datetime.datetime = rest_field(
        name="startDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date of the summaries data that will be served in the report. Required."""
    end_date: datetime.datetime = rest_field(
        name="endDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end date of the summaries data that will be served in the report. Required."""
    kind: Optional[Union[str, "_models.BenefitKind"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of benefit data requested. Required for billing account and billing profile scopes.
     Implied and not to be passed at benefit scopes. Supported values are Reservation and
     SavingsPlan. Known values are: \"IncludedQuantity\", \"Reservation\", and \"SavingsPlan\"."""

    @overload
    def __init__(
        self,
        *,
        grain: Union[str, "_models.Grain"],
        start_date: datetime.datetime,
        end_date: datetime.datetime,
        billing_account_id: Optional[str] = None,
        billing_profile_id: Optional[str] = None,
        benefit_order_id: Optional[str] = None,
        benefit_id: Optional[str] = None,
        kind: Optional[Union[str, "_models.BenefitKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitUtilizationSummary(Resource):
    """Benefit utilization summary resource.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    IncludedQuantityUtilizationSummary, SavingsPlanUtilizationSummary

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar kind: Supported values: 'SavingsPlan'. Required. Known values are: "IncludedQuantity",
     "Reservation", and "SavingsPlan".
    :vartype kind: str or ~azure.mgmt.costmanagement.models.BenefitKind
    """

    __mapping__: dict[str, _Model] = {}
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Supported values: 'SavingsPlan'. Required. Known values are: \"IncludedQuantity\",
     \"Reservation\", and \"SavingsPlan\"."""

    @overload
    def __init__(
        self,
        *,
        kind: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BenefitUtilizationSummaryProperties(_Model):
    """The properties of a benefit utilization summary.

    :ivar arm_sku_name: ARM SKU name. For example, 'Compute_Savings_Plan' for savings plan.
    :vartype arm_sku_name: str
    :ivar benefit_id: The benefit ID is the identifier of the benefit.
    :vartype benefit_id: str
    :ivar benefit_order_id: The benefit order ID is the identifier for a benefit purchase.
    :vartype benefit_order_id: str
    :ivar benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
     "IncludedQuantity", "Reservation", and "SavingsPlan".
    :vartype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
    :ivar usage_date: Date corresponding to the utilization summary record. If the grain of data is
     monthly, value for this field will be first day of the month.
    :vartype usage_date: ~datetime.datetime
    """

    arm_sku_name: Optional[str] = rest_field(name="armSkuName", visibility=["read"])
    """ARM SKU name. For example, 'Compute_Savings_Plan' for savings plan."""
    benefit_id: Optional[str] = rest_field(name="benefitId", visibility=["read"])
    """The benefit ID is the identifier of the benefit."""
    benefit_order_id: Optional[str] = rest_field(name="benefitOrderId", visibility=["read"])
    """The benefit order ID is the identifier for a benefit purchase."""
    benefit_type: Optional[Union[str, "_models.BenefitKind"]] = rest_field(
        name="benefitType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The benefit type. Supported values: 'SavingsPlan'. Known values are: \"IncludedQuantity\",
     \"Reservation\", and \"SavingsPlan\"."""
    usage_date: Optional[datetime.datetime] = rest_field(name="usageDate", visibility=["read"], format="rfc3339")
    """Date corresponding to the utilization summary record. If the grain of data is monthly, value
     for this field will be first day of the month."""

    @overload
    def __init__(
        self,
        *,
        benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BlobInfo(_Model):
    """The blob information generated by this operation.

    :ivar blob_link: Link to the blob to download file.
    :vartype blob_link: str
    :ivar byte_count: Bytes in the blob.
    :vartype byte_count: int
    """

    blob_link: Optional[str] = rest_field(name="blobLink", visibility=["read", "create", "update", "delete", "query"])
    """Link to the blob to download file."""
    byte_count: Optional[int] = rest_field(name="byteCount", visibility=["read", "create", "update", "delete", "query"])
    """Bytes in the blob."""

    @overload
    def __init__(
        self,
        *,
        blob_link: Optional[str] = None,
        byte_count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Budget(ExtensionResource):
    """A budget resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the budget.
    :vartype properties: ~azure.mgmt.costmanagement.models.BudgetProperties
    :ivar e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
     used to determine whether the user is updating the latest version or not.
    :vartype e_tag: str
    """

    properties: Optional["_models.BudgetProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the budget."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read", "create", "update", "delete", "query"])
    """eTag of the resource. To handle concurrent update scenario, this field will be used to
     determine whether the user is updating the latest version or not."""

    __flattened_items = [
        "category",
        "amount",
        "time_grain",
        "time_period",
        "filter",
        "current_spend",
        "notifications",
        "forecast_spend",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.BudgetProperties"] = None,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class BudgetComparisonExpression(_Model):
    """The comparison expression to be used in the budgets.

    :ivar name: The name of the column to use in comparison. Required.
    :vartype name: str
    :ivar operator: The operator to use for comparison. Required. "In"
    :vartype operator: str or ~azure.mgmt.costmanagement.models.BudgetOperatorType
    :ivar values_property: Array of values to use for comparison. Required.
    :vartype values_property: list[str]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to use in comparison. Required."""
    operator: Union[str, "_models.BudgetOperatorType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The operator to use for comparison. Required. \"In\""""
    values_property: list[str] = rest_field(name="values", visibility=["read", "create", "update", "delete", "query"])
    """Array of values to use for comparison. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        operator: Union[str, "_models.BudgetOperatorType"],
        values_property: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BudgetFilter(_Model):
    """May be used to filter budgets by user-specified dimensions and/or tags.

        Supported for CategoryType(s): Cost, ReservationUtilization.

        :ivar and_property: The logical "AND" expression. Must have at least 2 items.

         Supported for CategoryType(s): Cost.
        :vartype and_property: list[~azure.mgmt.costmanagement.models.BudgetFilterProperties]
        :ivar dimensions: Has comparison expression for a dimension.

    Supported for CategoryType(s): Cost, ReservationUtilization.

    Supported dimension names for **CategoryType: ReservationUtilization**

         * ReservationId
         * ReservedResourceType.
        :vartype dimensions: ~azure.mgmt.costmanagement.models.BudgetComparisonExpression
        :ivar tags: Has comparison expression for a tag.

         Supported for CategoryType(s): Cost.
        :vartype tags: ~azure.mgmt.costmanagement.models.BudgetComparisonExpression
    """

    and_property: Optional[list["_models.BudgetFilterProperties"]] = rest_field(
        name="and", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"AND\" expression. Must have at least 2 items.
     
     Supported for CategoryType(s): Cost."""
    dimensions: Optional["_models.BudgetComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a dimension.
 
 Supported for CategoryType(s): Cost, ReservationUtilization.
 
 Supported dimension names for **CategoryType: ReservationUtilization**
 
      * ReservationId
      * ReservedResourceType."""
    tags: Optional["_models.BudgetComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a tag.
     
     Supported for CategoryType(s): Cost."""

    @overload
    def __init__(
        self,
        *,
        and_property: Optional[list["_models.BudgetFilterProperties"]] = None,
        dimensions: Optional["_models.BudgetComparisonExpression"] = None,
        tags: Optional["_models.BudgetComparisonExpression"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BudgetFilterProperties(_Model):
    """The Dimensions or Tags to filter a budget by.

        Supported for CategoryType(s): Cost, ReservationUtilization.

        :ivar dimensions: Has comparison expression for a dimension.

    Supported for CategoryType(s): Cost, ReservationUtilization.

    Supported dimension names for **CategoryType: ReservationUtilization**

         * ReservationId
         * ReservedResourceType.
        :vartype dimensions: ~azure.mgmt.costmanagement.models.BudgetComparisonExpression
        :ivar tags: Has comparison expression for a tag.

         Supported for CategoryType(s): Cost.
        :vartype tags: ~azure.mgmt.costmanagement.models.BudgetComparisonExpression
    """

    dimensions: Optional["_models.BudgetComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a dimension.
 
 Supported for CategoryType(s): Cost, ReservationUtilization.
 
 Supported dimension names for **CategoryType: ReservationUtilization**
 
      * ReservationId
      * ReservedResourceType."""
    tags: Optional["_models.BudgetComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a tag.
     
     Supported for CategoryType(s): Cost."""

    @overload
    def __init__(
        self,
        *,
        dimensions: Optional["_models.BudgetComparisonExpression"] = None,
        tags: Optional["_models.BudgetComparisonExpression"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BudgetProperties(_Model):
    """The properties of the budget.

        :ivar category: The category of the budget.

         * 'Cost' defines a Budget.
         * 'ReservationUtilization' defines a Reservation Utilization Alert Rule. Required. Known
           values are: "Cost" and "ReservationUtilization".
        :vartype category: str or ~azure.mgmt.costmanagement.models.CategoryType
        :ivar amount: The total amount of cost to track with the budget.

         Supported for CategoryType(s): Cost.

         Required for CategoryType(s): Cost.
        :vartype amount: float
        :ivar time_grain: The time covered by a budget. Tracking of the amount will be reset based on
        the time grain.

    Supported for CategoryType(s): Cost, ReservationUtilization.

    Supported timeGrainTypes for **CategoryType: Cost**



         * Monthly
         * Quarterly
         * Annually
         * BillingMonth*
         * BillingQuarter*
         * BillingAnnual*

    *only supported for Web Direct customers.

    Supported timeGrainTypes for **CategoryType: ReservationUtilization**

         * Last7Days
         * Last30Days

    Required for CategoryType(s): Cost, ReservationUtilization. Required. Known values are:
        "Monthly", "Quarterly", "Annually", "BillingMonth", "BillingQuarter", "BillingAnnual",
        "Last7Days", and "Last30Days".
        :vartype time_grain: str or ~azure.mgmt.costmanagement.models.TimeGrainType
        :ivar time_period: The time period that defines the active period of the budget. The budget
         will evaluate data on or after the startDate and will expire on the endDate.

         Supported for CategoryType(s): Cost, ReservationUtilization.

         Required for CategoryType(s): Cost, ReservationUtilization. Required.
        :vartype time_period: ~azure.mgmt.costmanagement.models.BudgetTimePeriod
        :ivar filter: May be used to filter budgets by user-specified dimensions and/or tags.

         Supported for CategoryType(s): Cost, ReservationUtilization.
        :vartype filter: ~azure.mgmt.costmanagement.models.BudgetFilter
        :ivar current_spend: The current amount of cost which is being tracked for a budget.

         Supported for CategoryType(s): Cost.
        :vartype current_spend: ~azure.mgmt.costmanagement.models.CurrentSpend
        :ivar notifications: Dictionary of notifications associated with the budget.

    Supported for CategoryType(s): Cost, ReservationUtilization.



         * Constraints for **CategoryType: Cost** - Budget can have up to 5 notifications with
           thresholdType: Actual and 5 notifications with thresholdType: Forecasted.
         * Constraints for **CategoryType: ReservationUtilization** - Only one notification
           allowed. thresholdType is not applicable.
        :vartype notifications: dict[str, ~azure.mgmt.costmanagement.models.Notification]
        :ivar forecast_spend: The forecasted cost which is being tracked for a budget.

         Supported for CategoryType(s): Cost.
        :vartype forecast_spend: ~azure.mgmt.costmanagement.models.ForecastSpend
    """

    category: Union[str, "_models.CategoryType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The category of the budget.
 
      * 'Cost' defines a Budget.
      * 'ReservationUtilization' defines a Reservation Utilization Alert Rule. Required. Known
        values are: \"Cost\" and \"ReservationUtilization\"."""
    amount: Optional[float] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The total amount of cost to track with the budget.
     
     Supported for CategoryType(s): Cost.
     
     Required for CategoryType(s): Cost."""
    time_grain: Union[str, "_models.TimeGrainType"] = rest_field(
        name="timeGrain", visibility=["read", "create", "update", "delete", "query"]
    )
    """The time covered by a budget. Tracking of the amount will be reset based on the time grain.
 
 Supported for CategoryType(s): Cost, ReservationUtilization.
 
 Supported timeGrainTypes for **CategoryType: Cost**
 
 
 
      * Monthly
      * Quarterly
      * Annually
      * BillingMonth*
      * BillingQuarter*
      * BillingAnnual*
 
 *only supported for Web Direct customers.
 
 Supported timeGrainTypes for **CategoryType: ReservationUtilization**
 
      * Last7Days
      * Last30Days
 
 Required for CategoryType(s): Cost, ReservationUtilization. Required. Known values are:
     \"Monthly\", \"Quarterly\", \"Annually\", \"BillingMonth\", \"BillingQuarter\",
     \"BillingAnnual\", \"Last7Days\", and \"Last30Days\"."""
    time_period: "_models.BudgetTimePeriod" = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The time period that defines the active period of the budget. The budget will evaluate data on
     or after the startDate and will expire on the endDate.
     
     Supported for CategoryType(s): Cost, ReservationUtilization.
     
     Required for CategoryType(s): Cost, ReservationUtilization. Required."""
    filter: Optional["_models.BudgetFilter"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """May be used to filter budgets by user-specified dimensions and/or tags.
     
     Supported for CategoryType(s): Cost, ReservationUtilization."""
    current_spend: Optional["_models.CurrentSpend"] = rest_field(name="currentSpend", visibility=["read"])
    """The current amount of cost which is being tracked for a budget.
     
     Supported for CategoryType(s): Cost."""
    notifications: Optional[dict[str, "_models.Notification"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Dictionary of notifications associated with the budget.
 
 Supported for CategoryType(s): Cost, ReservationUtilization.
 
 
 
      * Constraints for **CategoryType: Cost** - Budget can have up to 5 notifications with
        thresholdType: Actual and 5 notifications with thresholdType: Forecasted.
      * Constraints for **CategoryType: ReservationUtilization** - Only one notification
        allowed. thresholdType is not applicable."""
    forecast_spend: Optional["_models.ForecastSpend"] = rest_field(name="forecastSpend", visibility=["read"])
    """The forecasted cost which is being tracked for a budget.
     
     Supported for CategoryType(s): Cost."""

    @overload
    def __init__(
        self,
        *,
        category: Union[str, "_models.CategoryType"],
        time_grain: Union[str, "_models.TimeGrainType"],
        time_period: "_models.BudgetTimePeriod",
        amount: Optional[float] = None,
        filter: Optional["_models.BudgetFilter"] = None,  # pylint: disable=redefined-builtin
        notifications: Optional[dict[str, "_models.Notification"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BudgetTimePeriod(_Model):
    """The time period that defines the active period of the budget. The budget will evaluate data on
    or after the startDate and will expire on the endDate.

    Supported for CategoryType(s): Cost, ReservationUtilization.

    Required for CategoryType(s): Cost, ReservationUtilization.

    :ivar start_date: The start date for the budget.



     * Constraints for **CategoryType: Cost** - Must be first of the month and should be less
       than the end date. Budget start date must be on or after June 1, 2017. Future start date should
       not be more than twelve months. Past start date should  be selected within the timegrain
       period.

     * Constraints for **CategoryType: ReservationUtilization** - Must be on or after the
       current date and less than the end date. Required.
    :vartype start_date: ~datetime.datetime
    :ivar end_date: The end date for the budget.



     * Constraints for **CategoryType: Cost** - No constraints. If not provided, we default
       this to 10 years from the start date.

     * Constraints for **CategoryType: ReservationUtilization** - End date cannot be more than
       3 years after the start date.
    :vartype end_date: ~datetime.datetime
    """

    start_date: datetime.datetime = rest_field(
        name="startDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date for the budget.
 
 
 
      * Constraints for **CategoryType: Cost** - Must be first of the month and should be less
        than the end date. Budget start date must be on or after June 1, 2017. Future start date should
        not be more than twelve months. Past start date should  be selected within the timegrain
        period.
 
      * Constraints for **CategoryType: ReservationUtilization** - Must be on or after the
        current date and less than the end date. Required."""
    end_date: Optional[datetime.datetime] = rest_field(
        name="endDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end date for the budget.
 
 
 
      * Constraints for **CategoryType: Cost** - No constraints. If not provided, we default
        this to 10 years from the start date.
 
      * Constraints for **CategoryType: ReservationUtilization** - End date cannot be more than
        3 years after the start date."""

    @overload
    def __init__(
        self,
        *,
        start_date: datetime.datetime,
        end_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CheckNameAvailabilityRequest(_Model):
    """The check availability request body.

    :ivar name: The name of the resource for which availability needs to be checked.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the resource for which availability needs to be checked."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The resource type."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CheckNameAvailabilityResponse(_Model):
    """The check availability result.

    :ivar name_available: Indicates if the resource name is available.
    :vartype name_available: bool
    :ivar reason: The reason why the given name is not available. Known values are: "Invalid" and
     "AlreadyExists".
    :vartype reason: str or ~azure.mgmt.costmanagement.models.CheckNameAvailabilityReason
    :ivar message: Detailed reason why the given name is not available.
    :vartype message: str
    """

    name_available: Optional[bool] = rest_field(
        name="nameAvailable", visibility=["read", "create", "update", "delete", "query"]
    )
    """Indicates if the resource name is available."""
    reason: Optional[Union[str, "_models.CheckNameAvailabilityReason"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The reason why the given name is not available. Known values are: \"Invalid\" and
     \"AlreadyExists\"."""
    message: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Detailed reason why the given name is not available."""

    @overload
    def __init__(
        self,
        *,
        name_available: Optional[bool] = None,
        reason: Optional[Union[str, "_models.CheckNameAvailabilityReason"]] = None,
        message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommonExportProperties(_Model):
    """The common properties of the export.

    :ivar format: The format of the export being delivered. Known values are: "Csv" and "Parquet".
    :vartype format: str or ~azure.mgmt.costmanagement.models.FormatType
    :ivar delivery_info: Has delivery information for the export. Required.
    :vartype delivery_info: ~azure.mgmt.costmanagement.models.ExportDeliveryInfo
    :ivar definition: Has the definition for the export. Required.
    :vartype definition: ~azure.mgmt.costmanagement.models.ExportDefinition
    :ivar run_history: If requested, has the most recent run history for the export.
    :vartype run_history: ~azure.mgmt.costmanagement.models.ExportExecutionListResult
    :ivar partition_data: If set to true, exported data will be partitioned by size and placed in a
     blob directory together with a manifest file.
    :vartype partition_data: bool
    :ivar data_overwrite_behavior: Allow customers to select overwrite
     data(OverwritePreviousReport) for exports. This setting will enable overwrite data for the same
     month in customer storage account. By default set to CreateNewReport. Known values are:
     "OverwritePreviousReport" and "CreateNewReport".
    :vartype data_overwrite_behavior: str or
     ~azure.mgmt.costmanagement.models.DataOverwriteBehaviorType
    :ivar compression_mode: Allow customers to select compress data for exports. This setting will
     enable destination file compression scheme at runtime. By default set to None. Gzip is for csv
     and snappy for parquet. Known values are: "gzip", "snappy", and "none".
    :vartype compression_mode: str or ~azure.mgmt.costmanagement.models.CompressionModeType
    :ivar export_description: The export description set by customer at time of export
     creation/update.
    :vartype export_description: str
    :ivar next_run_time_estimate: If the export has an active schedule, provides an estimate of the
     next run time.
    :vartype next_run_time_estimate: ~datetime.datetime
    :ivar system_suspension_context: The export suspension reason if export is in SystemSuspended
     state. This is not populated currently.
    :vartype system_suspension_context: ~azure.mgmt.costmanagement.models.ExportSuspensionContext
    """

    format: Optional[Union[str, "_models.FormatType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The format of the export being delivered. Known values are: \"Csv\" and \"Parquet\"."""
    delivery_info: "_models.ExportDeliveryInfo" = rest_field(
        name="deliveryInfo", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has delivery information for the export. Required."""
    definition: "_models.ExportDefinition" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Has the definition for the export. Required."""
    run_history: Optional["_models.ExportExecutionListResult"] = rest_field(
        name="runHistory", visibility=["read", "create", "update", "delete", "query"]
    )
    """If requested, has the most recent run history for the export."""
    partition_data: Optional[bool] = rest_field(
        name="partitionData", visibility=["read", "create", "update", "delete", "query"]
    )
    """If set to true, exported data will be partitioned by size and placed in a blob directory
     together with a manifest file."""
    data_overwrite_behavior: Optional[Union[str, "_models.DataOverwriteBehaviorType"]] = rest_field(
        name="dataOverwriteBehavior", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allow customers to select overwrite data(OverwritePreviousReport) for exports. This setting
     will enable overwrite data for the same month in customer storage account. By default set to
     CreateNewReport. Known values are: \"OverwritePreviousReport\" and \"CreateNewReport\"."""
    compression_mode: Optional[Union[str, "_models.CompressionModeType"]] = rest_field(
        name="compressionMode", visibility=["read", "create", "update", "delete", "query"]
    )
    """Allow customers to select compress data for exports. This setting will enable destination file
     compression scheme at runtime. By default set to None. Gzip is for csv and snappy for parquet.
     Known values are: \"gzip\", \"snappy\", and \"none\"."""
    export_description: Optional[str] = rest_field(
        name="exportDescription", visibility=["read", "create", "update", "delete", "query"]
    )
    """The export description set by customer at time of export creation/update."""
    next_run_time_estimate: Optional[datetime.datetime] = rest_field(
        name="nextRunTimeEstimate", visibility=["read"], format="rfc3339"
    )
    """If the export has an active schedule, provides an estimate of the next run time."""
    system_suspension_context: Optional["_models.ExportSuspensionContext"] = rest_field(
        name="systemSuspensionContext", visibility=["read"]
    )
    """The export suspension reason if export is in SystemSuspended state. This is not populated
     currently."""

    @overload
    def __init__(
        self,
        *,
        delivery_info: "_models.ExportDeliveryInfo",
        definition: "_models.ExportDefinition",
        format: Optional[Union[str, "_models.FormatType"]] = None,
        run_history: Optional["_models.ExportExecutionListResult"] = None,
        partition_data: Optional[bool] = None,
        data_overwrite_behavior: Optional[Union[str, "_models.DataOverwriteBehaviorType"]] = None,
        compression_mode: Optional[Union[str, "_models.CompressionModeType"]] = None,
        export_description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostAllocationProportion(_Model):
    """Target resources and allocation.

    :ivar name: Target resource for cost allocation. Required.
    :vartype name: str
    :ivar percentage: Percentage of source cost to allocate to this resource. This value can be
     specified to two decimal places and the total percentage of all resources in this rule must sum
     to 100.00. Required.
    :vartype percentage: float
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Target resource for cost allocation. Required."""
    percentage: float = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Percentage of source cost to allocate to this resource. This value can be specified to two
     decimal places and the total percentage of all resources in this rule must sum to 100.00.
     Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        percentage: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostAllocationResource(_Model):
    """Common values for resources for cost allocation.

    :ivar resource_type: Type of resources contained in this cost allocation rule. Required. Known
     values are: "Dimension" and "Tag".
    :vartype resource_type: str or ~azure.mgmt.costmanagement.models.CostAllocationResourceType
    :ivar name: If resource type is dimension, this must be either ResourceGroupName or
     SubscriptionId. If resource type is tag, this must be a valid Azure tag. Required.
    :vartype name: str
    """

    resource_type: Union[str, "_models.CostAllocationResourceType"] = rest_field(
        name="resourceType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Type of resources contained in this cost allocation rule. Required. Known values are:
     \"Dimension\" and \"Tag\"."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """If resource type is dimension, this must be either ResourceGroupName or SubscriptionId. If
     resource type is tag, this must be a valid Azure tag. Required."""

    @overload
    def __init__(
        self,
        *,
        resource_type: Union[str, "_models.CostAllocationResourceType"],
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostAllocationRuleCheckNameAvailabilityRequest(_Model):  # pylint: disable=name-too-long
    """The cost allocation rule check name availability request.

    :ivar name: Rule name.
    :vartype name: str
    :ivar type: Resource type. This is expected to be Microsoft.CostManagement/costAllocationRules.
    :vartype type: str
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Rule name."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Resource type. This is expected to be Microsoft.CostManagement/costAllocationRules."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostAllocationRuleCheckNameAvailabilityResponse(_Model):  # pylint: disable=name-too-long
    """The cost allocation rule check name availability response.

    :ivar name_available: Whether this rule name is available.
    :vartype name_available: bool
    :ivar reason: The reason this name is not available. Known values are: "Invalid",
     "AlreadyExists", and "Valid".
    :vartype reason: str or ~azure.mgmt.costmanagement.models.Reason
    :ivar message: Error message if the name is not available.
    :vartype message: str
    """

    name_available: Optional[bool] = rest_field(
        name="nameAvailable", visibility=["read", "create", "update", "delete", "query"]
    )
    """Whether this rule name is available."""
    reason: Optional[Union[str, "_models.Reason"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The reason this name is not available. Known values are: \"Invalid\", \"AlreadyExists\", and
     \"Valid\"."""
    message: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Error message if the name is not available."""

    @overload
    def __init__(
        self,
        *,
        name_available: Optional[bool] = None,
        reason: Optional[Union[str, "_models.Reason"]] = None,
        message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProxyResource(Resource):
    """Proxy Resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    """


class CostAllocationRuleDefinition(ProxyResource):
    """The cost allocation rule model definition.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: Cost allocation rule properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.CostAllocationRuleProperties
    """

    properties: Optional["_models.CostAllocationRuleProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Cost allocation rule properties."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.CostAllocationRuleProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostAllocationRuleDetails(_Model):
    """Resource details of the cost allocation rule.

    :ivar source_resources: Source resources for cost allocation. At this time, this list can
     contain no more than one element.
    :vartype source_resources: list[~azure.mgmt.costmanagement.models.SourceCostAllocationResource]
    :ivar target_resources: Target resources for cost allocation. At this time, this list can
     contain no more than one element.
    :vartype target_resources: list[~azure.mgmt.costmanagement.models.TargetCostAllocationResource]
    """

    source_resources: Optional[list["_models.SourceCostAllocationResource"]] = rest_field(
        name="sourceResources", visibility=["read", "create", "update", "delete", "query"]
    )
    """Source resources for cost allocation. At this time, this list can contain no more than one
     element."""
    target_resources: Optional[list["_models.TargetCostAllocationResource"]] = rest_field(
        name="targetResources", visibility=["read", "create", "update", "delete", "query"]
    )
    """Target resources for cost allocation. At this time, this list can contain no more than one
     element."""

    @overload
    def __init__(
        self,
        *,
        source_resources: Optional[list["_models.SourceCostAllocationResource"]] = None,
        target_resources: Optional[list["_models.TargetCostAllocationResource"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostAllocationRuleProperties(_Model):
    """The properties of a cost allocation rule.

    :ivar description: Description of a cost allocation rule.
    :vartype description: str
    :ivar details: Resource information for the cost allocation rule. Required.
    :vartype details: ~azure.mgmt.costmanagement.models.CostAllocationRuleDetails
    :ivar status: Status of the rule. Required. Known values are: "NotActive", "Active", and
     "Processing".
    :vartype status: str or ~azure.mgmt.costmanagement.models.RuleStatus
    :ivar created_date: Time at which the rule was created. Rules that change cost for the same
     resource are applied in order of creation.
    :vartype created_date: ~datetime.datetime
    :ivar updated_date: Time at which the rule was last updated.
    :vartype updated_date: ~datetime.datetime
    """

    description: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Description of a cost allocation rule."""
    details: "_models.CostAllocationRuleDetails" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Resource information for the cost allocation rule. Required."""
    status: Union[str, "_models.RuleStatus"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Status of the rule. Required. Known values are: \"NotActive\", \"Active\", and \"Processing\"."""
    created_date: Optional[datetime.datetime] = rest_field(name="createdDate", visibility=["read"], format="rfc3339")
    """Time at which the rule was created. Rules that change cost for the same resource are applied in
     order of creation."""
    updated_date: Optional[datetime.datetime] = rest_field(name="updatedDate", visibility=["read"], format="rfc3339")
    """Time at which the rule was last updated."""

    @overload
    def __init__(
        self,
        *,
        details: "_models.CostAllocationRuleDetails",
        status: Union[str, "_models.RuleStatus"],
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostDetailsOperationResults(ExtensionResource):
    """The result of the long running operation for cost details Api.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar status: The status of the cost details operation. Known values are: "Completed",
     "NoDataFound", and "Failed".
    :vartype status: str or ~azure.mgmt.costmanagement.models.CostDetailsStatusType
    :ivar manifest: The manifest of the report generated by the operation.
    :vartype manifest: ~azure.mgmt.costmanagement.models.ReportManifest
    :ivar valid_till: The time at which report URL becomes invalid/expires in UTC e.g.
     2020-12-08T05:55:59.4394737Z.
    :vartype valid_till: ~datetime.datetime
    :ivar error: The details of the error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    status: Optional[Union[str, "_models.CostDetailsStatusType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The status of the cost details operation. Known values are: \"Completed\", \"NoDataFound\", and
     \"Failed\"."""
    manifest: Optional["_models.ReportManifest"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The manifest of the report generated by the operation."""
    valid_till: Optional[datetime.datetime] = rest_field(
        name="validTill", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time at which report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z."""
    error: Optional["_models.ErrorDetails"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The details of the error."""

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.CostDetailsStatusType"]] = None,
        manifest: Optional["_models.ReportManifest"] = None,
        valid_till: Optional[datetime.datetime] = None,
        error: Optional["_models.ErrorDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostDetailsTimePeriod(_Model):
    """The start and end date for pulling data for the cost detailed report. API only allows data to
    be pulled for 1 month or less and no older than 13 months.

    :ivar start: The start date to pull data from. example format 2020-03-15. Required.
    :vartype start: str
    :ivar end: The end date to pull data to. example format 2020-03-15. Required.
    :vartype end: str
    """

    start: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The start date to pull data from. example format 2020-03-15. Required."""
    end: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The end date to pull data to. example format 2020-03-15. Required."""

    @overload
    def __init__(
        self,
        *,
        start: str,
        end: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Operation(_Model):
    """REST API Operation.

    :ivar name: The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action".
    :vartype name: str
    :ivar is_data_action: Whether the operation applies to data-plane. This is "true" for
     data-plane operations and "false" for Azure Resource Manager/control-plane operations.
    :vartype is_data_action: bool
    :ivar display: Localized display information for this particular operation.
    :vartype display: ~azure.mgmt.costmanagement.models.OperationDisplay
    :ivar origin: The intended executor of the operation; as in Resource Based Access Control
     (RBAC) and audit logs UX. Default value is "user,system". Known values are: "user", "system",
     and "user,system".
    :vartype origin: str or ~azure.mgmt.costmanagement.models.Origin
    :ivar action_type: Extensible enum. Indicates the action type. "Internal" refers to actions
     that are for internal only APIs. "Internal"
    :vartype action_type: str or ~azure.mgmt.costmanagement.models.ActionType
    """

    name: Optional[str] = rest_field(visibility=["read"])
    """The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     \"Microsoft.Compute/virtualMachines/write\",
     \"Microsoft.Compute/virtualMachines/capture/action\"."""
    is_data_action: Optional[bool] = rest_field(name="isDataAction", visibility=["read"])
    """Whether the operation applies to data-plane. This is \"true\" for data-plane operations and
     \"false\" for Azure Resource Manager/control-plane operations."""
    display: Optional["_models.OperationDisplay"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Localized display information for this particular operation."""
    origin: Optional[Union[str, "_models.Origin"]] = rest_field(visibility=["read"])
    """The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit
     logs UX. Default value is \"user,system\". Known values are: \"user\", \"system\", and
     \"user,system\"."""
    action_type: Optional[Union[str, "_models.ActionType"]] = rest_field(name="actionType", visibility=["read"])
    """Extensible enum. Indicates the action type. \"Internal\" refers to actions that are for
     internal only APIs. \"Internal\""""

    @overload
    def __init__(
        self,
        *,
        display: Optional["_models.OperationDisplay"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostManagementOperation(Operation):
    """A Cost management REST API operation.

    :ivar name: The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
     "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action".
    :vartype name: str
    :ivar is_data_action: Whether the operation applies to data-plane. This is "true" for
     data-plane operations and "false" for Azure Resource Manager/control-plane operations.
    :vartype is_data_action: bool
    :ivar display: Localized display information for this particular operation.
    :vartype display: ~azure.mgmt.costmanagement.models.OperationDisplay
    :ivar origin: The intended executor of the operation; as in Resource Based Access Control
     (RBAC) and audit logs UX. Default value is "user,system". Known values are: "user", "system",
     and "user,system".
    :vartype origin: str or ~azure.mgmt.costmanagement.models.Origin
    :ivar action_type: Extensible enum. Indicates the action type. "Internal" refers to actions
     that are for internal only APIs. "Internal"
    :vartype action_type: str or ~azure.mgmt.costmanagement.models.ActionType
    :ivar id: Operation id: {provider}/{resource}/{operation}.
    :vartype id: str
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Operation id: {provider}/{resource}/{operation}."""

    @overload
    def __init__(
        self,
        *,
        display: Optional["_models.OperationDisplay"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostManagementProxyResource(_Model):
    """The Resource model definition.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
     used to determine whether the user is updating the latest version or not.
    :vartype e_tag: str
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Resource Id."""
    name: Optional[str] = rest_field(visibility=["read"])
    """Resource name."""
    type: Optional[str] = rest_field(visibility=["read"])
    """Resource type."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read", "create", "update", "delete", "query"])
    """eTag of the resource. To handle concurrent update scenario, this field will be used to
     determine whether the user is updating the latest version or not."""

    @overload
    def __init__(
        self,
        *,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CostManagementResource(_Model):
    """The Resource model definition.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar location: Location of the resource.
    :vartype location: str
    :ivar sku: SKU of the resource.
    :vartype sku: str
    :ivar e_tag: ETag of the resource.
    :vartype e_tag: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    id: Optional[str] = rest_field(visibility=["read"])
    """Resource Id."""
    name: Optional[str] = rest_field(visibility=["read"])
    """Resource name."""
    type: Optional[str] = rest_field(visibility=["read"])
    """Resource type."""
    location: Optional[str] = rest_field(visibility=["read"])
    """Location of the resource."""
    sku: Optional[str] = rest_field(visibility=["read"])
    """SKU of the resource."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read"])
    """ETag of the resource."""
    tags: Optional[dict[str, str]] = rest_field(visibility=["read"])
    """Resource tags."""


class CurrentSpend(_Model):
    """The current amount of cost which is being tracked for a budget.

    Supported for CategoryType(s): Cost.

    :ivar amount: The total amount of cost which is being tracked by the budget.
    :vartype amount: float
    :ivar unit: The unit of measure for the budget amount.
    :vartype unit: str
    """

    amount: Optional[float] = rest_field(visibility=["read"])
    """The total amount of cost which is being tracked by the budget."""
    unit: Optional[str] = rest_field(visibility=["read"])
    """The unit of measure for the budget amount."""


class Dimension(CostManagementResource):
    """List of Dimension.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar location: Location of the resource.
    :vartype location: str
    :ivar sku: SKU of the resource.
    :vartype sku: str
    :ivar e_tag: ETag of the resource.
    :vartype e_tag: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar properties: Dimension properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.DimensionProperties
    """

    properties: Optional["_models.DimensionProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Dimension properties."""

    __flattened_items = [
        "description",
        "filter_enabled",
        "grouping_enabled",
        "data",
        "total",
        "category",
        "usage_start",
        "usage_end",
        "next_link",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.DimensionProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class DimensionProperties(_Model):
    """Dimension properties.

    :ivar description: Dimension description.
    :vartype description: str
    :ivar filter_enabled: Filter enabled.
    :vartype filter_enabled: bool
    :ivar grouping_enabled: Grouping enabled.
    :vartype grouping_enabled: bool
    :ivar data: Dimension data.
    :vartype data: list[str]
    :ivar total: Total number of data for the dimension.
    :vartype total: int
    :ivar category: Dimension category.
    :vartype category: str
    :ivar usage_start: Usage start.
    :vartype usage_start: ~datetime.datetime
    :ivar usage_end: Usage end.
    :vartype usage_end: ~datetime.datetime
    :ivar next_link: The link (url) to the next page of results.
    :vartype next_link: str
    """

    description: Optional[str] = rest_field(visibility=["read"])
    """Dimension description."""
    filter_enabled: Optional[bool] = rest_field(name="filterEnabled", visibility=["read"])
    """Filter enabled."""
    grouping_enabled: Optional[bool] = rest_field(name="groupingEnabled", visibility=["read"])
    """Grouping enabled."""
    data: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Dimension data."""
    total: Optional[int] = rest_field(visibility=["read"])
    """Total number of data for the dimension."""
    category: Optional[str] = rest_field(visibility=["read"])
    """Dimension category."""
    usage_start: Optional[datetime.datetime] = rest_field(name="usageStart", visibility=["read"], format="rfc3339")
    """Usage start."""
    usage_end: Optional[datetime.datetime] = rest_field(name="usageEnd", visibility=["read"], format="rfc3339")
    """Usage end."""
    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read"])
    """The link (url) to the next page of results."""

    @overload
    def __init__(
        self,
        *,
        data: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DismissAlertPayload(_Model):
    """The request payload to update an alert.

    :ivar properties: Alert properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.AlertProperties
    """

    properties: Optional["_models.AlertProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Alert properties."""

    __flattened_items = [
        "definition",
        "description",
        "source",
        "details",
        "cost_entity_id",
        "status",
        "creation_time",
        "close_time",
        "modification_time",
        "status_modification_user_name",
        "status_modification_time",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.AlertProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class DownloadURL(_Model):
    """The URL to download the generated report.

    :ivar expiry_time: The time at which report URL becomes invalid/expires in UTC e.g.
     2020-12-08T05:55:59.4394737Z.
    :vartype expiry_time: ~datetime.datetime
    :ivar valid_till: The time at which report URL becomes invalid/expires in UTC e.g.
     2020-12-08T05:55:59.4394737Z.
    :vartype valid_till: ~datetime.datetime
    :ivar download_url: The URL to download the generated report.
    :vartype download_url: str
    """

    expiry_time: Optional[datetime.datetime] = rest_field(name="expiryTime", visibility=["read"], format="rfc3339")
    """The time at which report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z."""
    valid_till: Optional[datetime.datetime] = rest_field(
        name="validTill", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time at which report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z."""
    download_url: Optional[str] = rest_field(
        name="downloadUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """The URL to download the generated report."""

    @overload
    def __init__(
        self,
        *,
        valid_till: Optional[datetime.datetime] = None,
        download_url: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorAdditionalInfo(_Model):
    """The resource management error additional info.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    type: Optional[str] = rest_field(visibility=["read"])
    """The additional info type."""
    info: Optional[Any] = rest_field(visibility=["read"])
    """The additional info."""


class ErrorDetail(_Model):
    """The error detail.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.mgmt.costmanagement.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.mgmt.costmanagement.models.ErrorAdditionalInfo]
    """

    code: Optional[str] = rest_field(visibility=["read"])
    """The error code."""
    message: Optional[str] = rest_field(visibility=["read"])
    """The error message."""
    target: Optional[str] = rest_field(visibility=["read"])
    """The error target."""
    details: Optional[list["_models.ErrorDetail"]] = rest_field(visibility=["read"])
    """The error details."""
    additional_info: Optional[list["_models.ErrorAdditionalInfo"]] = rest_field(
        name="additionalInfo", visibility=["read"]
    )
    """The error additional info."""


class ErrorDetails(_Model):
    """The details of the error.

    :ivar code: Error code.
    :vartype code: str
    :ivar message: Error message indicating why the operation failed.
    :vartype message: str
    """

    code: Optional[str] = rest_field(visibility=["read"])
    """Error code."""
    message: Optional[str] = rest_field(visibility=["read"])
    """Error message indicating why the operation failed."""


class ErrorDetailsWithNestedDetails(ErrorDetails):
    """The details of the error.

    :ivar code: Error code.
    :vartype code: str
    :ivar message: Error message indicating why the operation failed.
    :vartype message: str
    :ivar details: The additional details of the error.
    :vartype details: list[~azure.mgmt.costmanagement.models.ErrorDetailsWithNestedDetails]
    """

    details: Optional[list["_models.ErrorDetailsWithNestedDetails"]] = rest_field(visibility=["read"])
    """The additional details of the error."""


class ErrorResponse(_Model):
    """Error response indicates that the service is not able to process the incoming request. The
    reason is provided in the error message. \\n\\nSome Error responses: \\n\\n * 429
    TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
    \\"x-ms-ratelimit-microsoft.consumption-retry-after\\" header. \\n\\n * 503 ServiceUnavailable
    - Service is temporarily unavailable. Retry after waiting for the time specified in the
    \\"Retry-After\\" header.

    :ivar error: The details of the error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    error: Optional["_models.ErrorDetails"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The details of the error."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorResponseWithNestedDetails(_Model):
    """Error response indicates that the service is not able to process the incoming request. The
    reason is provided in the error message.

    Some Error responses:



    * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
    "x-ms-ratelimit-microsoft.consumption-retry-after" header.

    * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
    specified in the "Retry-After" header.

    :ivar error: The details of the error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetailsWithNestedDetails
    """

    error: Optional["_models.ErrorDetailsWithNestedDetails"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The details of the error."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetailsWithNestedDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Export(ExtensionResource):
    """An export resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the export.
    :vartype properties: ~azure.mgmt.costmanagement.models.ExportProperties
    :ivar identity: The managed identity associated with Export.
    :vartype identity: ~azure.mgmt.costmanagement.models.SystemAssignedServiceIdentity
    :ivar location: The location of the Export's managed identity. Only required when utilizing
     managed identity.
    :vartype location: str
    :ivar e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
     used to determine whether the user is updating the latest version or not.
    :vartype e_tag: str
    """

    properties: Optional["_models.ExportProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the export."""
    identity: Optional["_models.SystemAssignedServiceIdentity"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The managed identity associated with Export."""
    location: Optional[str] = rest_field(visibility=["read", "create"])
    """The location of the Export's managed identity. Only required when utilizing managed identity."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read", "create", "update", "delete", "query"])
    """eTag of the resource. To handle concurrent update scenario, this field will be used to
     determine whether the user is updating the latest version or not."""

    __flattened_items = [
        "format",
        "delivery_info",
        "definition",
        "run_history",
        "partition_data",
        "data_overwrite_behavior",
        "compression_mode",
        "export_description",
        "next_run_time_estimate",
        "system_suspension_context",
        "schedule",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ExportProperties"] = None,
        identity: Optional["_models.SystemAssignedServiceIdentity"] = None,
        location: Optional[str] = None,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ExportDataset(_Model):
    """The definition for data in the export.

    :ivar granularity: The granularity of rows in the export. Currently 'Daily' is supported for
     most cases. Known values are: "Daily" and "Monthly".
    :vartype granularity: str or ~azure.mgmt.costmanagement.models.GranularityType
    :ivar configuration: The export dataset configuration.
    :vartype configuration: ~azure.mgmt.costmanagement.models.ExportDatasetConfiguration
    """

    granularity: Optional[Union[str, "_models.GranularityType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The granularity of rows in the export. Currently 'Daily' is supported for most cases. Known
     values are: \"Daily\" and \"Monthly\"."""
    configuration: Optional["_models.ExportDatasetConfiguration"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The export dataset configuration."""

    @overload
    def __init__(
        self,
        *,
        granularity: Optional[Union[str, "_models.GranularityType"]] = None,
        configuration: Optional["_models.ExportDatasetConfiguration"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportDatasetConfiguration(_Model):
    """This is on path to deprecation and will not be supported going forward.

    :ivar columns: Array of column names to be included in the export. If not provided then the
     export will include all available columns. The available columns can vary by customer channel
     (see examples).
    :vartype columns: list[str]
    :ivar data_version: The data version for the selected for the export. If not provided then the
     export will default to latest data version.
    :vartype data_version: str
    :ivar filters: Filters associated with the data sets.
    :vartype filters: list[~azure.mgmt.costmanagement.models.FilterItems]
    """

    columns: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of column names to be included in the export. If not provided then the export will
     include all available columns. The available columns can vary by customer channel (see
     examples)."""
    data_version: Optional[str] = rest_field(
        name="dataVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The data version for the selected for the export. If not provided then the export will default
     to latest data version."""
    filters: Optional[list["_models.FilterItems"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Filters associated with the data sets."""

    @overload
    def __init__(
        self,
        *,
        columns: Optional[list[str]] = None,
        data_version: Optional[str] = None,
        filters: Optional[list["_models.FilterItems"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportDefinition(_Model):
    """The definition of an export.

    :ivar type: The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is
     applicable to exports that do not yet provide data for charges or amortization for service
     reservations. Required. Known values are: "Usage", "ActualCost", "AmortizedCost", "FocusCost",
     "PriceSheet", "ReservationTransactions", "ReservationRecommendations", and
     "ReservationDetails".
    :vartype type: str or ~azure.mgmt.costmanagement.models.ExportType
    :ivar timeframe: The time frame for pulling data for the export. If custom, then a specific
     time period must be provided. Required. Known values are: "MonthToDate", "BillingMonthToDate",
     "TheLastMonth", "TheLastBillingMonth", "WeekToDate", "Custom", and "TheCurrentMonth".
    :vartype timeframe: str or ~azure.mgmt.costmanagement.models.TimeframeType
    :ivar time_period: Has time period for pulling data for the export.
    :vartype time_period: ~azure.mgmt.costmanagement.models.ExportTimePeriod
    :ivar data_set: The definition for data in the export.
    :vartype data_set: ~azure.mgmt.costmanagement.models.ExportDataset
    """

    type: Union[str, "_models.ExportType"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to
     exports that do not yet provide data for charges or amortization for service reservations.
     Required. Known values are: \"Usage\", \"ActualCost\", \"AmortizedCost\", \"FocusCost\",
     \"PriceSheet\", \"ReservationTransactions\", \"ReservationRecommendations\", and
     \"ReservationDetails\"."""
    timeframe: Union[str, "_models.TimeframeType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The time frame for pulling data for the export. If custom, then a specific time period must be
     provided. Required. Known values are: \"MonthToDate\", \"BillingMonthToDate\",
     \"TheLastMonth\", \"TheLastBillingMonth\", \"WeekToDate\", \"Custom\", and \"TheCurrentMonth\"."""
    time_period: Optional["_models.ExportTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has time period for pulling data for the export."""
    data_set: Optional["_models.ExportDataset"] = rest_field(
        name="dataSet", visibility=["read", "create", "update", "delete", "query"]
    )
    """The definition for data in the export."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ExportType"],
        timeframe: Union[str, "_models.TimeframeType"],
        time_period: Optional["_models.ExportTimePeriod"] = None,
        data_set: Optional["_models.ExportDataset"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportDeliveryDestination(_Model):
    """This represents the blob storage account location where exports of costs will be delivered.
    There are two ways to configure the destination. The approach recommended for most customers is
    to specify the resourceId of the storage account. This requires a one-time registration of the
    account's subscription with the Microsoft.CostManagementExports resource provider in order to
    give Cost Management services access to the storage. When creating an export in the Azure
    portal this registration is performed automatically but API users may need to register the
    subscription explicitly (for more information see
    `https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services
    <https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services>`_
    ). Another way to configure the destination is available ONLY to Partners with a Microsoft
    Partner Agreement plan who are global admins of their billing account. These Partners, instead
    of specifying the resourceId of a storage account, can specify the storage account name along
    with a SAS token for the account. This allows exports of costs to a storage account in any
    tenant. The SAS token should be created for the blob service with Service/Container/Object
    resource types and with Read/Write/Delete/List/Add/Create permissions (for more information see
    `https://docs.microsoft.com/en-us/azure/cost-management-billing/costs/export-cost-data-storage-account-sas-key
    <https://docs.microsoft.com/en-us/azure/cost-management-billing/costs/export-cost-data-storage-account-sas-key>`_
    ).

    :ivar type: The export delivery destination type. Currently only 'AzureBlob' is supported.
     "AzureBlob"
    :vartype type: str or ~azure.mgmt.costmanagement.models.DestinationType
    :ivar resource_id: The resource id of the storage account where exports will be delivered. This
     is not required if a sasToken and storageAccount are specified.
    :vartype resource_id: str
    :ivar container: The name of the container where exports will be uploaded. If the container
     does not exist it will be created. Required.
    :vartype container: str
    :ivar root_folder_path: The name of the directory where exports will be uploaded.
    :vartype root_folder_path: str
    :ivar sas_token: A SAS token for the storage account. For a restricted set of Azure customers
     this together with storageAccount can be specified instead of resourceId. Note: the value
     returned by the API for this property will always be obfuscated. Returning this same obfuscated
     value will not result in the SAS token being updated. To update this value a new SAS token must
     be specified.
    :vartype sas_token: str
    :ivar storage_account: The storage account where exports will be uploaded. For a restricted set
     of Azure customers this together with sasToken can be specified instead of resourceId.
    :vartype storage_account: str
    """

    type: Optional[Union[str, "_models.DestinationType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The export delivery destination type. Currently only 'AzureBlob' is supported. \"AzureBlob\""""
    resource_id: Optional[str] = rest_field(
        name="resourceId", visibility=["read", "create", "update", "delete", "query"]
    )
    """The resource id of the storage account where exports will be delivered. This is not required if
     a sasToken and storageAccount are specified."""
    container: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the container where exports will be uploaded. If the container does not exist it
     will be created. Required."""
    root_folder_path: Optional[str] = rest_field(
        name="rootFolderPath", visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the directory where exports will be uploaded."""
    sas_token: Optional[str] = rest_field(name="sasToken", visibility=["read", "create", "update", "delete", "query"])
    """A SAS token for the storage account. For a restricted set of Azure customers this together with
     storageAccount can be specified instead of resourceId. Note: the value returned by the API for
     this property will always be obfuscated. Returning this same obfuscated value will not result
     in the SAS token being updated. To update this value a new SAS token must be specified."""
    storage_account: Optional[str] = rest_field(
        name="storageAccount", visibility=["read", "create", "update", "delete", "query"]
    )
    """The storage account where exports will be uploaded. For a restricted set of Azure customers
     this together with sasToken can be specified instead of resourceId."""

    @overload
    def __init__(
        self,
        *,
        container: str,
        type: Optional[Union[str, "_models.DestinationType"]] = None,
        resource_id: Optional[str] = None,
        root_folder_path: Optional[str] = None,
        sas_token: Optional[str] = None,
        storage_account: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportDeliveryInfo(_Model):
    """The delivery information associated with a export.

    :ivar destination: Has destination for the export being delivered. Required.
    :vartype destination: ~azure.mgmt.costmanagement.models.ExportDeliveryDestination
    """

    destination: "_models.ExportDeliveryDestination" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has destination for the export being delivered. Required."""

    @overload
    def __init__(
        self,
        *,
        destination: "_models.ExportDeliveryDestination",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportExecutionListResult(_Model):
    """Result of listing the run history of an export.

    :ivar value: A list of export runs.
    :vartype value: list[~azure.mgmt.costmanagement.models.ExportRun]
    """

    value: Optional[list["_models.ExportRun"]] = rest_field(visibility=["read"])
    """A list of export runs."""


class ExportProperties(CommonExportProperties):
    """The properties of the export.

    :ivar format: The format of the export being delivered. Known values are: "Csv" and "Parquet".
    :vartype format: str or ~azure.mgmt.costmanagement.models.FormatType
    :ivar delivery_info: Has delivery information for the export. Required.
    :vartype delivery_info: ~azure.mgmt.costmanagement.models.ExportDeliveryInfo
    :ivar definition: Has the definition for the export. Required.
    :vartype definition: ~azure.mgmt.costmanagement.models.ExportDefinition
    :ivar run_history: If requested, has the most recent run history for the export.
    :vartype run_history: ~azure.mgmt.costmanagement.models.ExportExecutionListResult
    :ivar partition_data: If set to true, exported data will be partitioned by size and placed in a
     blob directory together with a manifest file.
    :vartype partition_data: bool
    :ivar data_overwrite_behavior: Allow customers to select overwrite
     data(OverwritePreviousReport) for exports. This setting will enable overwrite data for the same
     month in customer storage account. By default set to CreateNewReport. Known values are:
     "OverwritePreviousReport" and "CreateNewReport".
    :vartype data_overwrite_behavior: str or
     ~azure.mgmt.costmanagement.models.DataOverwriteBehaviorType
    :ivar compression_mode: Allow customers to select compress data for exports. This setting will
     enable destination file compression scheme at runtime. By default set to None. Gzip is for csv
     and snappy for parquet. Known values are: "gzip", "snappy", and "none".
    :vartype compression_mode: str or ~azure.mgmt.costmanagement.models.CompressionModeType
    :ivar export_description: The export description set by customer at time of export
     creation/update.
    :vartype export_description: str
    :ivar next_run_time_estimate: If the export has an active schedule, provides an estimate of the
     next run time.
    :vartype next_run_time_estimate: ~datetime.datetime
    :ivar system_suspension_context: The export suspension reason if export is in SystemSuspended
     state. This is not populated currently.
    :vartype system_suspension_context: ~azure.mgmt.costmanagement.models.ExportSuspensionContext
    :ivar schedule: Has schedule information for the export.
    :vartype schedule: ~azure.mgmt.costmanagement.models.ExportSchedule
    """

    schedule: Optional["_models.ExportSchedule"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has schedule information for the export."""

    @overload
    def __init__(
        self,
        *,
        delivery_info: "_models.ExportDeliveryInfo",
        definition: "_models.ExportDefinition",
        format: Optional[Union[str, "_models.FormatType"]] = None,
        run_history: Optional["_models.ExportExecutionListResult"] = None,
        partition_data: Optional[bool] = None,
        data_overwrite_behavior: Optional[Union[str, "_models.DataOverwriteBehaviorType"]] = None,
        compression_mode: Optional[Union[str, "_models.CompressionModeType"]] = None,
        export_description: Optional[str] = None,
        schedule: Optional["_models.ExportSchedule"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportRecurrencePeriod(_Model):
    """The start and end date for recurrence schedule.

    :ivar from_property: The start date of recurrence. Required.
    :vartype from_property: ~datetime.datetime
    :ivar to: The end date of recurrence.
    :vartype to: ~datetime.datetime
    """

    from_property: datetime.datetime = rest_field(
        name="from", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date of recurrence. Required."""
    to: Optional[datetime.datetime] = rest_field(
        visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end date of recurrence."""

    @overload
    def __init__(
        self,
        *,
        from_property: datetime.datetime,
        to: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportRun(CostManagementProxyResource):
    """An export run.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
     used to determine whether the user is updating the latest version or not.
    :vartype e_tag: str
    :ivar properties: The properties of the export run.
    :vartype properties: ~azure.mgmt.costmanagement.models.ExportRunProperties
    """

    properties: Optional["_models.ExportRunProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the export run."""

    __flattened_items = [
        "execution_type",
        "status",
        "submitted_by",
        "submitted_time",
        "processing_start_time",
        "processing_end_time",
        "start_date",
        "end_date",
        "file_name",
        "manifest_file",
        "run_settings",
        "error",
    ]

    @overload
    def __init__(
        self,
        *,
        e_tag: Optional[str] = None,
        properties: Optional["_models.ExportRunProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ExportRunProperties(_Model):
    """The properties of the export run.

    :ivar execution_type: The type of the export run. Known values are: "OnDemand" and "Scheduled".
    :vartype execution_type: str or ~azure.mgmt.costmanagement.models.ExecutionType
    :ivar status: The last known status of the export run. Known values are: "Queued",
     "InProgress", "Completed", "Failed", "Timeout", "NewDataNotAvailable", and "DataNotAvailable".
    :vartype status: str or ~azure.mgmt.costmanagement.models.ExecutionStatus
    :ivar submitted_by: The identifier for the entity that triggered the export. For on-demand runs
     it is the user email. For scheduled runs it is 'System'.
    :vartype submitted_by: str
    :ivar submitted_time: The time when export was queued to be run.
    :vartype submitted_time: ~datetime.datetime
    :ivar processing_start_time: The time when export was picked up to be run.
    :vartype processing_start_time: ~datetime.datetime
    :ivar processing_end_time: The time when the export run finished.
    :vartype processing_end_time: ~datetime.datetime
    :ivar start_date: The start datetime for the export.
    :vartype start_date: ~datetime.datetime
    :ivar end_date: The end datetime for the export.
    :vartype end_date: ~datetime.datetime
    :ivar file_name: The name of the exported file.
    :vartype file_name: str
    :ivar manifest_file: The manifest file location(URI location) for the exported files.
    :vartype manifest_file: str
    :ivar run_settings: The export settings that were in effect for this run.
    :vartype run_settings: ~azure.mgmt.costmanagement.models.CommonExportProperties
    :ivar error: The details of any error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    execution_type: Optional[Union[str, "_models.ExecutionType"]] = rest_field(
        name="executionType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of the export run. Known values are: \"OnDemand\" and \"Scheduled\"."""
    status: Optional[Union[str, "_models.ExecutionStatus"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The last known status of the export run. Known values are: \"Queued\", \"InProgress\",
     \"Completed\", \"Failed\", \"Timeout\", \"NewDataNotAvailable\", and \"DataNotAvailable\"."""
    submitted_by: Optional[str] = rest_field(
        name="submittedBy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identifier for the entity that triggered the export. For on-demand runs it is the user
     email. For scheduled runs it is 'System'."""
    submitted_time: Optional[datetime.datetime] = rest_field(
        name="submittedTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time when export was queued to be run."""
    processing_start_time: Optional[datetime.datetime] = rest_field(
        name="processingStartTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time when export was picked up to be run."""
    processing_end_time: Optional[datetime.datetime] = rest_field(
        name="processingEndTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time when the export run finished."""
    start_date: Optional[datetime.datetime] = rest_field(
        name="startDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start datetime for the export."""
    end_date: Optional[datetime.datetime] = rest_field(
        name="endDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end datetime for the export."""
    file_name: Optional[str] = rest_field(name="fileName", visibility=["read", "create", "update", "delete", "query"])
    """The name of the exported file."""
    manifest_file: Optional[str] = rest_field(
        name="manifestFile", visibility=["read", "create", "update", "delete", "query"]
    )
    """The manifest file location(URI location) for the exported files."""
    run_settings: Optional["_models.CommonExportProperties"] = rest_field(
        name="runSettings", visibility=["read", "create", "update", "delete", "query"]
    )
    """The export settings that were in effect for this run."""
    error: Optional["_models.ErrorDetails"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The details of any error."""

    @overload
    def __init__(
        self,
        *,
        execution_type: Optional[Union[str, "_models.ExecutionType"]] = None,
        status: Optional[Union[str, "_models.ExecutionStatus"]] = None,
        submitted_by: Optional[str] = None,
        submitted_time: Optional[datetime.datetime] = None,
        processing_start_time: Optional[datetime.datetime] = None,
        processing_end_time: Optional[datetime.datetime] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        file_name: Optional[str] = None,
        manifest_file: Optional[str] = None,
        run_settings: Optional["_models.CommonExportProperties"] = None,
        error: Optional["_models.ErrorDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportRunRequest(_Model):
    """The export run request.

    :ivar time_period: Has time period for pulling data for the export.
    :vartype time_period: ~azure.mgmt.costmanagement.models.ExportTimePeriod
    """

    time_period: Optional["_models.ExportTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has time period for pulling data for the export."""

    @overload
    def __init__(
        self,
        *,
        time_period: Optional["_models.ExportTimePeriod"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportSchedule(_Model):
    """The schedule associated with the export.

    :ivar status: The status of the export's schedule. If 'Inactive', the export's schedule is
     paused. To enable export set the status to be Active and then make a PUT request. Known values
     are: "Active" and "Inactive".
    :vartype status: str or ~azure.mgmt.costmanagement.models.StatusType
    :ivar recurrence: The schedule recurrence. Known values are: "Daily", "Weekly", "Monthly", and
     "Annually".
    :vartype recurrence: str or ~azure.mgmt.costmanagement.models.RecurrenceType
    :ivar recurrence_period: Has start and end date of the recurrence. The start date must be in
     future. If present, the end date must be greater than start date.
    :vartype recurrence_period: ~azure.mgmt.costmanagement.models.ExportRecurrencePeriod
    """

    status: Optional[Union[str, "_models.StatusType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The status of the export's schedule. If 'Inactive', the export's schedule is paused. To enable
     export set the status to be Active and then make a PUT request. Known values are: \"Active\"
     and \"Inactive\"."""
    recurrence: Optional[Union[str, "_models.RecurrenceType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The schedule recurrence. Known values are: \"Daily\", \"Weekly\", \"Monthly\", and
     \"Annually\"."""
    recurrence_period: Optional["_models.ExportRecurrencePeriod"] = rest_field(
        name="recurrencePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has start and end date of the recurrence. The start date must be in future. If present, the end
     date must be greater than start date."""

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.StatusType"]] = None,
        recurrence: Optional[Union[str, "_models.RecurrenceType"]] = None,
        recurrence_period: Optional["_models.ExportRecurrencePeriod"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportSuspensionContext(_Model):
    """The properties of the export run. This is not populated currently.

    :ivar suspension_code: The code for export suspension.
    :vartype suspension_code: str
    :ivar suspension_reason: The detailed reason for export suspension.
    :vartype suspension_reason: str
    :ivar suspension_time: The time when the export was suspended.
    :vartype suspension_time: ~datetime.datetime
    """

    suspension_code: Optional[str] = rest_field(
        name="suspensionCode", visibility=["read", "create", "update", "delete", "query"]
    )
    """The code for export suspension."""
    suspension_reason: Optional[str] = rest_field(
        name="suspensionReason", visibility=["read", "create", "update", "delete", "query"]
    )
    """The detailed reason for export suspension."""
    suspension_time: Optional[datetime.datetime] = rest_field(
        name="suspensionTime", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time when the export was suspended."""

    @overload
    def __init__(
        self,
        *,
        suspension_code: Optional[str] = None,
        suspension_reason: Optional[str] = None,
        suspension_time: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExportTimePeriod(_Model):
    """The date range for data in the export. This should only be specified with timeFrame set to
    'Custom'. The maximum date range is 1 calendar month.

    :ivar from_property: The start date for export data. Required.
    :vartype from_property: ~datetime.datetime
    :ivar to: The end date for export data. Required.
    :vartype to: ~datetime.datetime
    """

    from_property: datetime.datetime = rest_field(
        name="from", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date for export data. Required."""
    to: datetime.datetime = rest_field(visibility=["read", "create", "update", "delete", "query"], format="rfc3339")
    """The end date for export data. Required."""

    @overload
    def __init__(
        self,
        *,
        from_property: datetime.datetime,
        to: datetime.datetime,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FileDestination(_Model):
    """Destination of the view data. This is optional. Currently only CSV format is supported.

    :ivar file_formats: Destination of the view data. Currently only CSV format is supported.
    :vartype file_formats: list[str or ~azure.mgmt.costmanagement.models.FileFormat]
    """

    file_formats: Optional[list[Union[str, "_models.FileFormat"]]] = rest_field(
        name="fileFormats", visibility=["read", "create", "update", "delete", "query"]
    )
    """Destination of the view data. Currently only CSV format is supported."""

    @overload
    def __init__(
        self,
        *,
        file_formats: Optional[list[Union[str, "_models.FileFormat"]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FilterItems(_Model):
    """Will contain the filter name and value to operate on. This is currently only supported for
    Export Definition type of ReservationRecommendations.

    :ivar name: The name of the filter. This is currently only supported for Export Definition type
     of ReservationRecommendations. Supported names are ['ReservationScope', 'LookBackPeriod',
     'ResourceType']. Known values are: "ReservationScope", "ResourceType", and "LookBackPeriod".
    :vartype name: str or ~azure.mgmt.costmanagement.models.FilterItemNames
    :ivar value: Value to filter by. Currently values supported per name are, for
     'ReservationScope' supported values are ['Single', 'Shared'], for 'LookBackPeriod' supported
     values are ['Last7Days', 'Last30Days', 'Last60Days'] and for 'ResourceType' supported values
     are ['VirtualMachines', 'SQLDatabases', 'PostgreSQL', 'ManagedDisk', 'MySQL', 'RedHat',
     'MariaDB', 'RedisCache', 'CosmosDB', 'SqlDataWarehouse', 'SUSELinux', 'AppService',
     'BlockBlob', 'AzureDataExplorer', 'VMwareCloudSimple'].
    :vartype value: str
    """

    name: Optional[Union[str, "_models.FilterItemNames"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the filter. This is currently only supported for Export Definition type of
     ReservationRecommendations. Supported names are ['ReservationScope', 'LookBackPeriod',
     'ResourceType']. Known values are: \"ReservationScope\", \"ResourceType\", and
     \"LookBackPeriod\"."""
    value: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Value to filter by. Currently values supported per name are, for 'ReservationScope' supported
     values are ['Single', 'Shared'], for 'LookBackPeriod' supported values are ['Last7Days',
     'Last30Days', 'Last60Days'] and for 'ResourceType' supported values are ['VirtualMachines',
     'SQLDatabases', 'PostgreSQL', 'ManagedDisk', 'MySQL', 'RedHat', 'MariaDB', 'RedisCache',
     'CosmosDB', 'SqlDataWarehouse', 'SUSELinux', 'AppService', 'BlockBlob', 'AzureDataExplorer',
     'VMwareCloudSimple']."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[Union[str, "_models.FilterItemNames"]] = None,
        value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastAggregation(_Model):
    """The aggregation expression to be used in the forecast.

    :ivar name: The name of the column to aggregate. Required. Known values are: "PreTaxCostUSD",
     "Cost", "CostUSD", and "PreTaxCost".
    :vartype name: str or ~azure.mgmt.costmanagement.models.FunctionName
    :ivar function: The name of the aggregation function to use. Required. "Sum"
    :vartype function: str or ~azure.mgmt.costmanagement.models.FunctionType
    """

    name: Union[str, "_models.FunctionName"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to aggregate. Required. Known values are: \"PreTaxCostUSD\", \"Cost\",
     \"CostUSD\", and \"PreTaxCost\"."""
    function: Union[str, "_models.FunctionType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the aggregation function to use. Required. \"Sum\""""

    @overload
    def __init__(
        self,
        *,
        name: Union[str, "_models.FunctionName"],
        function: Union[str, "_models.FunctionType"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastColumn(_Model):
    """Forecast column properties.

    :ivar name: The name of column.
    :vartype name: str
    :ivar type: The type of column.
    :vartype type: str
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of column."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The type of column."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastComparisonExpression(_Model):
    """The comparison expression to be used in the forecast.

    :ivar name: The name of the column to use in comparison. Required.
    :vartype name: str
    :ivar operator: The operator to use for comparison. Required. "In"
    :vartype operator: str or ~azure.mgmt.costmanagement.models.ForecastOperatorType
    :ivar values_property: Array of values to use for comparison. Required.
    :vartype values_property: list[str]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to use in comparison. Required."""
    operator: Union[str, "_models.ForecastOperatorType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The operator to use for comparison. Required. \"In\""""
    values_property: list[str] = rest_field(name="values", visibility=["read", "create", "update", "delete", "query"])
    """Array of values to use for comparison. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        operator: Union[str, "_models.ForecastOperatorType"],
        values_property: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastDataset(_Model):
    """The definition of data present in the forecast.

    :ivar granularity: The granularity of rows in the forecast. Known values are: "Daily" and
     "Monthly".
    :vartype granularity: str or ~azure.mgmt.costmanagement.models.GranularityType
    :ivar configuration: Has configuration information for the data in the export. The
     configuration will be ignored if aggregation and grouping are provided.
    :vartype configuration: ~azure.mgmt.costmanagement.models.ForecastDatasetConfiguration
    :ivar aggregation: Dictionary of aggregation expression to use in the forecast. The key of each
     item in the dictionary is the alias for the aggregated column. forecast can have up to 2
     aggregation clauses. Required.
    :vartype aggregation: dict[str, ~azure.mgmt.costmanagement.models.ForecastAggregation]
    :ivar filter: Has filter expression to use in the forecast.
    :vartype filter: ~azure.mgmt.costmanagement.models.ForecastFilter
    """

    granularity: Optional[Union[str, "_models.GranularityType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The granularity of rows in the forecast. Known values are: \"Daily\" and \"Monthly\"."""
    configuration: Optional["_models.ForecastDatasetConfiguration"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has configuration information for the data in the export. The configuration will be ignored if
     aggregation and grouping are provided."""
    aggregation: dict[str, "_models.ForecastAggregation"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Dictionary of aggregation expression to use in the forecast. The key of each item in the
     dictionary is the alias for the aggregated column. forecast can have up to 2 aggregation
     clauses. Required."""
    filter: Optional["_models.ForecastFilter"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Has filter expression to use in the forecast."""

    @overload
    def __init__(
        self,
        *,
        aggregation: dict[str, "_models.ForecastAggregation"],
        granularity: Optional[Union[str, "_models.GranularityType"]] = None,
        configuration: Optional["_models.ForecastDatasetConfiguration"] = None,
        filter: Optional["_models.ForecastFilter"] = None,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastDatasetConfiguration(_Model):
    """The configuration of dataset in the forecast.

    :ivar columns: Array of column names to be included in the forecast. Any valid forecast column
     name is allowed. If not provided, then forecast includes all columns.
    :vartype columns: list[str]
    """

    columns: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of column names to be included in the forecast. Any valid forecast column name is
     allowed. If not provided, then forecast includes all columns."""

    @overload
    def __init__(
        self,
        *,
        columns: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastDefinition(_Model):
    """The definition of a forecast.

    :ivar type: The type of the forecast. Required. Known values are: "Usage", "ActualCost", and
     "AmortizedCost".
    :vartype type: str or ~azure.mgmt.costmanagement.models.ForecastType
    :ivar timeframe: The time frame for pulling data for the forecast. If custom, then a specific
     time period must be provided. Required. "Custom"
    :vartype timeframe: str or ~azure.mgmt.costmanagement.models.ForecastTimeframe
    :ivar time_period: Has time period for pulling data for the forecast.
    :vartype time_period: ~azure.mgmt.costmanagement.models.ForecastTimePeriod
    :ivar dataset: Has definition for data in this forecast. Required.
    :vartype dataset: ~azure.mgmt.costmanagement.models.ForecastDataset
    :ivar include_actual_cost: A boolean determining if actualCost will be included.
    :vartype include_actual_cost: bool
    :ivar include_fresh_partial_cost: A boolean determining if FreshPartialCost will be included.
    :vartype include_fresh_partial_cost: bool
    """

    type: Union[str, "_models.ForecastType"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The type of the forecast. Required. Known values are: \"Usage\", \"ActualCost\", and
     \"AmortizedCost\"."""
    timeframe: Union[str, "_models.ForecastTimeframe"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The time frame for pulling data for the forecast. If custom, then a specific time period must
     be provided. Required. \"Custom\""""
    time_period: Optional["_models.ForecastTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has time period for pulling data for the forecast."""
    dataset: "_models.ForecastDataset" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Has definition for data in this forecast. Required."""
    include_actual_cost: Optional[bool] = rest_field(
        name="includeActualCost", visibility=["read", "create", "update", "delete", "query"]
    )
    """A boolean determining if actualCost will be included."""
    include_fresh_partial_cost: Optional[bool] = rest_field(
        name="includeFreshPartialCost", visibility=["read", "create", "update", "delete", "query"]
    )
    """A boolean determining if FreshPartialCost will be included."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ForecastType"],
        timeframe: Union[str, "_models.ForecastTimeframe"],
        dataset: "_models.ForecastDataset",
        time_period: Optional["_models.ForecastTimePeriod"] = None,
        include_actual_cost: Optional[bool] = None,
        include_fresh_partial_cost: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastFilter(_Model):
    """The filter expression to be used in the export.

    :ivar and_property: The logical "AND" expression. Must have at least 2 items.
    :vartype and_property: list[~azure.mgmt.costmanagement.models.ForecastFilter]
    :ivar or_property: The logical "OR" expression. Must have at least 2 items.
    :vartype or_property: list[~azure.mgmt.costmanagement.models.ForecastFilter]
    :ivar dimensions: Has comparison expression for a dimension.
    :vartype dimensions: ~azure.mgmt.costmanagement.models.ForecastComparisonExpression
    :ivar tags: Has comparison expression for a tag.
    :vartype tags: ~azure.mgmt.costmanagement.models.ForecastComparisonExpression
    """

    and_property: Optional[list["_models.ForecastFilter"]] = rest_field(
        name="and", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"AND\" expression. Must have at least 2 items."""
    or_property: Optional[list["_models.ForecastFilter"]] = rest_field(
        name="or", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"OR\" expression. Must have at least 2 items."""
    dimensions: Optional["_models.ForecastComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a dimension."""
    tags: Optional["_models.ForecastComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a tag."""

    @overload
    def __init__(
        self,
        *,
        and_property: Optional[list["_models.ForecastFilter"]] = None,
        or_property: Optional[list["_models.ForecastFilter"]] = None,
        dimensions: Optional["_models.ForecastComparisonExpression"] = None,
        tags: Optional["_models.ForecastComparisonExpression"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastProperties(_Model):
    """Forecast properties.

    :ivar next_link: The link (url) to the next page of results.
    :vartype next_link: str
    :ivar columns: Array of columns.
    :vartype columns: list[~azure.mgmt.costmanagement.models.ForecastColumn]
    :ivar rows: Array of rows.
    :vartype rows: list[list[any]]
    """

    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read", "create", "update", "delete", "query"])
    """The link (url) to the next page of results."""
    columns: Optional[list["_models.ForecastColumn"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Array of columns."""
    rows: Optional[list[list[Any]]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of rows."""

    @overload
    def __init__(
        self,
        *,
        next_link: Optional[str] = None,
        columns: Optional[list["_models.ForecastColumn"]] = None,
        rows: Optional[list[list[Any]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForecastResult(CostManagementResource):
    """Result of forecast. It contains all columns listed under groupings and aggregation.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar location: Location of the resource.
    :vartype location: str
    :ivar sku: SKU of the resource.
    :vartype sku: str
    :ivar e_tag: ETag of the resource.
    :vartype e_tag: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar properties: Forecast properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.ForecastProperties
    """

    properties: Optional["_models.ForecastProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Forecast properties."""

    __flattened_items = ["next_link", "columns", "rows"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ForecastProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ForecastSpend(_Model):
    """The forecasted cost which is being tracked for a budget.

    Supported for CategoryType(s): Cost.

    :ivar amount: The forecasted cost for the total time period which is being tracked by the
     budget. This value is only provided if the budget contains a forecast alert type.
    :vartype amount: float
    :ivar unit: The unit of measure for the budget amount.
    :vartype unit: str
    """

    amount: Optional[float] = rest_field(visibility=["read"])
    """The forecasted cost for the total time period which is being tracked by the budget. This value
     is only provided if the budget contains a forecast alert type."""
    unit: Optional[str] = rest_field(visibility=["read"])
    """The unit of measure for the budget amount."""


class ForecastTimePeriod(_Model):
    """Has time period for pulling data for the forecast.

    :ivar from_property: The start date to pull data from. Required.
    :vartype from_property: ~datetime.datetime
    :ivar to: The end date to pull data to. Required.
    :vartype to: ~datetime.datetime
    """

    from_property: datetime.datetime = rest_field(
        name="from", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date to pull data from. Required."""
    to: datetime.datetime = rest_field(visibility=["read", "create", "update", "delete", "query"], format="rfc3339")
    """The end date to pull data to. Required."""

    @overload
    def __init__(
        self,
        *,
        from_property: datetime.datetime,
        to: datetime.datetime,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateCostDetailsReportErrorResponse(_Model):
    """Error response indicates that the service is not able to process the incoming request. The
    reason is provided in the error message.

    Some Error responses:



    * 400 Bad Request - Invalid Request Payload. Request payload provided is not in a json format
    or had an invalid member not accepted in the request payload.

    * 400 Bad Request - Invalid request payload:  can only have either timePeriod or invoiceId or
    billingPeriod. API only allows data to be pulled for either timePeriod or invoiceId or
    billingPeriod. Customer should provide only one of these parameters.

    * 400 Bad Request - Start date must be after . API only allows data to be pulled no older than
    13 months from now.

    * 400 Bad Request - The maximum allowed date range is 1 months. API only allows data to be
    pulled for 1 month or less.

    * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
    "retry-after" header.

    * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
    specified in the "Retry-After" header.

    :ivar error: The details of the error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    error: Optional["_models.ErrorDetails"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The details of the error."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateCostDetailsReportRequestDefinition(_Model):  # pylint: disable=name-too-long
    """The definition of a cost detailed report.

    :ivar metric: The type of the detailed report. By default ActualCost is provided. Known values
     are: "ActualCost" and "AmortizedCost".
    :vartype metric: str or ~azure.mgmt.costmanagement.models.CostDetailsMetricType
    :ivar time_period: The specific date range of cost details requested for the report. This
     parameter cannot be used alongside either the invoiceId or billingPeriod parameters. If a
     timePeriod, invoiceId or billingPeriod parameter is not provided in the request body the API
     will return the current month's cost. API only allows data to be pulled for 1 month or less and
     no older than 13 months. If no timePeriod or billingPeriod or invoiceId is provided the API
     defaults to the open month time period.
    :vartype time_period: ~azure.mgmt.costmanagement.models.CostDetailsTimePeriod
    :ivar billing_period: This parameter can be used only by Enterprise Agreement customers. Use
     the YearMonth(e.g. 202008) format. This parameter cannot be used alongside either the invoiceId
     or timePeriod parameters. If a timePeriod, invoiceId or billingPeriod parameter is not provided
     in the request body the API will return the current month's cost.
    :vartype billing_period: str
    :ivar invoice_id: This parameter can only be used by Microsoft Customer Agreement customers.
     Additionally, it can only be used at the Billing Profile or Customer scope. This parameter
     cannot be used alongside either the billingPeriod or timePeriod parameters. If a timePeriod,
     invoiceId or billingPeriod parameter is not provided in the request body the API will return
     the current month's cost.
    :vartype invoice_id: str
    """

    metric: Optional[Union[str, "_models.CostDetailsMetricType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of the detailed report. By default ActualCost is provided. Known values are:
     \"ActualCost\" and \"AmortizedCost\"."""
    time_period: Optional["_models.CostDetailsTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """The specific date range of cost details requested for the report. This parameter cannot be used
     alongside either the invoiceId or billingPeriod parameters. If a timePeriod, invoiceId or
     billingPeriod parameter is not provided in the request body the API will return the current
     month's cost. API only allows data to be pulled for 1 month or less and no older than 13
     months. If no timePeriod or billingPeriod or invoiceId is provided the API defaults to the open
     month time period."""
    billing_period: Optional[str] = rest_field(
        name="billingPeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """This parameter can be used only by Enterprise Agreement customers. Use the YearMonth(e.g.
     202008) format. This parameter cannot be used alongside either the invoiceId or timePeriod
     parameters. If a timePeriod, invoiceId or billingPeriod parameter is not provided in the
     request body the API will return the current month's cost."""
    invoice_id: Optional[str] = rest_field(name="invoiceId", visibility=["read", "create", "update", "delete", "query"])
    """This parameter can only be used by Microsoft Customer Agreement customers. Additionally, it can
     only be used at the Billing Profile or Customer scope. This parameter cannot be used alongside
     either the billingPeriod or timePeriod parameters. If a timePeriod, invoiceId or billingPeriod
     parameter is not provided in the request body the API will return the current month's cost."""

    @overload
    def __init__(
        self,
        *,
        metric: Optional[Union[str, "_models.CostDetailsMetricType"]] = None,
        time_period: Optional["_models.CostDetailsTimePeriod"] = None,
        billing_period: Optional[str] = None,
        invoice_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateDetailedCostReportDefinition(_Model):
    """The definition of a cost detailed report.

    :ivar metric: The type of the detailed report. By default ActualCost is provided. Known values
     are: "ActualCost" and "AmortizedCost".
    :vartype metric: str or ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportMetricType
    :ivar time_period: Has time period for pulling data for the cost detailed report. Can only have
     one of either timePeriod or invoiceId or billingPeriod parameters. If none provided current
     month cost is provided.
    :vartype time_period: ~azure.mgmt.costmanagement.models.GenerateDetailedCostReportTimePeriod
    :ivar billing_period: Billing period in YearMonth(e.g. 202008) format. Only for legacy
     enterprise customers can use this. Can only have one of either timePeriod or invoiceId or
     billingPeriod parameters. If none provided current month cost is provided.
    :vartype billing_period: str
    :ivar invoice_id: Invoice ID for Pay-as-you-go and Microsoft Customer Agreement scopes. Can
     only have one of either timePeriod or invoiceId or billingPeriod parameters. If none provided
     current month cost is provided.
    :vartype invoice_id: str
    :ivar customer_id: Customer ID for Microsoft Customer Agreement scopes (Invoice Id is also
     required for this).
    :vartype customer_id: str
    """

    metric: Optional[Union[str, "_models.GenerateDetailedCostReportMetricType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of the detailed report. By default ActualCost is provided. Known values are:
     \"ActualCost\" and \"AmortizedCost\"."""
    time_period: Optional["_models.GenerateDetailedCostReportTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has time period for pulling data for the cost detailed report. Can only have one of either
     timePeriod or invoiceId or billingPeriod parameters. If none provided current month cost is
     provided."""
    billing_period: Optional[str] = rest_field(
        name="billingPeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Billing period in YearMonth(e.g. 202008) format. Only for legacy enterprise customers can use
     this. Can only have one of either timePeriod or invoiceId or billingPeriod parameters. If none
     provided current month cost is provided."""
    invoice_id: Optional[str] = rest_field(name="invoiceId", visibility=["read", "create", "update", "delete", "query"])
    """Invoice ID for Pay-as-you-go and Microsoft Customer Agreement scopes. Can only have one of
     either timePeriod or invoiceId or billingPeriod parameters. If none provided current month cost
     is provided."""
    customer_id: Optional[str] = rest_field(
        name="customerId", visibility=["read", "create", "update", "delete", "query"]
    )
    """Customer ID for Microsoft Customer Agreement scopes (Invoice Id is also required for this)."""

    @overload
    def __init__(
        self,
        *,
        metric: Optional[Union[str, "_models.GenerateDetailedCostReportMetricType"]] = None,
        time_period: Optional["_models.GenerateDetailedCostReportTimePeriod"] = None,
        billing_period: Optional[str] = None,
        invoice_id: Optional[str] = None,
        customer_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateDetailedCostReportErrorResponse(_Model):
    """Error response indicates that the service is not able to process the incoming request. The
    reason is provided in the error message.

    Some Error responses:



    * 413 Request Entity Too Large - Request is throttled. The amount of data required to fulfill
    the request exceeds the maximum size permitted of 2Gb. Please utilize our Exports feature
    instead.

    * 429 TooManyRequests - Request is throttled. Retry after waiting for the time specified in the
    "x-ms-ratelimit-microsoft.consumption-retry-after" header.

    * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after waiting for the time
    specified in the "Retry-After" header.

    :ivar error: The details of the error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    error: Optional["_models.ErrorDetails"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The details of the error."""

    @overload
    def __init__(
        self,
        *,
        error: Optional["_models.ErrorDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateDetailedCostReportOperationResult(ExtensionResource):  # pylint: disable=name-too-long
    """The result of the long running operation for cost detailed report.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the resource generated.
    :vartype properties: ~azure.mgmt.costmanagement.models.DownloadURL
    """

    properties: Optional["_models.DownloadURL"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The properties of the resource generated."""

    __flattened_items = ["expiry_time", "valid_till", "download_url"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.DownloadURL"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class GenerateDetailedCostReportOperationStatuses(ExtensionResource):  # pylint: disable=name-too-long
    """The status of the long running operation for cost detailed report.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the usage file generated.
    :vartype properties: ~azure.mgmt.costmanagement.models.DownloadURL
    :ivar status: The status of the long running operation.
    :vartype status: ~azure.mgmt.costmanagement.models.Status
    :ivar start_time: The startTime of the operation.
    :vartype start_time: str
    :ivar end_time: The endTime of the operation.
    :vartype end_time: str
    :ivar error: The details of the error.
    :vartype error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    properties: Optional["_models.DownloadURL"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The properties of the usage file generated."""
    status: Optional["_models.Status"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The status of the long running operation."""
    start_time: Optional[str] = rest_field(name="startTime", visibility=["read", "create", "update", "delete", "query"])
    """The startTime of the operation."""
    end_time: Optional[str] = rest_field(name="endTime", visibility=["read", "create", "update", "delete", "query"])
    """The endTime of the operation."""
    error: Optional["_models.ErrorDetails"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The details of the error."""

    __flattened_items = ["expiry_time", "valid_till", "download_url"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.DownloadURL"] = None,
        status: Optional["_models.Status"] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        error: Optional["_models.ErrorDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class GenerateDetailedCostReportTimePeriod(_Model):
    """The start and end date for pulling data for the cost detailed report.

    :ivar start: The start date to pull data from. example format 2020-03-15. Required.
    :vartype start: str
    :ivar end: The end date to pull data to. example format 2020-03-15. Required.
    :vartype end: str
    """

    start: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The start date to pull data from. example format 2020-03-15. Required."""
    end: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The end date to pull data to. example format 2020-03-15. Required."""

    @overload
    def __init__(
        self,
        *,
        start: str,
        end: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IncludedQuantityUtilizationSummary(BenefitUtilizationSummary, discriminator="IncludedQuantity"):
    """Included Quantity utilization summary resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: Included Quantity utilization summary properties.
    :vartype properties:
     ~azure.mgmt.costmanagement.models.IncludedQuantityUtilizationSummaryProperties
    :ivar kind: Supported values: 'SavingsPlan'. Required. Benefit is IncludedQuantity.
    :vartype kind: str or ~azure.mgmt.costmanagement.models.INCLUDED_QUANTITY
    """

    properties: Optional["_models.IncludedQuantityUtilizationSummaryProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Included Quantity utilization summary properties."""
    kind: Literal[BenefitKind.INCLUDED_QUANTITY] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Supported values: 'SavingsPlan'. Required. Benefit is IncludedQuantity."""

    __flattened_items = [
        "arm_sku_name",
        "benefit_id",
        "benefit_order_id",
        "benefit_type",
        "usage_date",
        "utilization_percentage",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.IncludedQuantityUtilizationSummaryProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class IncludedQuantityUtilizationSummaryProperties(
    BenefitUtilizationSummaryProperties
):  # pylint: disable=name-too-long
    """Included Quantity utilization summary properties.

    :ivar arm_sku_name: ARM SKU name. For example, 'Compute_Savings_Plan' for savings plan.
    :vartype arm_sku_name: str
    :ivar benefit_id: The benefit ID is the identifier of the benefit.
    :vartype benefit_id: str
    :ivar benefit_order_id: The benefit order ID is the identifier for a benefit purchase.
    :vartype benefit_order_id: str
    :ivar benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
     "IncludedQuantity", "Reservation", and "SavingsPlan".
    :vartype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
    :ivar usage_date: Date corresponding to the utilization summary record. If the grain of data is
     monthly, value for this field will be first day of the month.
    :vartype usage_date: ~datetime.datetime
    :ivar utilization_percentage: This is the utilized percentage for the benefit ID.
    :vartype utilization_percentage: ~decimal.Decimal
    """

    utilization_percentage: Optional[decimal.Decimal] = rest_field(name="utilizationPercentage", visibility=["read"])
    """This is the utilized percentage for the benefit ID."""

    @overload
    def __init__(
        self,
        *,
        benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class KpiProperties(_Model):
    """Each KPI must contain a 'type' and 'enabled' key.

    :ivar type: KPI type (Forecast, Budget). Known values are: "Forecast" and "Budget".
    :vartype type: str or ~azure.mgmt.costmanagement.models.KpiTypeType
    :ivar id: ID of resource related to metric (budget).
    :vartype id: str
    :ivar enabled: show the KPI in the UI?.
    :vartype enabled: bool
    """

    type: Optional[Union[str, "_models.KpiTypeType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """KPI type (Forecast, Budget). Known values are: \"Forecast\" and \"Budget\"."""
    id: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """ID of resource related to metric (budget)."""
    enabled: Optional[bool] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """show the KPI in the UI?."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.KpiTypeType"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        enabled: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MCAPriceSheetProperties(_Model):
    """The properties of the price sheet.

    :ivar billing_account_id: Unique identifier for the billing account.
    :vartype billing_account_id: str
    :ivar billing_account_name: Name of the billing profile that is set up to receive invoices. The
     prices in the price sheet are associated with this billing profile.
    :vartype billing_account_name: str
    :ivar billing_profile_id: Unique identifier for the billing profile.
    :vartype billing_profile_id: str
    :ivar billing_profile_name: Name of the billing profile that is set up to receive invoices. The
     prices in the price sheet are associated with this billing profile.
    :vartype billing_profile_name: str
    :ivar product_order_name: Name of the purchased product plan. Indicates if this pricing is
     standard Azure Plan pricing, Dev/Test pricing etc.

     Currently unavailable for Azure 3rd party and ReservedInstance meters.
    :vartype product_order_name: str
    :ivar service_family: Type of Azure service. For example, Compute, Analytics, and Security.
    :vartype service_family: float
    :ivar product: Name of the product accruing the charges.
    :vartype product: str
    :ivar product_id: Unique identifier for the product whose meter is consumed.
    :vartype product_id: str
    :ivar sku_id: Unique identifier of the SKU.
    :vartype sku_id: str
    :ivar unit_of_measure: How usage is measured for the service.
    :vartype unit_of_measure: str
    :ivar meter_id: Unique identifier of the meter.
    :vartype meter_id: str
    :ivar meter_name: Name of the meter. The meter represents the deployable resource of an Azure
     service.
    :vartype meter_name: str
    :ivar meter_type: Name of the meter type.
    :vartype meter_type: str
    :ivar meter_category: Name of the classification category for the meter. For example, Cloud
     services, Networking, etc.
    :vartype meter_category: str
    :ivar meter_sub_category: Name of the meter subclassification category.
    :vartype meter_sub_category: str
    :ivar meter_region: Name of the Azure region where the meter for the service is available.
    :vartype meter_region: str
    :ivar tier_minimum_units: Defines the lower bound of the tier range for which prices are
     defined. For example, if the range is 0 to 100, tierMinimumUnits would be 0.
    :vartype tier_minimum_units: str
    :ivar effective_start_date: Effective start date of the Price Sheet billing period.
    :vartype effective_start_date: ~datetime.datetime
    :ivar effective_end_date: Effective end date of the Price Sheet billing period.
    :vartype effective_end_date: ~datetime.datetime
    :ivar unit_price: The per-unit price at the time of billing for a given product or service,
     inclusive of any negotiated discounts on top of the market price.

     For PriceType ReservedInstance, unit price reflects the total cost of the 1 or 3-year
     commitment including discounts.

     Note: The unit price isn't the same as the effective price in usage details downloads when
     services have differential prices across tiers.

     If services have multi-tiered pricing, the effective price is a blended rate across the tiers
     and doesn't show a tier-specific unit price. The blended price or effective price is the net
     price for the consumed quantity spanning across the multiple tiers (where each tier has a
     specific unit price).
    :vartype unit_price: str
    :ivar base_price: The unit price at the time the customer signs on or the unit price at the
     time of service meter GA launch if it is after sign-on.

     This is applicable for Enterprise Agreement users.
    :vartype base_price: str
    :ivar market_price: The current list price for a given product or service. This price is
     without any negotiations and is based on your Microsoft Agreement type.

     For PriceType Consumption, market price is reflected as the pay-as-you-go price.

     For PriceType Savings Plan, market price reflects the Savings plan benefit on top of
     pay-as-you-go price for the corresponding commitment term.

     For PriceType ReservedInstance, market price reflects the total price of the 1 or 3-year
     commitment.
    :vartype market_price: str
    :ivar currency: Currency in which all the prices are reflected.
    :vartype currency: str
    :ivar billing_currency: Currency in which charges are posted.
    :vartype billing_currency: str
    :ivar term: Term length for Azure Savings Plan or Reservation term  one year or three years
     (P1Y or P3Y).
    :vartype term: str
    :ivar price_type: Price type for a product. For example, an Azure resource with a pay-as-you-go
     rate with priceType as Consumption. Other price types include ReservedInstance and Savings
     Plan.
    :vartype price_type: str
    """

    billing_account_id: Optional[str] = rest_field(name="billingAccountID", visibility=["read"])
    """Unique identifier for the billing account."""
    billing_account_name: Optional[str] = rest_field(name="billingAccountName", visibility=["read"])
    """Name of the billing profile that is set up to receive invoices. The prices in the price sheet
     are associated with this billing profile."""
    billing_profile_id: Optional[str] = rest_field(name="billingProfileId", visibility=["read"])
    """Unique identifier for the billing profile."""
    billing_profile_name: Optional[str] = rest_field(name="billingProfileName", visibility=["read"])
    """Name of the billing profile that is set up to receive invoices. The prices in the price sheet
     are associated with this billing profile."""
    product_order_name: Optional[str] = rest_field(name="productOrderName", visibility=["read"])
    """Name of the purchased product plan. Indicates if this pricing is standard Azure Plan pricing,
     Dev/Test pricing etc.
     
     Currently unavailable for Azure 3rd party and ReservedInstance meters."""
    service_family: Optional[float] = rest_field(name="serviceFamily", visibility=["read"])
    """Type of Azure service. For example, Compute, Analytics, and Security."""
    product: Optional[str] = rest_field(visibility=["read"])
    """Name of the product accruing the charges."""
    product_id: Optional[str] = rest_field(name="productId", visibility=["read"])
    """Unique identifier for the product whose meter is consumed."""
    sku_id: Optional[str] = rest_field(name="skuId", visibility=["read"])
    """Unique identifier of the SKU."""
    unit_of_measure: Optional[str] = rest_field(name="unitOfMeasure", visibility=["read"])
    """How usage is measured for the service."""
    meter_id: Optional[str] = rest_field(name="meterId", visibility=["read"])
    """Unique identifier of the meter."""
    meter_name: Optional[str] = rest_field(name="meterName", visibility=["read"])
    """Name of the meter. The meter represents the deployable resource of an Azure service."""
    meter_type: Optional[str] = rest_field(name="meterType", visibility=["read"])
    """Name of the meter type."""
    meter_category: Optional[str] = rest_field(name="meterCategory", visibility=["read"])
    """Name of the classification category for the meter. For example, Cloud services, Networking,
     etc."""
    meter_sub_category: Optional[str] = rest_field(name="meterSubCategory", visibility=["read"])
    """Name of the meter subclassification category."""
    meter_region: Optional[str] = rest_field(name="meterRegion", visibility=["read"])
    """Name of the Azure region where the meter for the service is available."""
    tier_minimum_units: Optional[str] = rest_field(name="tierMinimumUnits", visibility=["read"])
    """Defines the lower bound of the tier range for which prices are defined. For example, if the
     range is 0 to 100, tierMinimumUnits would be 0."""
    effective_start_date: Optional[datetime.datetime] = rest_field(
        name="effectiveStartDate", visibility=["read"], format="rfc3339"
    )
    """Effective start date of the Price Sheet billing period."""
    effective_end_date: Optional[datetime.datetime] = rest_field(
        name="effectiveEndDate", visibility=["read"], format="rfc3339"
    )
    """Effective end date of the Price Sheet billing period."""
    unit_price: Optional[str] = rest_field(name="unitPrice", visibility=["read"])
    """The per-unit price at the time of billing for a given product or service, inclusive of any
     negotiated discounts on top of the market price.
     
     For PriceType ReservedInstance, unit price reflects the total cost of the 1 or 3-year
     commitment including discounts.
     
     Note: The unit price isn't the same as the effective price in usage details downloads when
     services have differential prices across tiers.
     
     If services have multi-tiered pricing, the effective price is a blended rate across the tiers
     and doesn't show a tier-specific unit price. The blended price or effective price is the net
     price for the consumed quantity spanning across the multiple tiers (where each tier has a
     specific unit price)."""
    base_price: Optional[str] = rest_field(name="basePrice", visibility=["read"])
    """The unit price at the time the customer signs on or the unit price at the time of service meter
     GA launch if it is after sign-on.
     
     This is applicable for Enterprise Agreement users."""
    market_price: Optional[str] = rest_field(name="marketPrice", visibility=["read"])
    """The current list price for a given product or service. This price is without any negotiations
     and is based on your Microsoft Agreement type.
     
     For PriceType Consumption, market price is reflected as the pay-as-you-go price.
     
     For PriceType Savings Plan, market price reflects the Savings plan benefit on top of
     pay-as-you-go price for the corresponding commitment term.
     
     For PriceType ReservedInstance, market price reflects the total price of the 1 or 3-year
     commitment."""
    currency: Optional[str] = rest_field(visibility=["read"])
    """Currency in which all the prices are reflected."""
    billing_currency: Optional[str] = rest_field(name="billingCurrency", visibility=["read"])
    """Currency in which charges are posted."""
    term: Optional[str] = rest_field(visibility=["read"])
    """Term length for Azure Savings Plan or Reservation term  one year or three years (P1Y or P3Y)."""
    price_type: Optional[str] = rest_field(name="priceType", visibility=["read"])
    """Price type for a product. For example, an Azure resource with a pay-as-you-go rate with
     priceType as Consumption. Other price types include ReservedInstance and Savings Plan."""


class Notification(_Model):
    """The notification associated with a budget.

        Supported for CategoryType(s): Cost, ReservationUtilization.

        :ivar enabled: The notification is enabled or not.

         Supported for CategoryType(s): Cost, ReservationUtilization. Required.
        :vartype enabled: bool
        :ivar operator: The comparison operator.

    Supported for CategoryType(s): Cost, ReservationUtilization.

    Supported operators for **CategoryType: Cost**

         * GreaterThan
         * GreaterThanOrEqualTo

    Supported operators for **CategoryType: ReservationUtilization**

         * LessThan. Required. Known values are: "EqualTo", "GreaterThan", "GreaterThanOrEqualTo",
           and "LessThan".
        :vartype operator: str or ~azure.mgmt.costmanagement.models.BudgetNotificationOperatorType
        :ivar threshold: Threshold value associated with a notification. It is always percent with a
         maximum of 2 decimal places.

         Supported for CategoryType(s): Cost, ReservationUtilization.

         **CategoryType: Cost** - Must be between 0 and 1000. Notification is sent when the cost
         exceeded the threshold.

         **CategoryType: ReservationUtilization** - Must be between 0 and 100. Notification is sent when
         a reservation has a utilization percentage below the threshold. Required.
        :vartype threshold: float
        :ivar frequency: Frequency of a notification. Represents how long the notification will be
         silent after triggering an alert for a threshold breach. If not specified, the frequency will
         be set by default based on the timeGrain (Weekly when timeGrain: Last7Days, Monthly when
         timeGrain: Last30Days).

         Supported for CategoryType(s): ReservationUtilization. Known values are: "Daily", "Weekly", and
         "Monthly".
        :vartype frequency: str or ~azure.mgmt.costmanagement.models.Frequency
        :ivar contact_emails: Email addresses to send the notification to when the threshold is
         breached. Must have at least one contact email or contact group specified at the Subscription
         or Resource Group scopes. All other scopes must have at least one contact email specified.

         Supported for CategoryType(s): Cost, ReservationUtilization. Required.
        :vartype contact_emails: list[str]
        :ivar contact_roles: Subscription or Resource Group scopes only. Contact roles to send the
         notification to when the threshold is breached.

         Supported for CategoryType(s): Cost.
        :vartype contact_roles: list[str]
        :ivar contact_groups: Subscription or Resource Group scopes only. Action groups to send the
         notification to when the threshold is exceeded. Must be provided as a fully qualified Azure
         resource id.

         Supported for CategoryType(s): Cost.
        :vartype contact_groups: list[str]
        :ivar threshold_type: The type of threshold.

         Supported for CategoryType(s): Cost. Known values are: "Actual" and "Forecasted".
        :vartype threshold_type: str or ~azure.mgmt.costmanagement.models.ThresholdType
        :ivar locale: Language in which the recipient will receive the notification,

         Supported for CategoryType(s): Cost, ReservationUtilization. Known values are: "en-us",
         "ja-jp", "zh-cn", "de-de", "es-es", "fr-fr", "it-it", "ko-kr", "pt-br", "ru-ru", "zh-tw",
         "cs-cz", "pl-pl", "tr-tr", "da-dk", "en-gb", "hu-hu", "nb-no", "nl-nl", "pt-pt", and "sv-se".
        :vartype locale: str or ~azure.mgmt.costmanagement.models.CultureCode
    """

    enabled: bool = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The notification is enabled or not.
     
     Supported for CategoryType(s): Cost, ReservationUtilization. Required."""
    operator: Union[str, "_models.BudgetNotificationOperatorType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The comparison operator.
 
 Supported for CategoryType(s): Cost, ReservationUtilization.
 
 Supported operators for **CategoryType: Cost**
 
      * GreaterThan
      * GreaterThanOrEqualTo
 
 Supported operators for **CategoryType: ReservationUtilization**
 
      * LessThan. Required. Known values are: \"EqualTo\", \"GreaterThan\",
        \"GreaterThanOrEqualTo\", and \"LessThan\"."""
    threshold: float = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Threshold value associated with a notification. It is always percent with a maximum of 2
     decimal places.
     
     Supported for CategoryType(s): Cost, ReservationUtilization.
     
     **CategoryType: Cost** - Must be between 0 and 1000. Notification is sent when the cost
     exceeded the threshold.
     
     **CategoryType: ReservationUtilization** - Must be between 0 and 100. Notification is sent when
     a reservation has a utilization percentage below the threshold. Required."""
    frequency: Optional[Union[str, "_models.Frequency"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Frequency of a notification. Represents how long the notification will be silent after
     triggering an alert for a threshold breach. If not specified, the frequency will be set by
     default based on the timeGrain (Weekly when timeGrain: Last7Days, Monthly when timeGrain:
     Last30Days).
     
     Supported for CategoryType(s): ReservationUtilization. Known values are: \"Daily\", \"Weekly\",
     and \"Monthly\"."""
    contact_emails: list[str] = rest_field(
        name="contactEmails", visibility=["read", "create", "update", "delete", "query"]
    )
    """Email addresses to send the notification to when the threshold is breached. Must have at least
     one contact email or contact group specified at the Subscription or Resource Group scopes. All
     other scopes must have at least one contact email specified.
     
     Supported for CategoryType(s): Cost, ReservationUtilization. Required."""
    contact_roles: Optional[list[str]] = rest_field(
        name="contactRoles", visibility=["read", "create", "update", "delete", "query"]
    )
    """Subscription or Resource Group scopes only. Contact roles to send the notification to when the
     threshold is breached.
     
     Supported for CategoryType(s): Cost."""
    contact_groups: Optional[list[str]] = rest_field(
        name="contactGroups", visibility=["read", "create", "update", "delete", "query"]
    )
    """Subscription or Resource Group scopes only. Action groups to send the notification to when the
     threshold is exceeded. Must be provided as a fully qualified Azure resource id.
     
     Supported for CategoryType(s): Cost."""
    threshold_type: Optional[Union[str, "_models.ThresholdType"]] = rest_field(
        name="thresholdType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of threshold.
     
     Supported for CategoryType(s): Cost. Known values are: \"Actual\" and \"Forecasted\"."""
    locale: Optional[Union[str, "_models.CultureCode"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Language in which the recipient will receive the notification,
     
     Supported for CategoryType(s): Cost, ReservationUtilization. Known values are: \"en-us\",
     \"ja-jp\", \"zh-cn\", \"de-de\", \"es-es\", \"fr-fr\", \"it-it\", \"ko-kr\", \"pt-br\",
     \"ru-ru\", \"zh-tw\", \"cs-cz\", \"pl-pl\", \"tr-tr\", \"da-dk\", \"en-gb\", \"hu-hu\",
     \"nb-no\", \"nl-nl\", \"pt-pt\", and \"sv-se\"."""

    @overload
    def __init__(
        self,
        *,
        enabled: bool,
        operator: Union[str, "_models.BudgetNotificationOperatorType"],
        threshold: float,
        contact_emails: list[str],
        frequency: Optional[Union[str, "_models.Frequency"]] = None,
        contact_roles: Optional[list[str]] = None,
        contact_groups: Optional[list[str]] = None,
        threshold_type: Optional[Union[str, "_models.ThresholdType"]] = None,
        locale: Optional[Union[str, "_models.CultureCode"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NotificationProperties(_Model):
    """The properties of the scheduled action notification.

    :ivar to: Array of email addresses. Required.
    :vartype to: list[str]
    :ivar language: Locale of the email.
    :vartype language: str
    :ivar message: Optional message to be added in the email. Length is limited to 250 characters.
    :vartype message: str
    :ivar regional_format: Regional format used for formatting date/time and currency values in the
     email.
    :vartype regional_format: str
    :ivar subject: Subject of the email. Length is limited to 70 characters. Required.
    :vartype subject: str
    """

    to: list[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of email addresses. Required."""
    language: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Locale of the email."""
    message: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Optional message to be added in the email. Length is limited to 250 characters."""
    regional_format: Optional[str] = rest_field(
        name="regionalFormat", visibility=["read", "create", "update", "delete", "query"]
    )
    """Regional format used for formatting date/time and currency values in the email."""
    subject: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Subject of the email. Length is limited to 70 characters. Required."""

    @overload
    def __init__(
        self,
        *,
        to: list[str],
        subject: str,
        language: Optional[str] = None,
        message: Optional[str] = None,
        regional_format: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OperationDisplay(_Model):
    """Localized display information for and operation.

    :ivar provider: The localized friendly form of the resource provider name, e.g. "Microsoft
     Monitoring Insights" or "Microsoft Compute".
    :vartype provider: str
    :ivar resource: The localized friendly name of the resource type related to this operation.
     E.g. "Virtual Machines" or "Job Schedule Collections".
    :vartype resource: str
    :ivar operation: The concise, localized friendly name for the operation; suitable for
     dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
    :vartype operation: str
    :ivar description: The short, localized friendly description of the operation; suitable for
     tool tips and detailed views.
    :vartype description: str
    """

    provider: Optional[str] = rest_field(visibility=["read"])
    """The localized friendly form of the resource provider name, e.g. \"Microsoft Monitoring
     Insights\" or \"Microsoft Compute\"."""
    resource: Optional[str] = rest_field(visibility=["read"])
    """The localized friendly name of the resource type related to this operation. E.g. \"Virtual
     Machines\" or \"Job Schedule Collections\"."""
    operation: Optional[str] = rest_field(visibility=["read"])
    """The concise, localized friendly name for the operation; suitable for dropdowns. E.g. \"Create
     or Update Virtual Machine\", \"Restart Virtual Machine\"."""
    description: Optional[str] = rest_field(visibility=["read"])
    """The short, localized friendly description of the operation; suitable for tool tips and detailed
     views."""


class OperationStatus(_Model):
    """The status of the long running operation.

    :ivar status: The status of the long running operation. Known values are: "Running",
     "Completed", and "Failed".
    :vartype status: str or ~azure.mgmt.costmanagement.models.OperationStatusType
    :ivar properties: The properties of the resource generated.
    :vartype properties: ~azure.mgmt.costmanagement.models.ReportURL
    """

    status: Optional[Union[str, "_models.OperationStatusType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The status of the long running operation. Known values are: \"Running\", \"Completed\", and
     \"Failed\"."""
    properties: Optional["_models.ReportURL"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The properties of the resource generated."""

    __flattened_items = ["report_url", "valid_until"]

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.OperationStatusType"]] = None,
        properties: Optional["_models.ReportURL"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class PivotProperties(_Model):
    """Each pivot must contain a 'type' and 'name'.

    :ivar type: Data type to show in view. Known values are: "Dimension" and "TagKey".
    :vartype type: str or ~azure.mgmt.costmanagement.models.PivotTypeType
    :ivar name: Data field to show in view.
    :vartype name: str
    """

    type: Optional[Union[str, "_models.PivotTypeType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Data type to show in view. Known values are: \"Dimension\" and \"TagKey\"."""
    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Data field to show in view."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.PivotTypeType"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PricesheetDownloadProperties(_Model):
    """The URL to download the generated report.

    :ivar expiry_time: The time at which report URL becomes invalid/expires in UTC e.g.
     2020-12-08T05:55:59.4394737Z.
    :vartype expiry_time: ~datetime.datetime
    :ivar download_url: The URL to download the generated report.
    :vartype download_url: str
    :ivar download_file_properties: The properties in downloaded file.
    :vartype download_file_properties: ~azure.mgmt.costmanagement.models.MCAPriceSheetProperties
    """

    expiry_time: Optional[datetime.datetime] = rest_field(name="expiryTime", visibility=["read"], format="rfc3339")
    """The time at which report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z."""
    download_url: Optional[str] = rest_field(
        name="downloadUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """The URL to download the generated report."""
    download_file_properties: Optional["_models.MCAPriceSheetProperties"] = rest_field(
        name="downloadFileProperties", visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties in downloaded file."""

    @overload
    def __init__(
        self,
        *,
        download_url: Optional[str] = None,
        download_file_properties: Optional["_models.MCAPriceSheetProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryAggregation(_Model):
    """The aggregation expression to be used in the query.

    :ivar name: The name of the column to aggregate. Required.
    :vartype name: str
    :ivar function: The name of the aggregation function to use. Required. "Sum"
    :vartype function: str or ~azure.mgmt.costmanagement.models.FunctionType
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to aggregate. Required."""
    function: Union[str, "_models.FunctionType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the aggregation function to use. Required. \"Sum\""""

    @overload
    def __init__(
        self,
        *,
        name: str,
        function: Union[str, "_models.FunctionType"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryColumn(_Model):
    """QueryColumn properties.

    :ivar name: The name of column.
    :vartype name: str
    :ivar type: The type of column.
    :vartype type: str
    """

    name: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of column."""
    type: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The type of column."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryComparisonExpression(_Model):
    """The comparison expression to be used in the query.

    :ivar name: The name of the column to use in comparison. Required.
    :vartype name: str
    :ivar operator: The operator to use for comparison. Required. "In"
    :vartype operator: str or ~azure.mgmt.costmanagement.models.QueryOperatorType
    :ivar values_property: Array of values to use for comparison. Required.
    :vartype values_property: list[str]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to use in comparison. Required."""
    operator: Union[str, "_models.QueryOperatorType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The operator to use for comparison. Required. \"In\""""
    values_property: list[str] = rest_field(name="values", visibility=["read", "create", "update", "delete", "query"])
    """Array of values to use for comparison. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        operator: Union[str, "_models.QueryOperatorType"],
        values_property: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryDataset(_Model):
    """The definition of data present in the query.

    :ivar granularity: The granularity of rows in the query. Known values are: "Daily" and
     "Monthly".
    :vartype granularity: str or ~azure.mgmt.costmanagement.models.GranularityType
    :ivar configuration: Has configuration information for the data in the export. The
     configuration will be ignored if aggregation and grouping are provided.
    :vartype configuration: ~azure.mgmt.costmanagement.models.QueryDatasetConfiguration
    :ivar aggregation: Dictionary of aggregation expression to use in the query. The key of each
     item in the dictionary is the alias for the aggregated column. Query can have up to 2
     aggregation clauses.
    :vartype aggregation: dict[str, ~azure.mgmt.costmanagement.models.QueryAggregation]
    :ivar grouping: Array of group by expression to use in the query. Query can have up to 2 group
     by clauses.
    :vartype grouping: list[~azure.mgmt.costmanagement.models.QueryGrouping]
    :ivar filter: The filter expression to use in the query. Please reference our Query API REST
     documentation for how to properly format the filter.
    :vartype filter: ~azure.mgmt.costmanagement.models.QueryFilter
    """

    granularity: Optional[Union[str, "_models.GranularityType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The granularity of rows in the query. Known values are: \"Daily\" and \"Monthly\"."""
    configuration: Optional["_models.QueryDatasetConfiguration"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has configuration information for the data in the export. The configuration will be ignored if
     aggregation and grouping are provided."""
    aggregation: Optional[dict[str, "_models.QueryAggregation"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Dictionary of aggregation expression to use in the query. The key of each item in the
     dictionary is the alias for the aggregated column. Query can have up to 2 aggregation clauses."""
    grouping: Optional[list["_models.QueryGrouping"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Array of group by expression to use in the query. Query can have up to 2 group by clauses."""
    filter: Optional["_models.QueryFilter"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The filter expression to use in the query. Please reference our Query API REST documentation
     for how to properly format the filter."""

    @overload
    def __init__(
        self,
        *,
        granularity: Optional[Union[str, "_models.GranularityType"]] = None,
        configuration: Optional["_models.QueryDatasetConfiguration"] = None,
        aggregation: Optional[dict[str, "_models.QueryAggregation"]] = None,
        grouping: Optional[list["_models.QueryGrouping"]] = None,
        filter: Optional["_models.QueryFilter"] = None,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryDatasetConfiguration(_Model):
    """The configuration of dataset in the query.

    :ivar columns: Array of column names to be included in the query. Any valid query column name
     is allowed. If not provided, then query includes all columns.
    :vartype columns: list[str]
    """

    columns: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of column names to be included in the query. Any valid query column name is allowed. If
     not provided, then query includes all columns."""

    @overload
    def __init__(
        self,
        *,
        columns: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryDefinition(_Model):
    """The definition of a query.

    :ivar type: The type of the query. Required. Known values are: "Usage", "ActualCost",
     "AmortizedCost", "FocusCost", "PriceSheet", "ReservationTransactions",
     "ReservationRecommendations", and "ReservationDetails".
    :vartype type: str or ~azure.mgmt.costmanagement.models.ExportType
    :ivar timeframe: The time frame for pulling data for the query. If custom, then a specific time
     period must be provided. Required. Known values are: "MonthToDate", "BillingMonthToDate",
     "TheLastMonth", "TheLastBillingMonth", "WeekToDate", "Custom", and "TheCurrentMonth".
    :vartype timeframe: str or ~azure.mgmt.costmanagement.models.TimeframeType
    :ivar time_period: Has time period for pulling data for the query.
    :vartype time_period: ~azure.mgmt.costmanagement.models.QueryTimePeriod
    :ivar dataset: Has definition for data in this query. Required.
    :vartype dataset: ~azure.mgmt.costmanagement.models.QueryDataset
    """

    type: Union[str, "_models.ExportType"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The type of the query. Required. Known values are: \"Usage\", \"ActualCost\",
     \"AmortizedCost\", \"FocusCost\", \"PriceSheet\", \"ReservationTransactions\",
     \"ReservationRecommendations\", and \"ReservationDetails\"."""
    timeframe: Union[str, "_models.TimeframeType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The time frame for pulling data for the query. If custom, then a specific time period must be
     provided. Required. Known values are: \"MonthToDate\", \"BillingMonthToDate\",
     \"TheLastMonth\", \"TheLastBillingMonth\", \"WeekToDate\", \"Custom\", and \"TheCurrentMonth\"."""
    time_period: Optional["_models.QueryTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has time period for pulling data for the query."""
    dataset: "_models.QueryDataset" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Has definition for data in this query. Required."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ExportType"],
        timeframe: Union[str, "_models.TimeframeType"],
        dataset: "_models.QueryDataset",
        time_period: Optional["_models.QueryTimePeriod"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryFilter(_Model):
    """The filter expression to be used in the export.

    :ivar and_property: The logical "AND" expression. Must have at least 2 items.
    :vartype and_property: list[~azure.mgmt.costmanagement.models.QueryFilter]
    :ivar or_property: The logical "OR" expression. Must have at least 2 items.
    :vartype or_property: list[~azure.mgmt.costmanagement.models.QueryFilter]
    :ivar dimensions: Has comparison expression for a dimension.
    :vartype dimensions: ~azure.mgmt.costmanagement.models.QueryComparisonExpression
    :ivar tags: Has comparison expression for a tag.
    :vartype tags: ~azure.mgmt.costmanagement.models.QueryComparisonExpression
    """

    and_property: Optional[list["_models.QueryFilter"]] = rest_field(
        name="and", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"AND\" expression. Must have at least 2 items."""
    or_property: Optional[list["_models.QueryFilter"]] = rest_field(
        name="or", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"OR\" expression. Must have at least 2 items."""
    dimensions: Optional["_models.QueryComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a dimension."""
    tags: Optional["_models.QueryComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a tag."""

    @overload
    def __init__(
        self,
        *,
        and_property: Optional[list["_models.QueryFilter"]] = None,
        or_property: Optional[list["_models.QueryFilter"]] = None,
        dimensions: Optional["_models.QueryComparisonExpression"] = None,
        tags: Optional["_models.QueryComparisonExpression"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryGrouping(_Model):
    """The group by expression to be used in the query.

    :ivar type: Has type of the column to group. Required. Known values are: "TagKey" and
     "Dimension".
    :vartype type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
    :ivar name: The name of the column to group. Required.
    :vartype name: str
    """

    type: Union[str, "_models.QueryColumnType"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Has type of the column to group. Required. Known values are: \"TagKey\" and \"Dimension\"."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to group. Required."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.QueryColumnType"],
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryProperties(_Model):
    """Query properties.

    :ivar next_link: The link (url) to the next page of results.
    :vartype next_link: str
    :ivar columns: Array of columns.
    :vartype columns: list[~azure.mgmt.costmanagement.models.QueryColumn]
    :ivar rows: Array of rows.
    :vartype rows: list[list[any]]
    """

    next_link: Optional[str] = rest_field(name="nextLink", visibility=["read", "create", "update", "delete", "query"])
    """The link (url) to the next page of results."""
    columns: Optional[list["_models.QueryColumn"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Array of columns."""
    rows: Optional[list[list[Any]]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of rows."""

    @overload
    def __init__(
        self,
        *,
        next_link: Optional[str] = None,
        columns: Optional[list["_models.QueryColumn"]] = None,
        rows: Optional[list[list[Any]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QueryResult(CostManagementResource):
    """Result of query. It contains all columns listed under groupings and aggregation.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar location: Location of the resource.
    :vartype location: str
    :ivar sku: SKU of the resource.
    :vartype sku: str
    :ivar e_tag: ETag of the resource.
    :vartype e_tag: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar properties: Query properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.QueryProperties
    """

    properties: Optional["_models.QueryProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Query properties."""

    __flattened_items = ["next_link", "columns", "rows"]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.QueryProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class QueryTimePeriod(_Model):
    """The start and end date for pulling data for the query.

    :ivar from_property: The start date to pull data from. Required.
    :vartype from_property: ~datetime.datetime
    :ivar to: The end date to pull data to. Required.
    :vartype to: ~datetime.datetime
    """

    from_property: datetime.datetime = rest_field(
        name="from", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date to pull data from. Required."""
    to: datetime.datetime = rest_field(visibility=["read", "create", "update", "delete", "query"], format="rfc3339")
    """The end date to pull data to. Required."""

    @overload
    def __init__(
        self,
        *,
        from_property: datetime.datetime,
        to: datetime.datetime,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RecommendationUsageDetails(_Model):
    """On-demand charges between firstConsumptionDate and lastConsumptionDate that were used for
    computing benefit recommendations.

    :ivar usage_grain: The grain of the usage. Supported values: 'Hourly'. Known values are:
     "Hourly", "Daily", and "Monthly".
    :vartype usage_grain: str or ~azure.mgmt.costmanagement.models.Grain
    :ivar charges: On-demand charges for each hour between firstConsumptionDate and
     lastConsumptionDate that were used for computing benefit recommendations.
    :vartype charges: list[~decimal.Decimal]
    """

    usage_grain: Optional[Union[str, "_models.Grain"]] = rest_field(
        name="usageGrain", visibility=["read", "create", "update", "delete", "query"]
    )
    """The grain of the usage. Supported values: 'Hourly'. Known values are: \"Hourly\", \"Daily\",
     and \"Monthly\"."""
    charges: Optional[list[decimal.Decimal]] = rest_field(visibility=["read"])
    """On-demand charges for each hour between firstConsumptionDate and lastConsumptionDate that were
     used for computing benefit recommendations."""

    @overload
    def __init__(
        self,
        *,
        usage_grain: Optional[Union[str, "_models.Grain"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigAggregation(_Model):
    """The aggregation expression to be used in the report.

    :ivar name: The name of the column to aggregate. Required.
    :vartype name: str
    :ivar function: The name of the aggregation function to use. Required. "Sum"
    :vartype function: str or ~azure.mgmt.costmanagement.models.FunctionType
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to aggregate. Required."""
    function: Union[str, "_models.FunctionType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The name of the aggregation function to use. Required. \"Sum\""""

    @overload
    def __init__(
        self,
        *,
        name: str,
        function: Union[str, "_models.FunctionType"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigComparisonExpression(_Model):
    """The comparison expression to be used in the report.

    :ivar name: The name of the column to use in comparison. Required.
    :vartype name: str
    :ivar operator: The operator to use for comparison. Required. Known values are: "In" and
     "Contains".
    :vartype operator: str or ~azure.mgmt.costmanagement.models.OperatorType
    :ivar values_property: Array of values to use for comparison. Required.
    :vartype values_property: list[str]
    """

    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to use in comparison. Required."""
    operator: Union[str, "_models.OperatorType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The operator to use for comparison. Required. Known values are: \"In\" and \"Contains\"."""
    values_property: list[str] = rest_field(name="values", visibility=["read", "create", "update", "delete", "query"])
    """Array of values to use for comparison. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        operator: Union[str, "_models.OperatorType"],
        values_property: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigDataset(_Model):
    """The definition of data present in the report.

    :ivar granularity: The granularity of rows in the report. Known values are: "Daily" and
     "Monthly".
    :vartype granularity: str or ~azure.mgmt.costmanagement.models.ReportGranularityType
    :ivar configuration: Has configuration information for the data in the report. The
     configuration will be ignored if aggregation and grouping are provided.
    :vartype configuration: ~azure.mgmt.costmanagement.models.ReportConfigDatasetConfiguration
    :ivar aggregation: Dictionary of aggregation expression to use in the report. The key of each
     item in the dictionary is the alias for the aggregated column. Report can have up to 2
     aggregation clauses.
    :vartype aggregation: dict[str, ~azure.mgmt.costmanagement.models.ReportConfigAggregation]
    :ivar grouping: Array of group by expression to use in the report. Report can have up to 2
     group by clauses.
    :vartype grouping: list[~azure.mgmt.costmanagement.models.ReportConfigGrouping]
    :ivar sorting: Array of order by expression to use in the report.
    :vartype sorting: list[~azure.mgmt.costmanagement.models.ReportConfigSorting]
    :ivar filter: Has filter expression to use in the report.
    :vartype filter: ~azure.mgmt.costmanagement.models.ReportConfigFilter
    """

    granularity: Optional[Union[str, "_models.ReportGranularityType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The granularity of rows in the report. Known values are: \"Daily\" and \"Monthly\"."""
    configuration: Optional["_models.ReportConfigDatasetConfiguration"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has configuration information for the data in the report. The configuration will be ignored if
     aggregation and grouping are provided."""
    aggregation: Optional[dict[str, "_models.ReportConfigAggregation"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Dictionary of aggregation expression to use in the report. The key of each item in the
     dictionary is the alias for the aggregated column. Report can have up to 2 aggregation clauses."""
    grouping: Optional[list["_models.ReportConfigGrouping"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Array of group by expression to use in the report. Report can have up to 2 group by clauses."""
    sorting: Optional[list["_models.ReportConfigSorting"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Array of order by expression to use in the report."""
    filter: Optional["_models.ReportConfigFilter"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has filter expression to use in the report."""

    @overload
    def __init__(
        self,
        *,
        granularity: Optional[Union[str, "_models.ReportGranularityType"]] = None,
        configuration: Optional["_models.ReportConfigDatasetConfiguration"] = None,
        aggregation: Optional[dict[str, "_models.ReportConfigAggregation"]] = None,
        grouping: Optional[list["_models.ReportConfigGrouping"]] = None,
        sorting: Optional[list["_models.ReportConfigSorting"]] = None,
        filter: Optional["_models.ReportConfigFilter"] = None,  # pylint: disable=redefined-builtin
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigDatasetConfiguration(_Model):
    """The configuration of dataset in the report.

    :ivar columns: Array of column names to be included in the report. Any valid report column name
     is allowed. If not provided, then report includes all columns.
    :vartype columns: list[str]
    """

    columns: Optional[list[str]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Array of column names to be included in the report. Any valid report column name is allowed. If
     not provided, then report includes all columns."""

    @overload
    def __init__(
        self,
        *,
        columns: Optional[list[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigDefinition(_Model):
    """The definition of a report config.

    :ivar type: The type of the report. Usage represents actual usage, forecast represents
     forecasted data and UsageAndForecast represents both usage and forecasted data. Actual usage
     and forecasted data can be differentiated based on dates. Required. "Usage"
    :vartype type: str or ~azure.mgmt.costmanagement.models.ReportType
    :ivar timeframe: The time frame for pulling data for the report. If custom, then a specific
     time period must be provided. Required. Known values are: "WeekToDate", "MonthToDate",
     "YearToDate", and "Custom".
    :vartype timeframe: str or ~azure.mgmt.costmanagement.models.ReportTimeframeType
    :ivar time_period: Has time period for pulling data for the report.
    :vartype time_period: ~azure.mgmt.costmanagement.models.ReportConfigTimePeriod
    :ivar data_set: Has definition for data in this report config.
    :vartype data_set: ~azure.mgmt.costmanagement.models.ReportConfigDataset
    :ivar include_monetary_commitment: If true, report includes monetary commitment.
    :vartype include_monetary_commitment: bool
    """

    type: Union[str, "_models.ReportType"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The type of the report. Usage represents actual usage, forecast represents forecasted data and
     UsageAndForecast represents both usage and forecasted data. Actual usage and forecasted data
     can be differentiated based on dates. Required. \"Usage\""""
    timeframe: Union[str, "_models.ReportTimeframeType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The time frame for pulling data for the report. If custom, then a specific time period must be
     provided. Required. Known values are: \"WeekToDate\", \"MonthToDate\", \"YearToDate\", and
     \"Custom\"."""
    time_period: Optional["_models.ReportConfigTimePeriod"] = rest_field(
        name="timePeriod", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has time period for pulling data for the report."""
    data_set: Optional["_models.ReportConfigDataset"] = rest_field(
        name="dataSet", visibility=["read", "create", "update", "delete", "query"]
    )
    """Has definition for data in this report config."""
    include_monetary_commitment: Optional[bool] = rest_field(
        name="includeMonetaryCommitment", visibility=["read", "create", "update", "delete", "query"]
    )
    """If true, report includes monetary commitment."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.ReportType"],
        timeframe: Union[str, "_models.ReportTimeframeType"],
        time_period: Optional["_models.ReportConfigTimePeriod"] = None,
        data_set: Optional["_models.ReportConfigDataset"] = None,
        include_monetary_commitment: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigFilter(_Model):
    """The filter expression to be used in the report.

    :ivar and_property: The logical "AND" expression. Must have at least 2 items.
    :vartype and_property: list[~azure.mgmt.costmanagement.models.ReportConfigFilter]
    :ivar or_property: The logical "OR" expression. Must have at least 2 items.
    :vartype or_property: list[~azure.mgmt.costmanagement.models.ReportConfigFilter]
    :ivar dimensions: Has comparison expression for a dimension.
    :vartype dimensions: ~azure.mgmt.costmanagement.models.ReportConfigComparisonExpression
    :ivar tags: Has comparison expression for a tag.
    :vartype tags: ~azure.mgmt.costmanagement.models.ReportConfigComparisonExpression
    """

    and_property: Optional[list["_models.ReportConfigFilter"]] = rest_field(
        name="and", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"AND\" expression. Must have at least 2 items."""
    or_property: Optional[list["_models.ReportConfigFilter"]] = rest_field(
        name="or", visibility=["read", "create", "update", "delete", "query"]
    )
    """The logical \"OR\" expression. Must have at least 2 items."""
    dimensions: Optional["_models.ReportConfigComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a dimension."""
    tags: Optional["_models.ReportConfigComparisonExpression"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Has comparison expression for a tag."""

    @overload
    def __init__(
        self,
        *,
        and_property: Optional[list["_models.ReportConfigFilter"]] = None,
        or_property: Optional[list["_models.ReportConfigFilter"]] = None,
        dimensions: Optional["_models.ReportConfigComparisonExpression"] = None,
        tags: Optional["_models.ReportConfigComparisonExpression"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigGrouping(_Model):
    """The group by expression to be used in the report.

    :ivar type: Has type of the column to group. Required. Known values are: "TagKey" and
     "Dimension".
    :vartype type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
    :ivar name: The name of the column to group. This version supports subscription lowest possible
     grain. Required.
    :vartype name: str
    """

    type: Union[str, "_models.QueryColumnType"] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Has type of the column to group. Required. Known values are: \"TagKey\" and \"Dimension\"."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to group. This version supports subscription lowest possible grain.
     Required."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.QueryColumnType"],
        name: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigSorting(_Model):
    """The order by expression to be used in the report.

    :ivar direction: Direction of sort. Known values are: "Ascending" and "Descending".
    :vartype direction: str or ~azure.mgmt.costmanagement.models.ReportConfigSortingType
    :ivar name: The name of the column to sort. Required.
    :vartype name: str
    """

    direction: Optional[Union[str, "_models.ReportConfigSortingType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Direction of sort. Known values are: \"Ascending\" and \"Descending\"."""
    name: str = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """The name of the column to sort. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        direction: Optional[Union[str, "_models.ReportConfigSortingType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportConfigTimePeriod(_Model):
    """The start and end date for pulling data for the report.

    :ivar from_property: The start date to pull data from. Required.
    :vartype from_property: ~datetime.datetime
    :ivar to: The end date to pull data to. Required.
    :vartype to: ~datetime.datetime
    """

    from_property: datetime.datetime = rest_field(
        name="from", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date to pull data from. Required."""
    to: datetime.datetime = rest_field(visibility=["read", "create", "update", "delete", "query"], format="rfc3339")
    """The end date to pull data to. Required."""

    @overload
    def __init__(
        self,
        *,
        from_property: datetime.datetime,
        to: datetime.datetime,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReportManifest(_Model):
    """The manifest of the report generated by the operation.

    :ivar manifest_version: The Manifest version.
    :vartype manifest_version: str
    :ivar data_format: The data format of the report. "Csv"
    :vartype data_format: str or ~azure.mgmt.costmanagement.models.CostDetailsDataFormat
    :ivar byte_count: The total number of bytes in all blobs.
    :vartype byte_count: int
    :ivar blob_count: The total number of blobs.
    :vartype blob_count: int
    :ivar compress_data: Is the data in compressed format.
    :vartype compress_data: bool
    :ivar request_context: The context of the Cost Details request.
    :vartype request_context: ~azure.mgmt.costmanagement.models.RequestContext
    :ivar blobs: List of blob information generated by this operation.
    :vartype blobs: list[~azure.mgmt.costmanagement.models.BlobInfo]
    """

    manifest_version: Optional[str] = rest_field(
        name="manifestVersion", visibility=["read", "create", "update", "delete", "query"]
    )
    """The Manifest version."""
    data_format: Optional[Union[str, "_models.CostDetailsDataFormat"]] = rest_field(
        name="dataFormat", visibility=["read", "create", "update", "delete", "query"]
    )
    """The data format of the report. \"Csv\""""
    byte_count: Optional[int] = rest_field(name="byteCount", visibility=["read", "create", "update", "delete", "query"])
    """The total number of bytes in all blobs."""
    blob_count: Optional[int] = rest_field(name="blobCount", visibility=["read", "create", "update", "delete", "query"])
    """The total number of blobs."""
    compress_data: Optional[bool] = rest_field(
        name="compressData", visibility=["read", "create", "update", "delete", "query"]
    )
    """Is the data in compressed format."""
    request_context: Optional["_models.RequestContext"] = rest_field(
        name="requestContext", visibility=["read", "create", "update", "delete", "query"]
    )
    """The context of the Cost Details request."""
    blobs: Optional[list["_models.BlobInfo"]] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """List of blob information generated by this operation."""

    __flattened_items = ["request_scope", "request_body"]

    @overload
    def __init__(
        self,
        *,
        manifest_version: Optional[str] = None,
        data_format: Optional[Union[str, "_models.CostDetailsDataFormat"]] = None,
        byte_count: Optional[int] = None,
        blob_count: Optional[int] = None,
        compress_data: Optional[bool] = None,
        request_context: Optional["_models.RequestContext"] = None,
        blobs: Optional[list["_models.BlobInfo"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.request_context is None:
                return None
            return getattr(self.request_context, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.request_context is None:
                self.request_context = self._attr_to_rest_field["request_context"]._class_type()
            setattr(self.request_context, key, value)
        else:
            super().__setattr__(key, value)


class ReportURL(_Model):
    """The URL to download the generated report.

    :ivar report_url: The CSV file from the reportUrl blob link consists of reservation usage data
     with the following schema at daily granularity. Known values are: "InstanceFlexibilityGroup",
     "InstanceFlexibilityRatio", "InstanceId", "Kind", "ReservationId", "ReservationOrderId",
     "ReservedHours", "SkuName", "TotalReservedQuantity", "UsageDate", and "UsedHours".
    :vartype report_url: str or ~azure.mgmt.costmanagement.models.ReservationReportSchema
    :ivar valid_until: The time at which report URL becomes invalid.
    :vartype valid_until: ~datetime.datetime
    """

    report_url: Optional[Union[str, "_models.ReservationReportSchema"]] = rest_field(
        name="reportUrl", visibility=["read", "create", "update", "delete", "query"]
    )
    """The CSV file from the reportUrl blob link consists of reservation usage data with the following
     schema at daily granularity. Known values are: \"InstanceFlexibilityGroup\",
     \"InstanceFlexibilityRatio\", \"InstanceId\", \"Kind\", \"ReservationId\",
     \"ReservationOrderId\", \"ReservedHours\", \"SkuName\", \"TotalReservedQuantity\",
     \"UsageDate\", and \"UsedHours\"."""
    valid_until: Optional[datetime.datetime] = rest_field(
        name="validUntil", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The time at which report URL becomes invalid."""

    @overload
    def __init__(
        self,
        *,
        report_url: Optional[Union[str, "_models.ReservationReportSchema"]] = None,
        valid_until: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequestContext(_Model):
    """The context of the Cost Details request.

    :ivar request_scope: The request scope of the request.
    :vartype request_scope: str
    :ivar request_body: The request payload body provided in Cost Details call.
    :vartype request_body:
     ~azure.mgmt.costmanagement.models.GenerateCostDetailsReportRequestDefinition
    """

    request_scope: Optional[str] = rest_field(
        name="requestScope", visibility=["read", "create", "update", "delete", "query"]
    )
    """The request scope of the request."""
    request_body: Optional["_models.GenerateCostDetailsReportRequestDefinition"] = rest_field(
        name="requestBody", visibility=["read", "create", "update", "delete", "query"]
    )
    """The request payload body provided in Cost Details call."""

    @overload
    def __init__(
        self,
        *,
        request_scope: Optional[str] = None,
        request_body: Optional["_models.GenerateCostDetailsReportRequestDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SavingsPlanUtilizationSummary(BenefitUtilizationSummary, discriminator="SavingsPlan"):
    """Savings plan utilization summary resource.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: Savings plan utilization summary properties.
    :vartype properties: ~azure.mgmt.costmanagement.models.SavingsPlanUtilizationSummaryProperties
    :ivar kind: Supported values: 'SavingsPlan'. Required. Benefit is SavingsPlan.
    :vartype kind: str or ~azure.mgmt.costmanagement.models.SAVINGS_PLAN
    """

    properties: Optional["_models.SavingsPlanUtilizationSummaryProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Savings plan utilization summary properties."""
    kind: Literal[BenefitKind.SAVINGS_PLAN] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Supported values: 'SavingsPlan'. Required. Benefit is SavingsPlan."""

    __flattened_items = [
        "arm_sku_name",
        "benefit_id",
        "benefit_order_id",
        "benefit_type",
        "usage_date",
        "avg_utilization_percentage",
        "min_utilization_percentage",
        "max_utilization_percentage",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.SavingsPlanUtilizationSummaryProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class SavingsPlanUtilizationSummaryProperties(BenefitUtilizationSummaryProperties):
    """Savings plan utilization summary properties.

    :ivar arm_sku_name: ARM SKU name. For example, 'Compute_Savings_Plan' for savings plan.
    :vartype arm_sku_name: str
    :ivar benefit_id: The benefit ID is the identifier of the benefit.
    :vartype benefit_id: str
    :ivar benefit_order_id: The benefit order ID is the identifier for a benefit purchase.
    :vartype benefit_order_id: str
    :ivar benefit_type: The benefit type. Supported values: 'SavingsPlan'. Known values are:
     "IncludedQuantity", "Reservation", and "SavingsPlan".
    :vartype benefit_type: str or ~azure.mgmt.costmanagement.models.BenefitKind
    :ivar usage_date: Date corresponding to the utilization summary record. If the grain of data is
     monthly, value for this field will be first day of the month.
    :vartype usage_date: ~datetime.datetime
    :ivar avg_utilization_percentage: This is the average hourly utilization for each date range
     that corresponds to given grain (Daily, Monthly). Suppose the API call is for usageDate >
     2025-03-01 and usageDate < 2022-10-31 at a daily granularity. There will be one record per
     benefit id for each day. For a single day, the avgUtilizationPercentage value will be equal to
     the average of the set of values where the set contains 24 utilization percentage entries one
     for each hour in a specific day.
    :vartype avg_utilization_percentage: ~decimal.Decimal
    :ivar min_utilization_percentage: This is the minimum hourly utilization for each date range
     that corresponds to given grain (Daily, Monthly). Suppose the API call is for usageDate >
     2025-03-01 and usageDate < 2022-10-31 at a daily granularity. There will be one record per
     benefit id for each day. For a single day, the minUtilizationPercentage value will be equal to
     the smallest in the set of values where the set contains 24 utilization percentage entries one
     for each hour in a specific day. If on the day 2022-10-18, the lowest utilization percentage
     was 10% at hour 4, then the value for the minUtilizationPercentage in the response will be 10%.
    :vartype min_utilization_percentage: ~decimal.Decimal
    :ivar max_utilization_percentage: This is the maximum hourly utilization for each date range
     that corresponds to given grain (Daily, Monthly). Suppose the API call is for usageDate >
     2025-03-01 and usageDate < 2022-10-31 at a daily granularity. There will be one record per
     benefit id for each day. For a single day, the maxUtilizationPercentage value will be equal to
     the largest in the set of values where the set contains 24 utilization percentage entries one
     for each hour in a specific day. If on the day 2022-10-18, the largest utilization percentage
     was 90% at hour 5, then the value for the maxUtilizationPercentage in the response will be 90%.
    :vartype max_utilization_percentage: ~decimal.Decimal
    """

    avg_utilization_percentage: Optional[decimal.Decimal] = rest_field(
        name="avgUtilizationPercentage", visibility=["read"]
    )
    """This is the average hourly utilization for each date range that corresponds to given grain
     (Daily, Monthly). Suppose the API call is for usageDate > 2025-03-01 and usageDate < 2022-10-31
     at a daily granularity. There will be one record per benefit id for each day. For a single day,
     the avgUtilizationPercentage value will be equal to the average of the set of values where the
     set contains 24 utilization percentage entries one for each hour in a specific day."""
    min_utilization_percentage: Optional[decimal.Decimal] = rest_field(
        name="minUtilizationPercentage", visibility=["read"]
    )
    """This is the minimum hourly utilization for each date range that corresponds to given grain
     (Daily, Monthly). Suppose the API call is for usageDate > 2025-03-01 and usageDate < 2022-10-31
     at a daily granularity. There will be one record per benefit id for each day. For a single day,
     the minUtilizationPercentage value will be equal to the smallest in the set of values where the
     set contains 24 utilization percentage entries one for each hour in a specific day. If on the
     day 2022-10-18, the lowest utilization percentage was 10% at hour 4, then the value for the
     minUtilizationPercentage in the response will be 10%."""
    max_utilization_percentage: Optional[decimal.Decimal] = rest_field(
        name="maxUtilizationPercentage", visibility=["read"]
    )
    """This is the maximum hourly utilization for each date range that corresponds to given grain
     (Daily, Monthly). Suppose the API call is for usageDate > 2025-03-01 and usageDate < 2022-10-31
     at a daily granularity. There will be one record per benefit id for each day. For a single day,
     the maxUtilizationPercentage value will be equal to the largest in the set of values where the
     set contains 24 utilization percentage entries one for each hour in a specific day. If on the
     day 2022-10-18, the largest utilization percentage was 90% at hour 5, then the value for the
     maxUtilizationPercentage in the response will be 90%."""

    @overload
    def __init__(
        self,
        *,
        benefit_type: Optional[Union[str, "_models.BenefitKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduledAction(ProxyResource):
    """Scheduled action definition.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the scheduled action.
    :vartype properties: ~azure.mgmt.costmanagement.models.ScheduledActionProperties
    :ivar e_tag: Resource Etag. For update calls, eTag is optional and can be specified to achieve
     optimistic concurrency. Fetch the resource's eTag by doing a 'GET' call first and then
     including the latest eTag as part of the request body or 'If-Match' header while performing the
     update. For create calls, eTag is not required.
    :vartype e_tag: str
    :ivar kind: Kind of the scheduled action. Known values are: "Email" and "InsightAlert".
    :vartype kind: str or ~azure.mgmt.costmanagement.models.ScheduledActionKind
    """

    properties: Optional["_models.ScheduledActionProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the scheduled action."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read", "create", "update", "delete", "query"])
    """Resource Etag. For update calls, eTag is optional and can be specified to achieve optimistic
     concurrency. Fetch the resource's eTag by doing a 'GET' call first and then including the
     latest eTag as part of the request body or 'If-Match' header while performing the update. For
     create calls, eTag is not required."""
    kind: Optional[Union[str, "_models.ScheduledActionKind"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Kind of the scheduled action. Known values are: \"Email\" and \"InsightAlert\"."""

    __flattened_items = [
        "display_name",
        "file_destination",
        "notification",
        "notification_email",
        "schedule",
        "scope",
        "status",
        "view_id",
    ]

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ScheduledActionProperties"] = None,
        e_tag: Optional[str] = None,
        kind: Optional[Union[str, "_models.ScheduledActionKind"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.properties is None:
                return None
            return getattr(self.properties, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.properties is None:
                self.properties = self._attr_to_rest_field["properties"]._class_type()
            setattr(self.properties, key, value)
        else:
            super().__setattr__(key, value)


class ScheduledActionProperties(_Model):
    """The properties of the scheduled action.

    :ivar display_name: Scheduled action name. Required.
    :vartype display_name: str
    :ivar file_destination: Destination format of the view data. This is optional.
    :vartype file_destination: ~azure.mgmt.costmanagement.models.FileDestination
    :ivar notification: Notification properties based on scheduled action kind. Required.
    :vartype notification: ~azure.mgmt.costmanagement.models.NotificationProperties
    :ivar notification_email: Email address of the point of contact that should get the unsubscribe
     requests and notification emails.
    :vartype notification_email: str
    :ivar schedule: Schedule of the scheduled action. Required.
    :vartype schedule: ~azure.mgmt.costmanagement.models.ScheduleProperties
    :ivar scope: For private scheduled action(Create or Update), scope will be empty.<br /> For
     shared scheduled action(Create or Update By Scope), Cost Management scope can be
     'subscriptions/{subscriptionId}' for subscription scope,
     'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     Department scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     for EnrollmentAccount scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     for BillingProfile scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     for InvoiceSection scope,
     '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     ExternalBillingAccount scope, and
     '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
     ExternalSubscription scope.
    :vartype scope: str
    :ivar status: Status of the scheduled action. Required. Known values are: "Enabled", "Expired",
     and "Disabled".
    :vartype status: str or ~azure.mgmt.costmanagement.models.ScheduledActionStatus
    :ivar view_id: Cost analysis viewId used for scheduled action. For example,
     '/providers/Microsoft.CostManagement/views/swaggerExample'. Required.
    :vartype view_id: str
    """

    display_name: str = rest_field(name="displayName", visibility=["read", "create", "update", "delete", "query"])
    """Scheduled action name. Required."""
    file_destination: Optional["_models.FileDestination"] = rest_field(
        name="fileDestination", visibility=["read", "create", "update", "delete", "query"]
    )
    """Destination format of the view data. This is optional."""
    notification: "_models.NotificationProperties" = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Notification properties based on scheduled action kind. Required."""
    notification_email: Optional[str] = rest_field(
        name="notificationEmail", visibility=["read", "create", "update", "delete", "query"]
    )
    """Email address of the point of contact that should get the unsubscribe requests and notification
     emails."""
    schedule: "_models.ScheduleProperties" = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Schedule of the scheduled action. Required."""
    scope: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """For private scheduled action(Create or Update), scope will be empty.<br /> For shared scheduled
     action(Create or Update By Scope), Cost Management scope can be
     'subscriptions/{subscriptionId}' for subscription scope,
     'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     Department scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     for EnrollmentAccount scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     for BillingProfile scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     for InvoiceSection scope,
     '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     ExternalBillingAccount scope, and
     '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
     ExternalSubscription scope."""
    status: Union[str, "_models.ScheduledActionStatus"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Status of the scheduled action. Required. Known values are: \"Enabled\", \"Expired\", and
     \"Disabled\"."""
    view_id: str = rest_field(name="viewId", visibility=["read", "create", "update", "delete", "query"])
    """Cost analysis viewId used for scheduled action. For example,
     '/providers/Microsoft.CostManagement/views/swaggerExample'. Required."""

    @overload
    def __init__(
        self,
        *,
        display_name: str,
        notification: "_models.NotificationProperties",
        schedule: "_models.ScheduleProperties",
        status: Union[str, "_models.ScheduledActionStatus"],
        view_id: str,
        file_destination: Optional["_models.FileDestination"] = None,
        notification_email: Optional[str] = None,
        scope: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduleProperties(_Model):
    """The properties of the schedule.

    :ivar frequency: Frequency of the schedule. Required. Known values are: "Daily", "Weekly", and
     "Monthly".
    :vartype frequency: str or ~azure.mgmt.costmanagement.models.ScheduleFrequency
    :ivar hour_of_day: UTC time at which cost analysis data will be emailed.
    :vartype hour_of_day: int
    :ivar days_of_week: Day names in english on which cost analysis data will be emailed. This
     property is applicable when frequency is Weekly or Monthly.
    :vartype days_of_week: list[str or ~azure.mgmt.costmanagement.models.DaysOfWeek]
    :ivar weeks_of_month: Weeks in which cost analysis data will be emailed. This property is
     applicable when frequency is Monthly and used in combination with daysOfWeek.
    :vartype weeks_of_month: list[str or ~azure.mgmt.costmanagement.models.WeeksOfMonth]
    :ivar day_of_month: UTC day on which cost analysis data will be emailed. Must be between 1 and
     31. This property is applicable when frequency is Monthly and overrides weeksOfMonth or
     daysOfWeek.
    :vartype day_of_month: int
    :ivar start_date: The start date and time of the scheduled action (UTC). Required.
    :vartype start_date: ~datetime.datetime
    :ivar end_date: The end date and time of the scheduled action (UTC). Required.
    :vartype end_date: ~datetime.datetime
    """

    frequency: Union[str, "_models.ScheduleFrequency"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Frequency of the schedule. Required. Known values are: \"Daily\", \"Weekly\", and \"Monthly\"."""
    hour_of_day: Optional[int] = rest_field(
        name="hourOfDay", visibility=["read", "create", "update", "delete", "query"]
    )
    """UTC time at which cost analysis data will be emailed."""
    days_of_week: Optional[list[Union[str, "_models.DaysOfWeek"]]] = rest_field(
        name="daysOfWeek", visibility=["read", "create", "update", "delete", "query"]
    )
    """Day names in english on which cost analysis data will be emailed. This property is applicable
     when frequency is Weekly or Monthly."""
    weeks_of_month: Optional[list[Union[str, "_models.WeeksOfMonth"]]] = rest_field(
        name="weeksOfMonth", visibility=["read", "create", "update", "delete", "query"]
    )
    """Weeks in which cost analysis data will be emailed. This property is applicable when frequency
     is Monthly and used in combination with daysOfWeek."""
    day_of_month: Optional[int] = rest_field(
        name="dayOfMonth", visibility=["read", "create", "update", "delete", "query"]
    )
    """UTC day on which cost analysis data will be emailed. Must be between 1 and 31. This property is
     applicable when frequency is Monthly and overrides weeksOfMonth or daysOfWeek."""
    start_date: datetime.datetime = rest_field(
        name="startDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The start date and time of the scheduled action (UTC). Required."""
    end_date: datetime.datetime = rest_field(
        name="endDate", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The end date and time of the scheduled action (UTC). Required."""

    @overload
    def __init__(
        self,
        *,
        frequency: Union[str, "_models.ScheduleFrequency"],
        start_date: datetime.datetime,
        end_date: datetime.datetime,
        hour_of_day: Optional[int] = None,
        days_of_week: Optional[list[Union[str, "_models.DaysOfWeek"]]] = None,
        weeks_of_month: Optional[list[Union[str, "_models.WeeksOfMonth"]]] = None,
        day_of_month: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Setting(ProxyResource):
    """Setting definition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    TagInheritanceSetting

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar kind: Metadata used by portal/tooling/etc to render different UX experiences for
     resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported,
     the resource provider must validate and persist this value. Required. "taginheritance"
    :vartype kind: str or ~azure.mgmt.costmanagement.models.SettingsKind
    """

    __mapping__: dict[str, _Model] = {}
    kind: str = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])
    """Metadata used by portal/tooling/etc to render different UX experiences for resources of the
     same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource
     provider must validate and persist this value. Required. \"taginheritance\""""

    @overload
    def __init__(
        self,
        *,
        kind: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SharedScopeBenefitRecommendationProperties(
    BenefitRecommendationProperties, discriminator="Shared"
):  # pylint: disable=name-too-long
    """The properties of the benefit recommendation when scope is 'Shared'.

    :ivar first_consumption_date: The first usage date used for looking back for computing the
     recommendations.
    :vartype first_consumption_date: ~datetime.datetime
    :ivar last_consumption_date: The last usage date used for looking back for computing the
     recommendations.
    :vartype last_consumption_date: ~datetime.datetime
    :ivar look_back_period: The number of days of usage evaluated for computing the
     recommendations. Known values are: "Last7Days", "Last30Days", and "Last60Days".
    :vartype look_back_period: str or ~azure.mgmt.costmanagement.models.LookBackPeriod
    :ivar total_hours: The total hours for which the cost is covered. Its equal to number of
     records in a property 'properties/usage/charges'.
    :vartype total_hours: int
    :ivar usage: On-demand charges between firstConsumptionDate and lastConsumptionDate that were
     used for computing benefit recommendations.
    :vartype usage: ~azure.mgmt.costmanagement.models.RecommendationUsageDetails
    :ivar arm_sku_name: ARM SKU name. 'Compute_Savings_Plan' for SavingsPlan.
    :vartype arm_sku_name: str
    :ivar term: Term period of the benefit. For example, P1Y or P3Y. Known values are: "P1Y" and
     "P3Y".
    :vartype term: str or ~azure.mgmt.costmanagement.models.Term
    :ivar commitment_granularity: Grain of the proposed commitment amount. Supported values:
     'Hourly'. Known values are: "Hourly", "Daily", and "Monthly".
    :vartype commitment_granularity: str or ~azure.mgmt.costmanagement.models.Grain
    :ivar currency_code: An ISO 4217 currency code identifier for the costs and savings amounts.
    :vartype currency_code: str
    :ivar cost_without_benefit: The current cost without benefit, corresponds to 'totalHours' in
     the look-back period.
    :vartype cost_without_benefit: ~decimal.Decimal
    :ivar recommendation_details: The details of the proposed recommendation.
    :vartype recommendation_details: ~azure.mgmt.costmanagement.models.AllSavingsBenefitDetails
    :ivar all_recommendation_details: The list of all benefit recommendations with the
     recommendation details.
    :vartype all_recommendation_details: ~azure.mgmt.costmanagement.models.AllSavingsList
    :ivar scope: Benefit scope. For example, Single or Shared. Required. Shared scope
     recommendation.
    :vartype scope: str or ~azure.mgmt.costmanagement.models.SHARED
    """

    scope: Literal[Scope.SHARED] = rest_discriminator(name="scope", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Benefit scope. For example, Single or Shared. Required. Shared scope recommendation."""

    @overload
    def __init__(
        self,
        *,
        look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = None,
        usage: Optional["_models.RecommendationUsageDetails"] = None,
        term: Optional[Union[str, "_models.Term"]] = None,
        commitment_granularity: Optional[Union[str, "_models.Grain"]] = None,
        recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.scope = Scope.SHARED  # type: ignore


class SingleScopeBenefitRecommendationProperties(
    BenefitRecommendationProperties, discriminator="Single"
):  # pylint: disable=name-too-long
    """The properties of the benefit recommendations when scope is 'Single'.

    :ivar first_consumption_date: The first usage date used for looking back for computing the
     recommendations.
    :vartype first_consumption_date: ~datetime.datetime
    :ivar last_consumption_date: The last usage date used for looking back for computing the
     recommendations.
    :vartype last_consumption_date: ~datetime.datetime
    :ivar look_back_period: The number of days of usage evaluated for computing the
     recommendations. Known values are: "Last7Days", "Last30Days", and "Last60Days".
    :vartype look_back_period: str or ~azure.mgmt.costmanagement.models.LookBackPeriod
    :ivar total_hours: The total hours for which the cost is covered. Its equal to number of
     records in a property 'properties/usage/charges'.
    :vartype total_hours: int
    :ivar usage: On-demand charges between firstConsumptionDate and lastConsumptionDate that were
     used for computing benefit recommendations.
    :vartype usage: ~azure.mgmt.costmanagement.models.RecommendationUsageDetails
    :ivar arm_sku_name: ARM SKU name. 'Compute_Savings_Plan' for SavingsPlan.
    :vartype arm_sku_name: str
    :ivar term: Term period of the benefit. For example, P1Y or P3Y. Known values are: "P1Y" and
     "P3Y".
    :vartype term: str or ~azure.mgmt.costmanagement.models.Term
    :ivar commitment_granularity: Grain of the proposed commitment amount. Supported values:
     'Hourly'. Known values are: "Hourly", "Daily", and "Monthly".
    :vartype commitment_granularity: str or ~azure.mgmt.costmanagement.models.Grain
    :ivar currency_code: An ISO 4217 currency code identifier for the costs and savings amounts.
    :vartype currency_code: str
    :ivar cost_without_benefit: The current cost without benefit, corresponds to 'totalHours' in
     the look-back period.
    :vartype cost_without_benefit: ~decimal.Decimal
    :ivar recommendation_details: The details of the proposed recommendation.
    :vartype recommendation_details: ~azure.mgmt.costmanagement.models.AllSavingsBenefitDetails
    :ivar all_recommendation_details: The list of all benefit recommendations with the
     recommendation details.
    :vartype all_recommendation_details: ~azure.mgmt.costmanagement.models.AllSavingsList
    :ivar subscription_id: The subscription ID that this single scope recommendation is for.
     Applicable only if recommendation is for 'Single' scope.
    :vartype subscription_id: str
    :ivar resource_group: The resource group that this single scope recommendation is for.
     Applicable only if recommendation is for 'Single' scope and 'ResourceGroup' request scope.
    :vartype resource_group: str
    :ivar scope: Benefit scope. For example, Single or Shared. Required. Single scope
     recommendation.
    :vartype scope: str or ~azure.mgmt.costmanagement.models.SINGLE
    """

    subscription_id: Optional[str] = rest_field(name="subscriptionId", visibility=["read"])
    """The subscription ID that this single scope recommendation is for. Applicable only if
     recommendation is for 'Single' scope."""
    resource_group: Optional[str] = rest_field(name="resourceGroup", visibility=["read"])
    """The resource group that this single scope recommendation is for. Applicable only if
     recommendation is for 'Single' scope and 'ResourceGroup' request scope."""
    scope: Literal[Scope.SINGLE] = rest_discriminator(name="scope", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Benefit scope. For example, Single or Shared. Required. Single scope recommendation."""

    @overload
    def __init__(
        self,
        *,
        look_back_period: Optional[Union[str, "_models.LookBackPeriod"]] = None,
        usage: Optional["_models.RecommendationUsageDetails"] = None,
        term: Optional[Union[str, "_models.Term"]] = None,
        commitment_granularity: Optional[Union[str, "_models.Grain"]] = None,
        recommendation_details: Optional["_models.AllSavingsBenefitDetails"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.scope = Scope.SINGLE  # type: ignore


class SourceCostAllocationResource(CostAllocationResource):
    """Source resources for cost allocation.

    :ivar resource_type: Type of resources contained in this cost allocation rule. Required. Known
     values are: "Dimension" and "Tag".
    :vartype resource_type: str or ~azure.mgmt.costmanagement.models.CostAllocationResourceType
    :ivar name: If resource type is dimension, this must be either ResourceGroupName or
     SubscriptionId. If resource type is tag, this must be a valid Azure tag. Required.
    :vartype name: str
    :ivar values_property: Source Resources for cost allocation. This list cannot contain more than
     25 values. Required.
    :vartype values_property: list[str]
    """

    values_property: list[str] = rest_field(name="values", visibility=["read", "create", "update", "delete", "query"])
    """Source Resources for cost allocation. This list cannot contain more than 25 values. Required."""

    @overload
    def __init__(
        self,
        *,
        resource_type: Union[str, "_models.CostAllocationResourceType"],
        name: str,
        values_property: list[str],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Status(_Model):
    """The status of the long running operation.

    :ivar status: The status of the long running operation. Known values are: "InProgress",
     "Completed", "Failed", "Queued", "NoDataFound", "ReadyToDownload", and "TimedOut".
    :vartype status: str or ~azure.mgmt.costmanagement.models.ReportOperationStatusType
    """

    status: Optional[Union[str, "_models.ReportOperationStatusType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The status of the long running operation. Known values are: \"InProgress\", \"Completed\",
     \"Failed\", \"Queued\", \"NoDataFound\", \"ReadyToDownload\", and \"TimedOut\"."""

    @overload
    def __init__(
        self,
        *,
        status: Optional[Union[str, "_models.ReportOperationStatusType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemAssignedServiceIdentity(_Model):
    """Managed service identity (either system assigned, or none).

    :ivar principal_id: The service principal ID of the system assigned identity. This property
     will only be provided for a system assigned identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of the system assigned identity. This property will only be
     provided for a system assigned identity.
    :vartype tenant_id: str
    :ivar type: The type of managed identity assigned to this resource. Required. Known values are:
     "None" and "SystemAssigned".
    :vartype type: str or ~azure.mgmt.costmanagement.models.SystemAssignedServiceIdentityType
    """

    principal_id: Optional[str] = rest_field(name="principalId", visibility=["read"])
    """The service principal ID of the system assigned identity. This property will only be provided
     for a system assigned identity."""
    tenant_id: Optional[str] = rest_field(name="tenantId", visibility=["read"])
    """The tenant ID of the system assigned identity. This property will only be provided for a system
     assigned identity."""
    type: Union[str, "_models.SystemAssignedServiceIdentityType"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of managed identity assigned to this resource. Required. Known values are: \"None\"
     and \"SystemAssigned\"."""

    @overload
    def __init__(
        self,
        *,
        type: Union[str, "_models.SystemAssignedServiceIdentityType"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemData(_Model):
    """Metadata pertaining to creation and last modification of the resource.

    :ivar created_by: The identity that created the resource.
    :vartype created_by: str
    :ivar created_by_type: The type of identity that created the resource. Known values are:
     "User", "Application", "ManagedIdentity", and "Key".
    :vartype created_by_type: str or ~azure.mgmt.costmanagement.models.CreatedByType
    :ivar created_at: The timestamp of resource creation (UTC).
    :vartype created_at: ~datetime.datetime
    :ivar last_modified_by: The identity that last modified the resource.
    :vartype last_modified_by: str
    :ivar last_modified_by_type: The type of identity that last modified the resource. Known values
     are: "User", "Application", "ManagedIdentity", and "Key".
    :vartype last_modified_by_type: str or ~azure.mgmt.costmanagement.models.CreatedByType
    :ivar last_modified_at: The timestamp of resource last modification (UTC).
    :vartype last_modified_at: ~datetime.datetime
    """

    created_by: Optional[str] = rest_field(name="createdBy", visibility=["read", "create", "update", "delete", "query"])
    """The identity that created the resource."""
    created_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="createdByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that created the resource. Known values are: \"User\", \"Application\",
     \"ManagedIdentity\", and \"Key\"."""
    created_at: Optional[datetime.datetime] = rest_field(
        name="createdAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource creation (UTC)."""
    last_modified_by: Optional[str] = rest_field(
        name="lastModifiedBy", visibility=["read", "create", "update", "delete", "query"]
    )
    """The identity that last modified the resource."""
    last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = rest_field(
        name="lastModifiedByType", visibility=["read", "create", "update", "delete", "query"]
    )
    """The type of identity that last modified the resource. Known values are: \"User\",
     \"Application\", \"ManagedIdentity\", and \"Key\"."""
    last_modified_at: Optional[datetime.datetime] = rest_field(
        name="lastModifiedAt", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """The timestamp of resource last modification (UTC)."""

    @overload
    def __init__(
        self,
        *,
        created_by: Optional[str] = None,
        created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        created_at: Optional[datetime.datetime] = None,
        last_modified_by: Optional[str] = None,
        last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
        last_modified_at: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TagInheritanceProperties(_Model):
    """The properties of the tag inheritance setting.

    :ivar prefer_container_tags: This property defines the behavior when an inherited tag being
     applied matches a lower scope tag (Eg. Subscription tag matches the resource tag). If set to
     true - when tags match, the highest scope tags will be applied. Billing profile is the highest
     scope,  followed by invoice sections, subscriptions and resource groups (allows overriding of
     lower scope tag values). If set to false - when tags match, the lowest scope tags will be
     applied. So, if a resource has the same tag as a subscription tag, the resource tag will be
     applied (does not allow overriding of lower scope tag values). Required.
    :vartype prefer_container_tags: bool
    """

    prefer_container_tags: bool = rest_field(
        name="preferContainerTags", visibility=["read", "create", "update", "delete", "query"]
    )
    """This property defines the behavior when an inherited tag being applied matches a lower scope
     tag (Eg. Subscription tag matches the resource tag). If set to true - when tags match, the
     highest scope tags will be applied. Billing profile is the highest scope,  followed by invoice
     sections, subscriptions and resource groups (allows overriding of lower scope tag values). If
     set to false - when tags match, the lowest scope tags will be applied. So, if a resource has
     the same tag as a subscription tag, the resource tag will be applied (does not allow overriding
     of lower scope tag values). Required."""

    @overload
    def __init__(
        self,
        *,
        prefer_container_tags: bool,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TagInheritanceSetting(Setting, discriminator="taginheritance"):
    """Tag Inheritance Setting definition.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the tag inheritance setting.
    :vartype properties: ~azure.mgmt.costmanagement.models.TagInheritanceProperties
    :ivar kind: Specifies the kind of settings. Required.
    :vartype kind: str or ~azure.mgmt.costmanagement.models.TAGINHERITANCE
    """

    properties: Optional["_models.TagInheritanceProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the tag inheritance setting."""
    kind: Literal[SettingsKind.TAGINHERITANCE] = rest_discriminator(name="kind", visibility=["read", "create", "update", "delete", "query"])  # type: ignore
    """Specifies the kind of settings. Required."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.TagInheritanceProperties"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.kind = SettingsKind.TAGINHERITANCE  # type: ignore


class TargetCostAllocationResource(CostAllocationResource):
    """Target resources for cost allocation.

    :ivar resource_type: Type of resources contained in this cost allocation rule. Required. Known
     values are: "Dimension" and "Tag".
    :vartype resource_type: str or ~azure.mgmt.costmanagement.models.CostAllocationResourceType
    :ivar name: If resource type is dimension, this must be either ResourceGroupName or
     SubscriptionId. If resource type is tag, this must be a valid Azure tag. Required.
    :vartype name: str
    :ivar values_property: Target resources for cost allocation. This list cannot contain more than
     25 values. Required.
    :vartype values_property: list[~azure.mgmt.costmanagement.models.CostAllocationProportion]
    :ivar policy_type: Method of cost allocation for the rule. Required. "FixedProportion"
    :vartype policy_type: str or ~azure.mgmt.costmanagement.models.CostAllocationPolicyType
    """

    values_property: list["_models.CostAllocationProportion"] = rest_field(
        name="values", visibility=["read", "create", "update", "delete", "query"]
    )
    """Target resources for cost allocation. This list cannot contain more than 25 values. Required."""
    policy_type: Union[str, "_models.CostAllocationPolicyType"] = rest_field(
        name="policyType", visibility=["read", "create", "update", "delete", "query"]
    )
    """Method of cost allocation for the rule. Required. \"FixedProportion\""""

    @overload
    def __init__(
        self,
        *,
        resource_type: Union[str, "_models.CostAllocationResourceType"],
        name: str,
        values_property: list["_models.CostAllocationProportion"],
        policy_type: Union[str, "_models.CostAllocationPolicyType"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class View(ProxyResource):
    """States and configurations of Cost Analysis.

    :ivar id: Fully qualified resource ID for the resource. Ex -
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
    :vartype id: str
    :ivar name: The name of the resource.
    :vartype name: str
    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
     "Microsoft.Storage/storageAccounts".
    :vartype type: str
    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
     information.
    :vartype system_data: ~azure.mgmt.costmanagement.models.SystemData
    :ivar properties: The properties of the view.
    :vartype properties: ~azure.mgmt.costmanagement.models.ViewProperties
    :ivar e_tag: eTag of the resource. To handle concurrent update scenario, this field will be
     used to determine whether the user is updating the latest version or not.
    :vartype e_tag: str
    """

    properties: Optional["_models.ViewProperties"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """The properties of the view."""
    e_tag: Optional[str] = rest_field(name="eTag", visibility=["read", "create", "update", "delete", "query"])
    """eTag of the resource. To handle concurrent update scenario, this field will be used to
     determine whether the user is updating the latest version or not."""

    @overload
    def __init__(
        self,
        *,
        properties: Optional["_models.ViewProperties"] = None,
        e_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ViewProperties(_Model):
    """The properties of the view.

    :ivar display_name: User input name of the view. Required.
    :vartype display_name: str
    :ivar scope: Cost Management scope to save the view on. This includes
     'subscriptions/{subscriptionId}' for subscription scope,
     'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     Department scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     for EnrollmentAccount scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     for BillingProfile scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
     for Management Group scope,
     '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     ExternalBillingAccount scope, and
     '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
     ExternalSubscription scope.
    :vartype scope: str
    :ivar created_on: Date the user created this view.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: Date when the user last modified this view.
    :vartype modified_on: ~datetime.datetime
    :ivar date_range: Date range of the current view.
    :vartype date_range: str
    :ivar currency: Currency of the current view.
    :vartype currency: str
    :ivar query: Query body configuration. Required.
    :vartype query: ~azure.mgmt.costmanagement.models.ReportConfigDefinition
    :ivar chart: Chart type of the main view in Cost Analysis. Required. Known values are: "Area",
     "Line", "StackedColumn", "GroupedColumn", and "Table".
    :vartype chart: str or ~azure.mgmt.costmanagement.models.ChartType
    :ivar accumulated: Show costs accumulated over time. Known values are: "true" and "false".
    :vartype accumulated: str or ~azure.mgmt.costmanagement.models.AccumulatedType
    :ivar metric: Metric to use when displaying costs. Known values are: "ActualCost",
     "AmortizedCost", and "AHUB".
    :vartype metric: str or ~azure.mgmt.costmanagement.models.MetricType
    :ivar kpis: List of KPIs to show in Cost Analysis UI.
    :vartype kpis: list[~azure.mgmt.costmanagement.models.KpiProperties]
    :ivar pivots: Configuration of 3 sub-views in the Cost Analysis UI.
    :vartype pivots: list[~azure.mgmt.costmanagement.models.PivotProperties]
    """

    display_name: Optional[str] = rest_field(
        name="displayName", visibility=["read", "create", "update", "delete", "query"]
    )
    """User input name of the view. Required."""
    scope: Optional[str] = rest_field(visibility=["read", "create", "update", "delete", "query"])
    """Cost Management scope to save the view on. This includes 'subscriptions/{subscriptionId}' for
     subscription scope, 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
     resourceGroup scope, 'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for
     Billing Account scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     Department scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     for EnrollmentAccount scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     for BillingProfile scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
     for Management Group scope,
     '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     ExternalBillingAccount scope, and
     '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
     ExternalSubscription scope."""
    created_on: Optional[datetime.datetime] = rest_field(name="createdOn", visibility=["read"], format="rfc3339")
    """Date the user created this view."""
    modified_on: Optional[datetime.datetime] = rest_field(
        name="modifiedOn", visibility=["read", "create", "update", "delete", "query"], format="rfc3339"
    )
    """Date when the user last modified this view."""
    date_range: Optional[str] = rest_field(name="dateRange", visibility=["read", "create", "update", "delete", "query"])
    """Date range of the current view."""
    currency: Optional[str] = rest_field(visibility=["read"])
    """Currency of the current view."""
    query: Optional["_models.ReportConfigDefinition"] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Query body configuration. Required."""
    chart: Optional[Union[str, "_models.ChartType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Chart type of the main view in Cost Analysis. Required. Known values are: \"Area\", \"Line\",
     \"StackedColumn\", \"GroupedColumn\", and \"Table\"."""
    accumulated: Optional[Union[str, "_models.AccumulatedType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Show costs accumulated over time. Known values are: \"true\" and \"false\"."""
    metric: Optional[Union[str, "_models.MetricType"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Metric to use when displaying costs. Known values are: \"ActualCost\", \"AmortizedCost\", and
     \"AHUB\"."""
    kpis: Optional[list["_models.KpiProperties"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """List of KPIs to show in Cost Analysis UI."""
    pivots: Optional[list["_models.PivotProperties"]] = rest_field(
        visibility=["read", "create", "update", "delete", "query"]
    )
    """Configuration of 3 sub-views in the Cost Analysis UI."""

    __flattened_items = ["type", "timeframe", "time_period", "data_set", "include_monetary_commitment"]

    @overload
    def __init__(
        self,
        *,
        display_name: Optional[str] = None,
        scope: Optional[str] = None,
        modified_on: Optional[datetime.datetime] = None,
        date_range: Optional[str] = None,
        query: Optional["_models.ReportConfigDefinition"] = None,
        chart: Optional[Union[str, "_models.ChartType"]] = None,
        accumulated: Optional[Union[str, "_models.AccumulatedType"]] = None,
        metric: Optional[Union[str, "_models.MetricType"]] = None,
        kpis: Optional[list["_models.KpiProperties"]] = None,
        pivots: Optional[list["_models.PivotProperties"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        :param mapping: raw JSON to initialize the model.
        :type mapping: Mapping[str, Any]
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        _flattened_input = {k: kwargs.pop(k) for k in kwargs.keys() & self.__flattened_items}
        super().__init__(*args, **kwargs)
        for k, v in _flattened_input.items():
            setattr(self, k, v)

    def __getattr__(self, name: str) -> Any:
        if name in self.__flattened_items:
            if self.query is None:
                return None
            return getattr(self.query, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, key: str, value: Any) -> None:
        if key in self.__flattened_items:
            if self.query is None:
                self.query = self._attr_to_rest_field["query"]._class_type()
            setattr(self.query, key, value)
        else:
            super().__setattr__(key, value)
